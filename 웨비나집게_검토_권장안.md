# 웨비나 집계 명세서 검토 및 권장안

**검토일**: 2026년 2월 5일  
**검토 대상**: `웨비나집게.md` (개인 시청시간 & 세션 트래킹 전체 명세서)

---

## 📋 검토 요약

### ✅ 강점 (잘 설계된 부분)

1. **현 시스템과의 일관성 유지**
   - 기존 `presence/ping` API 확장 방식 채택
   - 기존 크론/버킷 구조 유지
   - `webinar_live_presence`의 목적 보존

2. **부하 최소화 설계**
   - heartbeat 기반 O(1) write 구조
   - 서버 중심 시청시간 계산 (조작 방지)
   - 라이브 화면 집계 쿼리 금지 원칙 준수

3. **단계적 구현 전략**
   - Phase 0 → Phase 1 → Phase 2로 명확한 단계 구분
   - 각 Phase별 DoD 정의

---

## ⚠️ 개선 권장 사항

### 1. Heartbeat 주기 정책 (7.1절)

**현재 제안**: 60초 권장 (30초는 정확하지만 비용↑, 120초는 오차↑)

**권장 수정**:
- **기본값: 120초 (현재 presence ping과 동일)**
  - 이유: 네트워크 요청 수 최소화 (부하 감소)
  - 시청시간 정확도는 ±2분 오차로 충분 (운영 KPI 목적)
- **설정 가능**: env 변수로 관리 (`SESSION_HEARTBEAT_INTERVAL_SECONDS`)
- **정확도가 중요한 경우**: Phase 2에서 선택적으로 60초로 조정 가능

**근거**:
- 현재 시스템이 이미 120초 주기로 안정적으로 동작 중
- 개인 시청시간은 "대략적인 참여도" 지표로 사용되므로 ±2분 오차는 허용 가능
- 60초로 줄이면 요청 수가 2배 증가 (비용/부하 증가)

---

### 2. 웨비나 종료시간 필드 설계 (4.1절)

**현재 제안**: `scheduled_end_time`, `actual_end_time` 2개 필드

**권장 수정**:
```sql
-- 기존: webinar_start_time (이미 존재)
-- 추가: 
webinar_scheduled_end_time TIMESTAMPTZ,  -- 예정 종료시간
webinar_actual_end_time TIMESTAMPTZ,     -- 실제 종료시간
```

**이유**:
- 기존 네이밍 컨벤션(`webinar_start_time`)과 일관성 유지
- `scheduled_end` / `actual_end`보다 명확함

**집계 윈도우 계산**:
```sql
-- 본편 종료시간 (우선순위: actual > scheduled)
content_to = COALESCE(webinar_actual_end_time, webinar_scheduled_end_time)

-- 수집 종료시간
collect_to = content_to + post_window_minutes
```

---

### 3. 세션 테이블 설계 보완 (5.1절)

**추가 권장 필드**:

```sql
CREATE TABLE webinar_user_sessions (
  -- ... 기존 필드 ...
  
  -- 추가 권장:
  session_key TEXT NOT NULL,  -- 클라이언트 생성 UUID (중복 방지)
  
  -- 인덱스 추가:
  CREATE UNIQUE INDEX uq_wus_session_key 
    ON webinar_user_sessions(session_key);
  
  -- 또는 복합 유니크 (같은 사용자가 같은 웨비나에 여러 세션 가능)
  CREATE UNIQUE INDEX uq_wus_webinar_user_session 
    ON webinar_user_sessions(webinar_id, user_id, session_key);
```

**세션 키 생성 규칙**:
- 클라이언트에서 `crypto.randomUUID()` 사용
- 페이지 진입 시 1회 생성, localStorage에 저장
- 재입장 시 새 session_key 생성 (새 세션으로 기록)

---

### 4. Presence/Ping API 확장 방식 (6.2절)

**현재 제안**: `presence/ping`에 `session_key` 옵션 필드 추가

**권장 구현**:

```typescript
// Request (하위호환)
POST /api/webinars/[webinarId]/presence/ping
Body: {
  session_key?: string,  // 옵션: 세션 추적 활성화 시
  view_state?: {
    is_visible?: boolean,
    is_active?: boolean
  }
}

// 서버 동작
1. 기존 presence ping 처리 (변경 없음)
2. session_key가 있으면:
   - 세션 조회/생성
   - heartbeat 업데이트 (Δt 누적)
3. view_state가 false면 누적 중지 (정책 1: 탭 visible만)
```

**중요**: 
- `session_key`가 없어도 기존 동작 유지 (하위호환)
- 세션 추적은 "옵트인" 방식 (클라이언트가 보내야 활성화)

---

### 5. 세션 Sweeper 크론 설계 (8.2절)

**현재 제안**: 5분 또는 10분 주기

**권장**:
- **주기: 10분** (기존 access-snapshot 크론과 분리)
- **대상**: `exited_at IS NULL AND last_heartbeat_at < now() - interval '5 minutes'`
- **처리**: 
  ```sql
  UPDATE webinar_user_sessions
  SET 
    exited_at = last_heartbeat_at,  -- now()가 아니라 last_heartbeat로 (과대계상 방지)
    closed_reason = 'timeout',
    updated_at = now()
  WHERE exited_at IS NULL 
    AND last_heartbeat_at < now() - interval '5 minutes'
  ```

**이유**:
- 5분은 너무 빈번 (비용 증가)
- 10분이면 충분히 stale 세션 정리 가능
- 기존 access-snapshot 크론(1분)과 분리하여 부하 분산

---

### 6. Δt Cap 정책 명확화 (7.1절)

**현재 제안**: heartbeat 간격의 2~3배

**권장 수정**:
```typescript
// 환경 변수
SESSION_HEARTBEAT_INTERVAL_SECONDS=120  // 기본값
SESSION_DELTA_CAP_MULTIPLIER=3          // 간격의 3배

// 계산
const deltaCap = SESSION_HEARTBEAT_INTERVAL_SECONDS * SESSION_DELTA_CAP_MULTIPLIER
// 예: 120 * 3 = 360초 (6분)

// 적용
const delta = Math.min(
  (now - last_heartbeat_at) / 1000,  // 초 단위
  deltaCap
)
```

**이유**:
- 탭 백그라운드/네트워크 지연으로 한 번에 20분 누적 방지
- 설정 가능하도록 env 변수로 관리

---

### 7. 통계 집계 쿼리 성능 최적화 (9.4절)

**현재 제안**: 인덱싱으로 해결, 필요 시 Phase 2에서 사전집계

**권장 보완**:

**인덱스 추가**:
```sql
-- 개인별 시청시간 집계용
CREATE INDEX idx_wus_webinar_user_watched 
  ON webinar_user_sessions(webinar_id, user_id, exited_at)
  WHERE exited_at IS NOT NULL;

-- 본편 시청시간 계산용 (시간 범위 쿼리)
CREATE INDEX idx_wus_webinar_entered_exited 
  ON webinar_user_sessions(webinar_id, entered_at, exited_at)
  WHERE exited_at IS NOT NULL;
```

**집계 쿼리 최적화**:
```sql
-- 개인별 시청시간 (본편 구간 보정)
WITH content_window AS (
  SELECT 
    webinar_start_time as content_from,
    COALESCE(webinar_actual_end_time, webinar_scheduled_end_time) as content_to
  FROM webinars
  WHERE id = $1
),
session_overlaps AS (
  SELECT 
    wus.user_id,
    GREATEST(wus.entered_at, cw.content_from) as overlap_start,
    LEAST(COALESCE(wus.exited_at, now()), cw.content_to) as overlap_end
  FROM webinar_user_sessions wus
  CROSS JOIN content_window cw
  WHERE wus.webinar_id = $1
    AND wus.entered_at < cw.content_to
    AND COALESCE(wus.exited_at, now()) > cw.content_from
)
SELECT 
  user_id,
  SUM(EXTRACT(EPOCH FROM (overlap_end - overlap_start)))::int as watched_seconds
FROM session_overlaps
GROUP BY user_id;
```

---

### 8. Multi-tab/Multi-device 정책 명확화 (12절)

**현재 제안**: "세션은 중복 허용(로그)" + "개인 KPI는 본편 길이로 상한(보정)"

**권장 정책 문서화**:

```markdown
## Multi-tab/Multi-device 정책

### 세션 레벨
- 각 탭/디바이스마다 별도 session_key 생성
- 중복 세션 허용 (로그 목적)

### 개인 KPI 집계
- 개인별 총 시청시간 = 모든 세션의 본편 구간 overlap 합계
- 상한: `min(총 시청시간, content_duration_seconds)` (과대계상 방지)
- 예: 웨비나 60분인데 2개 탭으로 90분 시청 → 60분으로 cap

### 동시 접속자 수
- 기존 `webinar_live_presence` 기반 집계 유지 (변경 없음)
- 세션 테이블과는 별개
```

---

## 🔧 구현 우선순위 조정

### Phase 0 (스케줄 선언) - **우선순위 상향 권장**

**이유**:
- 종료시간 필드가 없으면 Phase 1에서 "본편 구간 보정" 불가능
- UI 작업이 필요하므로 개발 리드타임 고려

**권장 순서**:
1. DB 마이그레이션 (종료시간 필드 추가)
2. 웨비나 설정 UI 수정 (종료시간 입력)
3. 통계 API에서 종료시간 사용 가능하도록 준비

---

### Phase 1 (세션 테이블 + heartbeat) - **하위호환성 강화**

**권장 수정**:
- `session_key`는 **옵션**으로 처리 (없어도 기존 동작 유지)
- 클라이언트는 점진적으로 `session_key` 전송 시작
- 기존 `presence/ping` 동작은 변경 없음

---

### Phase 2 (Sweeper + 통계 UX) - **성능 모니터링 추가**

**권장 추가**:
- 세션 sweeper 크론 실행 시간 모니터링
- 통계 쿼리 응답 시간 모니터링 (목표: 500ms 이내)
- 대용량 웨비나(1000+ 세션) 테스트

---

## 📊 예상 부하 재검토

### 현재 제안 vs 권장 수정 비교

| 항목 | 현재 제안 | 권장 수정 | 영향 |
|------|----------|----------|------|
| Heartbeat 주기 | 60초 | 120초 | 요청 수 50% 감소 |
| Sweeper 주기 | 5분 | 10분 | 크론 실행 50% 감소 |
| Δt Cap | 간격의 2~3배 | 간격의 3배 (명확화) | 동일 |

**예상 부하 (동시 시청자 600명)**:
- Heartbeat 60초: 10 RPS
- Heartbeat 120초: **5 RPS** (권장)
- DB Write: heartbeat당 2건 (presence upsert + session update)

**결론**: 권장 수정안이 부하를 더 줄이면서도 운영 목적에 충분함

---

## ✅ 최종 권장안 체크리스트

### Phase 0 (스케줄 선언)
- [ ] `webinar_scheduled_end_time`, `webinar_actual_end_time` 필드 추가
- [ ] 웨비나 설정 UI에 종료시간 입력 필드 추가
- [ ] 통계 API에서 종료시간 사용 가능하도록 준비

### Phase 1 (세션 테이블 + heartbeat)
- [ ] `webinar_user_sessions` 테이블 생성 (인덱스 포함)
- [ ] `presence/ping` API에 `session_key` 옵션 필드 추가 (하위호환)
- [ ] 클라이언트에서 `session_key` 생성 및 전송 로직 추가
- [ ] Heartbeat 주기: **120초** (env 변수로 설정 가능)
- [ ] Δt Cap: 간격의 3배 (env 변수로 설정 가능)

### Phase 2 (Sweeper + 통계 UX)
- [ ] 세션 sweeper 크론 추가 (10분 주기)
- [ ] 통계 API에 개인별 시청시간 집계 추가
- [ ] 통계 UI에 시청시간 섹션 추가
- [ ] 성능 모니터링 추가

---

## 🎯 핵심 권장 사항 요약

1. **Heartbeat 주기: 120초 유지** (60초 → 120초로 변경)
   - 부하 감소, 정확도는 충분

2. **종료시간 필드명: `webinar_scheduled_end_time`, `webinar_actual_end_time`**
   - 기존 네이밍 컨벤션과 일관성

3. **세션 sweeper: 10분 주기** (5분 → 10분)
   - 부하 감소, 충분한 정리 주기

4. **하위호환성 보장**
   - `session_key`는 옵션 필드로 처리
   - 기존 `presence/ping` 동작 변경 없음

5. **설정 가능성**
   - 모든 주기/캡 값은 env 변수로 관리 (하드코딩 금지)

---

## 📝 추가 검토 필요 사항

1. **세션 키 충돌 방지**
   - UUID 사용 시 충돌 확률은 매우 낮지만, 유니크 제약조건 필수

2. **대용량 웨비나 테스트**
   - 동시 접속자 1000+ 명 시나리오 테스트 필요
   - 세션 테이블 파티셔닝 고려 (장기 운영 시)

3. **데이터 정리 정책**
   - 오래된 세션 데이터 정리 크론 필요 (예: 90일 이상 된 데이터)

4. **모니터링 지표**
   - 세션 생성률, heartbeat 성공률, sweeper 처리 건수 모니터링

---

**검토 완료**: 위 권장 사항을 반영하여 명세서를 업데이트하는 것을 권장합니다.
