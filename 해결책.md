요 로그 패턴(“✅ SUBSCRIBED → 바로 ‘실시간 구독 해제’ → 상태 CLOSED → 재시도”)은 실시간 서버(수파베이스)가 연결을 끊어서가 아니라, 프론트 코드에서 구독 인스턴스를 곧바로 정리(unsubscribe/removeChannel)해 버리는 경쟁 상태 때문일 가능성이 큽니다. 정리되지 않은 setTimeout·중복 마운트·기존 채널 비동기 정리 등 몇 가지가 겹치면, 구독 성공 직후 본인 코드가 스스로 채널을 닫고(CLOSED) 다시 열고를 무한 반복합니다. 이건 스트리밍 기술의 한계라기보다 구독 수명 관리(lifecycle) 문제에 가깝습니다. 

Realtime_연결_끊김_문제_분석_보고서

왜 “성공 → 해제 → CLOSED”가 반복될까 (핵심 원인)

재연결 로직과 cleanup의 경합
subscribe 콜백에서 에러/타임아웃 시 setTimeout으로 재연결을 예약하면서 그 안에서 다시 unsubscribe/removeChannel까지 수행하면, 곧 이어질 useEffect의 cleanup과 중복 정리 → CLOSED가 납니다. 재연결은 채널 정리는 하지 말고 reconnectKey만 바꿔 useEffect 재실행에 cleanup을 맡기세요. 

Realtime_연결_끊김_문제_분석_보고서

타이머 정리 누락
재연결 setTimeout(그리고 폴백 재연결) 핸들이 useRef에 보관·cleanup에서 clearTimeout되지 않으면, 컴포넌트가 언마운트된 뒤에도 타이머가 살아 있어 이미 닫힌 채널을 또 닫으려 하고 새 채널을 또 열어 루프가 생깁니다. 

Realtime_연결_끊김_문제_분석_보고서

중복 마운트(모바일/데스크톱 두 군데에서 동시에 렌더)
화면에는 하나만 보이더라도 DOM에는 Chat 컴포넌트가 2개 마운트될 수 있습니다. 같은 webinarId로 두 채널을 구독했다가, 하나가 언마운트 되며 정리 → 다른 쪽까지 영향 → CLOSED 루프가 납니다. Chat은 한 번만 구독(또는 Provider로 단일 연결 공유)되게 하세요. 

Realtime_연결_끊김_문제_분석_보고서

기존 채널 정리를 await하지 않음
existingChannel.unsubscribe() 완료 전에 새 채널을 만들면 동시 다중 채널이 생겨 흔들립니다. 기존 채널 정리는 반드시 await 후 다음 단계로. 

Realtime_연결_끊김_문제_분석_보고서

별개이지만 치명적인 RLS 무한 재귀
동시에 보고된 profiles RLS 무한 재귀(500) 이슈는 권한 확인 API/미들웨어의 에러로 인해 화면 리마운트 → 구독 재생성을 유발할 수 있습니다. 권한 확인은 클라이언트 직접 질의 대신 서버/토큰 클레임으로 바꾸고, 슈퍼어드민 RLS는 단순화하세요. 

오류_보고서_RLS_무한재귀

“10분 패치” — 바로 적용할 변경 5가지

아래만 반영해도 “SUBSCRIBED 직후 CLOSED” 루프가 대부분 사라집니다.

재연결 타이머/폴백 타이머를 ref로 관리 + 전부 cleanup

// Chat.tsx
const reconnectTimeoutRef = useRef<number | null>(null);
const fallbackTimeoutRef  = useRef<number | null>(null);

useEffect(() => {
  // ... 구독 설정 ...

  const channel = supabase
    .channel(channelName, { config: { broadcast: { self: false }}})
    .on('postgres_changes', { event: '*', schema: 'public', table: 'messages',
                              filter: `webinar_id=eq.${webinarId}` }, onRowChange)
    .subscribe(async (status, err) => {
      if (status === 'SUBSCRIBED') {
        if (reconnectTimeoutRef.current) { clearTimeout(reconnectTimeoutRef.current); reconnectTimeoutRef.current = null; }
        if (fallbackTimeoutRef.current)  { clearTimeout(fallbackTimeoutRef.current);  fallbackTimeoutRef.current  = null; }
        // ...
      } else if (['CHANNEL_ERROR','TIMED_OUT','CLOSED'].includes(status)) {
        reconnectTriesRef.current += 1;

        if (reconnectTriesRef.current >= 3) {
          setFallbackOn(true);
          if (reconnectTimeoutRef.current) { clearTimeout(reconnectTimeoutRef.current); reconnectTimeoutRef.current = null; }
          fallbackTimeoutRef.current = window.setTimeout(() => {
            reconnectTriesRef.current = 0;
            setReconnectKey(k => k + 1);
            fallbackTimeoutRef.current = null;
          }, 30000);
          return;
        }

        const delay = Math.min(1000 * (2 ** (reconnectTriesRef.current - 1)) + Math.random()*250, 10000);
        if (reconnectTimeoutRef.current) clearTimeout(reconnectTimeoutRef.current);
        reconnectTimeoutRef.current = window.setTimeout(() => {
          setReconnectKey(k => k + 1);           // ✅ 채널 정리는 하지 않음
          reconnectTimeoutRef.current = null;
        }, delay);
      }
    });

  return () => {
    if (reconnectTimeoutRef.current) { clearTimeout(reconnectTimeoutRef.current); reconnectTimeoutRef.current = null; }
    if (fallbackTimeoutRef.current)  { clearTimeout(fallbackTimeoutRef.current);  fallbackTimeoutRef.current  = null; }
    channel.unsubscribe().finally(() => supabase.removeChannel(channel));
  };
}, [webinarId, reconnectKey]); // supabase 인스턴스는 싱글턴/메모이즈


포인트: 재연결 예약에서는 채널을 건드리지 말고, 정리는 cleanup에만 맡깁니다. 

Realtime_연결_끊김_문제_분석_보고서

기존 채널 정리 await

const existing = supabase.getChannels().find(ch => ch.topic === `realtime:${channelName}`);
if (existing) {
  await existing.unsubscribe();
  supabase.removeChannel(existing);
  await new Promise(r => setTimeout(r, 80)); // 정리 여유
}


Realtime_연결_끊김_문제_분석_보고서

중복 마운트 제거
모바일/데스크톱 둘 다 <Chat>을 렌더하지 말고, Chat 연결을 한 군데(Provider)에서만 생성하세요. UI는 컨텍스트만 구독. (또는 정말 두 군데 렌더해야 한다면, 연결은 Provider 1개가 들고 있고 두 UI는 상태만 보여주도록 분리) 

Realtime_연결_끊김_문제_분석_보고서

Supabase 클라이언트 싱글턴 보장
createClientSupabase()가 렌더마다 새 인스턴스를 만들지 않도록 **모듈 스코프 싱글턴/useMemo**로 고정하세요. 인스턴스가 바뀌면 채널도 같이 끊겼다 붙습니다. 

Realtime_연결_끊김_문제_분석_보고서

권한 확인(RLS) 경로 정리
profiles를 클라이언트에서 직접 읽지 말고, 서버 API 또는 JWT 클레임으로만 확인하도록 변경. 현재의 RLS 순환은 구독과 직접 연관 없어도 리마운트/리트라이 유발 요인입니다. 

오류_보고서_RLS_무한재귀