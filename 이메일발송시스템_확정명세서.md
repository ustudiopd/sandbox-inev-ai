# EventLive 이메일 제작/발송 대시보드 확정 명세서 v1.3

**작성일**: 2026-02-03  
**최종 수정**: 2026-02-03 (설계 감독관 최종 리뷰 반영 - RLS 정책/트리거 안정성 강화)  
**기반**: uslab.ai 뉴스레터 시스템 패턴  
**이메일 프로바이더**: Resend

**✅ 구현 착수 준비 완료**: 모든 P0 이슈 해결, 운영 결정 사항 명확화 완료, 운영 사고 방지 장치 완비

---

## 목차

1. [목적](#1-목적)
2. [핵심 컨셉](#2-핵심-컨셉)
3. [사용자/권한](#3-사용자권한)
4. [데이터 모델](#4-데이터-모델)
5. [발송 정책](#5-발송-정책)
6. [Resend 통합](#6-resend-통합)
7. [화면/UX](#7-화면ux)
8. [API 설계](#8-api-설계)
9. [발송 프로세스](#9-발송-프로세스)
10. [템플릿 변수 처리](#10-템플릿-변수-처리)
11. [대상자 쿼리](#11-대상자-쿼리)
12. [에러 처리 및 재시도](#12-에러-처리-및-재시도)
13. [기존 시스템 통합](#13-기존-시스템-통합)
14. [WERT 리마인드 적용](#14-wert-리마인드-적용)
15. [리스크/가드레일](#15-리스크가드레일)
16. [DoD (완료 기준)](#16-dod-완료-기준)
17. [구현 우선순위](#17-구현-우선순위)

---

## 1. 목적

- 클라이언트(고객사)가 메일 초안 작성/수정을 직접 할 수 있게 대시보드 제공
- 운영자는 테스트 발송 → 승인 → 실발송을 통제
- 멀티테넌시 환경에서 클라이언트별 발송 도메인/Reply-To 요구를 설정 기반으로 처리
- "바이브코딩"에서도 꼬이지 않도록 상태/로그/중복방지를 강제

---

## 2. 핵심 컨셉

uslab.ai의 구조(템플릿 DB + 초안 생성 + 편집 + test/send + run 로그 + 상태 전이)를 그대로 가져오되, EventLive는 "뉴스레터"가 아니라 이벤트/웨비나/등록캠페인 단위의 트랜잭션/리마인드 메일로 확장한다.

**상태 전이**:
```
draft → ready → sending → sent/failed
         ↑         ↓
         └─────────┘ (승인 취소: ready→draft)
         
ready → canceled (캠페인 취소)
```

**주의**: "승인 취소"와 "캠페인 취소"는 서로 다른 액션입니다.
- **승인 취소**: `ready` → `draft` (재편집 가능)
- **캠페인 취소**: `ready` → `canceled` (발송 중단, 재승인 불가)

---

## 3. 사용자/권한

### 3.1 대상 사용자

**Client 멤버**:
- `owner`: 모든 권한 (편집/승인/발송)
- `admin`: 편집/승인/발송 가능
- `operator`: 편집/승인/발송 가능
- `analyst`: 조회만 가능
- `viewer`: 조회만 가능

### 3.2 권한 원칙

- "누가/어느 클라이언트의 캠페인에 대해/어디까지"를 명확히
- 발송 권한은 최소 `owner`/`admin`/`operator`만
- `analyst`/`viewer`는 조회 및 통계만 가능

### 3.3 권한 확인 함수

기존 `requireClientMember()` 함수 활용:
```typescript
// lib/auth/guards.ts
const { user, role } = await requireClientMember(clientId, ['owner', 'admin', 'operator'])
```

---

## 4. 데이터 모델

### 4.1 email_templates (클라이언트별 템플릿)

**용도**: "리마인드/등록확인/후속안내" 같은 유형별 기본 템플릿 관리

**SQL 스키마**:
```sql
create table public.email_templates (
  id uuid primary key default gen_random_uuid(),
  agency_id uuid references public.agencies(id) on delete cascade,
  client_id uuid references public.clients(id) on delete cascade,
  template_key text not null, -- 예: 'webinar_reminder_d1', 'webinar_confirmation'
  subject_template text not null,
  body_md_template text not null, -- 마크다운 형식
  footer_md text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  
  -- 유니크 제약: client_id + template_key 조합은 유일
  constraint uniq_template_key unique (client_id, template_key)
);

create index idx_email_templates_client_id on public.email_templates(client_id);
create index idx_email_templates_template_key on public.email_templates(template_key);
```

**Phase 1에서는 생략 가능** (하드코딩된 템플릿 사용)

### 4.2 email_campaigns (메일 초안/발송 단위)

**SQL 스키마**:
```sql
create table public.email_campaigns (
  id uuid primary key default gen_random_uuid(),
  agency_id uuid references public.agencies(id) on delete cascade,
  client_id uuid not null references public.clients(id) on delete cascade,
  
  -- 대상 범위
  scope_type text not null check (scope_type in ('webinar', 'registration_campaign', 'survey_campaign')),
  scope_id uuid not null, -- webinarId, registration_campaign_id 등
  
  -- 캠페인 유형
  campaign_type text not null check (campaign_type in ('reminder_d1', 'reminder_h1', 'confirmation', 'custom')),
  
  -- 상태 관리
  status text not null default 'draft' check (status in ('draft', 'ready', 'sending', 'sent', 'failed', 'canceled')),
  
  -- 이메일 내용
  subject text not null,
  preheader text, -- 선택: 이메일 미리보기 텍스트
  body_md text not null, -- 마크다운 형식
  
  -- 템플릿 변수 (미리보기용)
  variables_json jsonb default '{}', -- 예: {"title": "...", "date": "...", "url": "..."}
  
  -- 대상자 규칙
  audience_query_json jsonb default '{}', -- 예: {"type": "webinar_registrants", "exclude_entered": true}
  
  -- 발송 설정
  scheduled_send_at timestamptz, -- 선택: 지금은 수동 발송만, 추후 자동화
  
  -- 승인 정보
  approved_at timestamptz,
  approved_by uuid references public.profiles(id),
  
  -- 발송 정보
  sending_started_at timestamptz,
  sent_at timestamptz,
  
  -- 발송 정책 override (선택)
  from_domain text, -- null이면 클라이언트 정책 사용
  from_localpart text, -- null이면 클라이언트 정책 사용
  from_name text, -- null이면 클라이언트 정책 사용
  reply_to text, -- null이면 클라이언트 정책 사용
  
  created_by uuid not null references public.profiles(id),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index idx_email_campaigns_client_id on public.email_campaigns(client_id);
create index idx_email_campaigns_scope on public.email_campaigns(scope_type, scope_id);
create index idx_email_campaigns_status on public.email_campaigns(status);
create index idx_email_campaigns_created_at on public.email_campaigns(created_at desc);
```

### 4.3 email_runs (실행 로그)

**SQL 스키마**:
```sql
create table public.email_runs (
  id uuid primary key default gen_random_uuid(),
  email_campaign_id uuid not null references public.email_campaigns(id) on delete cascade,
  
  run_type text not null check (run_type in ('generate', 'test_send', 'send')),
  status text not null check (status in ('success', 'failed')),
  provider text not null default 'resend' check (provider in ('resend', 'smtp')),
  
  -- 메타데이터
  meta_json jsonb default '{}', -- 예: {"total": 100, "success": 95, "failed": 5, "failed_samples": ["a@example.com", ...]}
  error text, -- 실패 요약
  
  created_by uuid references public.profiles(id),
  created_at timestamptz not null default now()
);

create index idx_email_runs_campaign_id on public.email_runs(email_campaign_id);
create index idx_email_runs_created_at on public.email_runs(created_at desc);
```

**⚠️ 중요: INSERT 권한 제한**
- `email_runs`는 **서버(service role)에서만 INSERT 가능**
- 클라이언트는 SELECT만 허용 (대시보드 조회용)
- RLS 정책으로 INSERT/UPDATE 차단 (로그 오염 방지)

### 4.4 email_send_logs (수신자 단위 로그: 중복방지 핵심)

**SQL 스키마**:
```sql
create table public.email_send_logs (
  id uuid primary key default gen_random_uuid(),
  email_campaign_id uuid not null references public.email_campaigns(id) on delete cascade,
  
  recipient_email text not null,
  status text not null check (status in ('queued', 'sent', 'failed')),
  
  provider_message_id text, -- Resend message ID
  error_message text,
  
  -- 중복 방지 키 (유니크)
  dedupe_key text not null,
  
  created_at timestamptz not null default now()
);

-- 중복 방지: dedupe_key는 유니크
create unique index uniq_email_send_logs_dedupe_key on public.email_send_logs(dedupe_key);
create index idx_email_send_logs_campaign_id on public.email_send_logs(email_campaign_id);
create index idx_email_send_logs_status on public.email_send_logs(status);
create index idx_email_send_logs_recipient_email on public.email_send_logs(recipient_email);
```

**⚠️ 중요: INSERT 권한 제한**
- `email_send_logs`는 **서버(service role)에서만 INSERT 가능**
- 클라이언트는 SELECT만 허용 (대시보드 조회용)
- RLS 정책으로 INSERT/UPDATE 차단 (로그 오염 방지)

**dedupe_key 생성 규칙**:
```typescript
// Phase 1: 캠페인 단위로 중복 방지 (재발송 가능)
const dedupeKey = `${campaignId}:${recipientEmail.toLowerCase()}`

// 참고: 원래 설계(clientId:scopeId:campaignType:email)는 
// "같은 웨비나+타입에 대해 평생 1회만"이라는 강한 제약이므로,
// Phase 1에서는 캠페인 단위로 완화하여 재발송/복구 가능하게 함
```

**중복 방지 정책 결정**:
- **Phase 1**: 캠페인 단위 (`campaignId:email`) - 동일 캠페인에서만 중복 방지, 재발송 가능
- **Phase 2 (선택)**: 범위 단위 (`clientId:scopeId:campaignType:email`) - 더 강한 중복 방지 필요 시

**재발송 정책 (운영 결정)**:
- ✅ **같은 캠페인에서 재시도**: 허용 안 함 (dedupe_key로 차단됨)
- ✅ **캠페인 복제 후 재발송**: 권장 방식 (문구 수정 후 새 캠페인 생성 → 발송)
- ⏳ **부분 재발송 (실패자만 재시도)**: Phase 2에서 별도 API 제공 예정
  - Phase 1에서는 실패한 수신자에게 재발송하려면 새 캠페인을 복제하여 생성해야 함

### 4.5 client_email_policies (클라이언트별 발송 정책)

**SQL 스키마**:
```sql
create table public.client_email_policies (
  id uuid primary key default gen_random_uuid(),
  client_id uuid not null unique references public.clients(id) on delete cascade,
  
  send_mode text not null default 'platform' check (send_mode in ('platform', 'white_label', 'customer_smtp')),
  from_domain text not null, -- 예: 'eventflow.kr'
  from_localpart_default text not null default 'notify', -- allowlist: 'no-reply', 'notify', 'reports', 'security'
  from_name_default text not null, -- 예: '모두의특강'
  reply_to_default text not null, -- 예: 'connect@wert.co.kr'
  link_base_url_default text, -- 예: 'https://eventflow.kr'
  
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index idx_client_email_policies_client_id on public.client_email_policies(client_id);
```

**WERT 기본값**:
- `from_domain`: `eventflow.kr`
- `from_localpart_default`: `notify`
- `from_name_default`: `모두의특강` (또는 클라이언트 이름)
- `reply_to_default`: `connect@wert.co.kr`

---

## 5. 발송 정책

### 5.1 정책 우선순위

1. **캠페인 override** (가장 높음): `email_campaigns.from_domain` 등이 설정된 경우
2. **클라이언트 정책**: `client_email_policies` 테이블 값
3. **기본값**: 시스템 기본값

### 5.2 From localpart allowlist

허용된 localpart만 사용 가능:
- `no-reply`
- `notify`
- `reports`
- `security`

화이트라벨 모드에서는 추가 도메인 인증 필요.

---

## 6. Resend 통합

### 6.1 환경 변수 설정

**⚠️ 보안 주의**: 실제 API 키는 문서/레포에 포함하지 않습니다.

`.env.local` (예시):
```env
RESEND_API_KEY=re_...  # 실제 키는 Vercel 환경변수 또는 개인 .env.local에만 저장
```

**설정 방법**:
1. Resend 대시보드에서 API 키 생성
2. 로컬 개발: `.env.local`에 저장 (gitignore됨)
3. 프로덕션: Vercel 환경변수에 저장
4. **절대** 문서/코드/커밋에 실제 키 포함 금지

### 6.2 도메인 인증

1. Resend 대시보드에서 도메인 인증 필요
2. `eventflow.kr` 도메인 인증 완료 후 사용
3. 인증된 도메인만 `from_domain`으로 선택 가능
4. Phase 1에서는 `eventflow.kr`만 사용

### 6.3 Resend SDK 사용

**설치**:
```bash
npm install resend
```

**라이브러리 파일**: `lib/email/resend.ts`
```typescript
import { Resend } from 'resend'

const resend = new Resend(process.env.RESEND_API_KEY)

export async function sendEmailViaResend(params: {
  from: string // "모두의특강 <notify@eventflow.kr>"
  to: string | string[]
  subject: string
  html: string
  text?: string
  replyTo?: string
}): Promise<{ id: string } | null> {
  try {
    const { data, error } = await resend.emails.send({
      from: params.from,
      to: Array.isArray(params.to) ? params.to : [params.to],
      subject: params.subject,
      html: params.html,
      text: params.text,
      reply_to: params.replyTo,
    })
    
    if (error) {
      console.error('Resend 발송 실패:', error)
      return null
    }
    
    return { id: data?.id || '' }
  } catch (error) {
    console.error('Resend 발송 예외:', error)
    return null
  }
}
```

### 6.4 발송 형식

- **HTML + 텍스트 대체본**: 모두 지원
- **첨부파일**: Phase 2에서 지원 예정
- **태그/메타데이터**: Phase 2에서 지원 예정

---

## 7. 화면/UX

### 7.1 초안 생성 페이지

**경로**: `/client/[clientId]/emails/new`

**파일**: `app/(client)/client/[clientId]/emails/new/page.tsx`

**입력 필드**:
- 대상(scope): 웨비나 선택 드롭다운
- 유형(campaign_type): `reminder_d1`, `reminder_h1`, `confirmation`, `custom` 선택
- 발송 예정일(선택): 날짜/시간 선택

**액션**:
- "초안 생성" 버튼: 템플릿 기반 초안 생성 → `draft` 상태로 저장 → 상세 편집 페이지로 이동

### 7.2 상세/편집 페이지

**경로**: `/client/[clientId]/emails/[campaignId]`

**파일**: `app/(client)/client/[clientId]/emails/[campaignId]/page.tsx`

**편집 필드**:
- `subject`: 제목 입력
- `preheader`: 미리보기 텍스트 (선택)
- `body_md`: 본문 마크다운 편집기 (Novel.sh 또는 간단한 textarea)

**미리보기**:
- HTML preview 버튼: 모달에서 iframe으로 렌더링
- **XSS 방지**: iframe은 `sandbox` 속성 필수, HTML sanitization 적용

**액션 버튼** (상태에 따라 enable/disable):
- **저장**: `draft` 또는 `ready` 상태 유지하며 저장
- **승인**: `draft` → `ready` (owner/admin/operator만)
- **승인 취소**: `ready` → `draft` (owner/admin/operator만) - 재편집 가능
- **캠페인 취소**: `ready` → `canceled` (owner/admin/operator만) - 발송 중단, 재승인 불가
- **테스트 발송**: `ready` 상태에서만, 수신자 이메일 입력 모달 → 발송
- **실발송**: `ready` 상태에서만, 확인 모달 + Dry-run count 표시 → 발송

### 7.3 목록 페이지

**경로**: `/client/[clientId]/emails`

**파일**: `app/(client)/client/[clientId]/emails/page.tsx`

**표시 내용**:
- 캠페인 목록 (제목, 상태, 생성일, 발송일 등)
- 필터: 상태별, scope별
- 정렬: 생성일순, 발송일순

---

## 8. API 설계

### 8.1 POST /api/client/emails/generate

**권한**: `owner`, `admin`, `operator`

**Request**:
```typescript
{
  clientId: string
  scopeType: 'webinar' | 'registration_campaign' | 'survey_campaign'
  scopeId: string
  campaignType: 'reminder_d1' | 'reminder_h1' | 'confirmation' | 'custom'
  scheduledSendAt?: string // ISO datetime
}
```

**Response** (시스템 표준 포맷):
```typescript
{
  success: true,
  data: {
    campaign: {
      id: string
      status: 'draft'
      subject: string
      body_md: string
      // ... 기타 필드
    }
  }
}
```

**동작**:
1. 권한 확인: `requireClientMember(clientId, ['owner', 'admin', 'operator'])`
2. IDOR 방지: `scopeId`가 해당 `clientId`에 속하는지 검증
3. 템플릿 기반 초안 생성 (하드코딩 또는 `email_templates` 조회)
4. `variables_json` 채움 (scope에서 데이터 추출)
5. `status='draft'`로 저장
6. **서버(service role)로** `email_runs`에 `run_type='generate'` 로그 남김
7. `audit_logs`에 `action='EMAIL_CAMPAIGN_GENERATE'` 기록

**⚠️ 중요**: `email_runs`의 INSERT는 반드시 서버(Admin Supabase)에서만 수행.

### 8.2 PUT /api/client/emails/[id]

**권한**: `owner`, `admin`, `operator`

**Request**:
```typescript
{
  subject?: string
  preheader?: string
  body_md?: string
}
```

**Response** (시스템 표준 포맷):
```typescript
{
  success: true,
  data: {
    campaign: { /* 업데이트된 캠페인 */ }
  }
}
```

**동작**:
1. 권한 확인: `requireClientMember(clientId, ['owner', 'admin', 'operator'])`
2. IDOR 방지: `campaignId`가 해당 `clientId`에 속하는지 검증
3. `draft` 또는 `ready` 상태에서만 수정 가능
4. `updated_at` 자동 업데이트
5. `audit_logs`에 `action='EMAIL_CAMPAIGN_UPDATE'` 기록

### 8.3 POST /api/client/emails/[id]/approve

**권한**: `owner`, `admin`, `operator`

**Request**: 없음

**Response** (시스템 표준 포맷):
```typescript
{
  success: true,
  data: {
    campaign: { status: 'ready', approved_at: string, approved_by: string }
  }
}
```

**감사 로그**:
- `audit_logs`에 `action='EMAIL_CAMPAIGN_APPROVE'` 기록

**동작**:
- `draft` → `ready` 상태 전이
- `approved_at`, `approved_by` 설정
- 원자적 업데이트 (동시성 제어)

### 8.4 POST /api/client/emails/[id]/cancel-approval

**권한**: `owner`, `admin`, `operator`

**Request**: 없음

**Response** (시스템 표준 포맷):
```typescript
{
  success: true,
  data: {
    campaign: { status: 'draft', approved_at: null, approved_by: null }
  }
}
```

**감사 로그**:
- `audit_logs`에 `action='EMAIL_CAMPAIGN_CANCEL_APPROVAL'` 기록

**동작**:
- `ready` → `draft` 상태 전이
- `approved_at`, `approved_by` 초기화

### 8.5 POST /api/client/emails/[id]/cancel

**권한**: `owner`, `admin`, `operator`

**Request**: 없음

**Response** (시스템 표준 포맷):
```typescript
{
  success: true,
  data: {
    campaign: { status: 'canceled' }
  }
}
```

**동작**:
- `ready` → `canceled` 상태 전이
- 발송 중단, 재승인 불가 (복제하여 새 캠페인 생성 필요)

**감사 로그**:
- `audit_logs`에 `action='EMAIL_CAMPAIGN_CANCEL'` 기록

### 8.6 POST /api/client/emails/[id]/test-send

**권한**: `owner`, `admin`, `operator`

**Request**:
```typescript
{
  testEmails: string[] // 최대 10개
}
```

**Response** (시스템 표준 포맷):
```typescript
{
  success: true,
  data: {
    run: {
      id: string
      status: 'success' | 'failed'
      meta_json: { /* 발송 결과 */ }
    }
  }
}
```

**동작**:
1. 권한 확인: `requireClientMember(clientId, ['owner', 'admin', 'operator'])`
2. IDOR 방지: `campaignId`가 해당 `clientId`에 속하는지 검증
3. `ready` 상태에서만 가능
4. 상태 변화 없음 (캠페인 상태 유지)
5. **서버(service role)로** `email_runs`에 `run_type='test_send'` 로그 남김
6. `email_send_logs`에는 기록하지 않음 (테스트이므로)
7. `audit_logs`에 `action='EMAIL_CAMPAIGN_TEST_SEND'` 기록

**⚠️ 중요**: `email_runs`의 INSERT는 반드시 서버(Admin Supabase)에서만 수행.

### 8.7 POST /api/client/emails/[id]/send

**권한**: `owner`, `admin`, `operator`

**Request**: 없음

**Response** (시스템 표준 포맷):
```typescript
{
  success: true,
  data: {
    campaign: { status: 'sending' | 'sent' | 'failed' }
    run: { /* 실행 로그 */ }
  }
}
```

**동작**:
1. 원자적 lock: `ready` → `sending` (동시 실행 방지, 트랜잭션 사용)
2. `sending_started_at` 설정
3. 대상자 조회 (`audience_query_json` 기준)
4. 배치 발송 (환경변수로 설정 가능, 기본 50개씩, 0.5~1초 간격)
5. **서버(service role)로** `email_send_logs`에 개별 로그 기록 (dedupe_key로 중복 방지)
6. 완료 후 `sent` 또는 `failed` 상태로 전이
7. **서버(service role)로** `email_runs`에 `run_type='send'` 로그 남김

**⚠️ 중요**: `email_runs`와 `email_send_logs`의 INSERT는 반드시 서버(Admin Supabase)에서만 수행. 클라이언트는 조회만 가능.

**에러 처리**:
- 일부 실패해도 계속 진행
- 실패율이 50% 이상이면 `failed` 상태
- 그 외는 `sent` 상태

**sending 고착 복구**:
- `sending_started_at`이 1시간 이상 경과한 `sending` 상태 캠페인은 자동으로 `failed` 전이
- 또는 운영자가 `POST /api/client/emails/[id]/reset-stuck` 호출하여 강제 복구 가능

**감사 로그**:
- `audit_logs`에 `action='EMAIL_CAMPAIGN_SEND'` 기록

### 8.8 POST /api/client/emails/[id]/reset-stuck

**권한**: `owner`, `admin`, `operator`

**Request**: 없음

**Response** (시스템 표준 포맷):
```typescript
{
  success: true,
  data: {
    campaign: { status: 'failed' }
    message: 'Stuck sending 상태가 failed로 전이되었습니다'
  }
}
```

**동작**:
- `sending` 상태이고 `sending_started_at`이 1시간 이상 경과한 경우만 가능
- `failed` 상태로 전이
- `email_runs`에 실패 로그 기록

**감사 로그**:
- `audit_logs`에 `action='EMAIL_CAMPAIGN_RESET_STUCK'` 기록

### 8.9 GET /api/client/emails/[id]/audience-preview

**권한**: `owner`, `admin`, `operator`, `analyst`, `viewer`

**Response** (시스템 표준 포맷):
```typescript
{
  success: true,
  data: {
    totalCount: number
    samples: Array<{
      email: string
      displayName?: string
      // 기타 필드
    }>
  }
}
```

**동작**:
- Dry-run: 예상 발송 대상 수/샘플 10명 반환
- `audience_query_json` 기준으로 조회

---

## 9. 발송 프로세스

### 9.1 배치 발송 구현

**파일**: `lib/email/send-campaign.ts`

```typescript
// 환경변수로 설정 가능 (하드코딩 금지)
const BATCH_SIZE = parseInt(process.env.EMAIL_BATCH_SIZE || '50', 10)
const BATCH_DELAY_MS = parseInt(process.env.EMAIL_BATCH_DELAY_MS || '500', 10)
const MAX_CONCURRENT = parseInt(process.env.EMAIL_MAX_CONCURRENT || '10', 10) // 동시 요청 수 제한

export async function sendCampaignBatch(
  campaignId: string,
  recipients: Array<{ email: string; displayName?: string }>
): Promise<{ success: number; failed: number }> {
  
  let success = 0
  let failed = 0
  
  for (let i = 0; i < recipients.length; i += BATCH_SIZE) {
    const batch = recipients.slice(i, i + BATCH_SIZE)
    
    // 동시성 제한: MAX_CONCURRENT개씩만 동시 발송
    for (let j = 0; j < batch.length; j += MAX_CONCURRENT) {
      const concurrentBatch = batch.slice(j, j + MAX_CONCURRENT)
      const results = await Promise.allSettled(
        concurrentBatch.map(recipient => sendSingleEmail(campaignId, recipient))
      )
    
      results.forEach((result) => {
        if (result.status === 'fulfilled' && result.value) {
          success++
        } else {
          failed++
        }
      })
    }
    
    // 마지막 배치가 아니면 딜레이
    if (i + BATCH_SIZE < recipients.length) {
      await new Promise(resolve => setTimeout(resolve, BATCH_DELAY_MS))
    }
  }
  
  return { success, failed }
}
```

### 9.2 서버리스 환경 고려

- Vercel 함수 타임아웃: 최대 60초 (Pro 플랜)
- 대량 발송 시 Vercel Cron Job 또는 외부 Queue 사용 고려 (Phase 2)
- Phase 1에서는 배치 크기와 딜레이로 타임아웃 방지

### 9.3 실시간 화면 영향 금지

- 참가자 화면에서 발송/집계 금지 (이미 프로젝트 원칙과 일치)
- 발송은 백그라운드에서만 실행

---

## 10. 템플릿 변수 처리

### 10.1 변수 목록

**웨비나 scope**:
- `{{title}}`: 웨비나 제목
- `{{date}}`: 시작 날짜 (예: "2026.1.14일")
- `{{time}}`: 시작 시간 (예: "19시")
- `{{datetime}}`: 시작 일시 (예: "2026.1.14일 19시")
- `{{url}}`: 웨비나 입장 URL
- `{{thumbnail_url}}`: 썸네일 이미지 URL

**등록 캠페인 scope**:
- `{{title}}`: 캠페인 제목
- `{{url}}`: 등록 페이지 URL

### 10.2 변수 치환 로직

**파일**: `lib/email/template-processor.ts`

```typescript
export function processTemplate(
  template: string,
  variables: Record<string, string>
): string {
  let result = template
  for (const [key, value] of Object.entries(variables)) {
    // HTML escape: 변수 값에 스크립트가 포함될 수 있으므로 escape
    const escapedValue = escapeHtml(value)
    const regex = new RegExp(`\\{\\{${key}\\}\\}`, 'g')
    result = result.replace(regex, escapedValue)
  }
  return result
}

function escapeHtml(text: string): string {
  const map: Record<string, string> = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;'
  }
  return text.replace(/[&<>"']/g, m => map[m])
}
```

### 10.3 마크다운 → HTML 변환

**라이브러리**: `react-markdown` 또는 `marked`

**파일**: `lib/email/markdown-to-html.ts`

```typescript
import { marked } from 'marked'
import DOMPurify from 'isomorphic-dompurify' // 또는 'dompurify'

export function markdownToHtml(markdown: string): string {
  // 마크다운 → HTML 변환
  const htmlBody = marked(markdown)
  
  // XSS 방지: HTML sanitization
  const sanitizedHtml = DOMPurify.sanitize(htmlBody, {
    ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'u', 'a', 'ul', 'ol', 'li', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'img'],
    ALLOWED_ATTR: ['href', 'src', 'alt', 'title']
  })
  
  return wrapEmailTemplate(sanitizedHtml)
}

function wrapEmailTemplate(body: string): string {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <style>
        /* 이메일 스타일 */
      </style>
    </head>
    <body>
      ${body}
    </body>
    </html>
  `
}
```

---

## 11. 대상자 쿼리

### 11.1 audience_query_json 구조

**웨비나 등록자 전체**:
```json
{
  "type": "webinar_registrants",
  "webinar_id": "uuid",
  "exclude_entered": false
}
```

**웨비나 미입장자만**:
```json
{
  "type": "webinar_registrants",
  "webinar_id": "uuid",
  "exclude_entered": true
}
```

**등록 캠페인 등록자**:
```json
{
  "type": "registration_campaign_registrants",
  "campaign_id": "uuid"
}
```

### 11.2 대상자 조회 함수

**파일**: `lib/email/audience-query.ts`

```typescript
export async function getAudience(
  query: any,
  admin: SupabaseClient
): Promise<Array<{ email: string; displayName?: string }>> {
  if (query.type === 'webinar_registrants') {
    let q = admin
      .from('registrations')
      .select('email, display_name')
      .eq('webinar_id', query.webinar_id)
      .not('email', 'is', null)
    
    if (query.exclude_entered) {
      // 미입장자만: event_access_logs에 없는 경우
      // Phase 1에서는 exclude_entered=false만 허용 (기능 플래그)
      // Phase 2에서 구현: LEFT JOIN으로 event_access_logs 확인
      throw new Error('exclude_entered 기능은 Phase 2에서 구현 예정입니다')
    }
    
    const { data } = await q
    return data?.map(r => ({
      email: r.email!,
      displayName: r.display_name || undefined
    })) || []
  }
  
  // 기타 타입 처리...
  return []
}
```

---

## 12. 에러 처리 및 재시도

### 12.1 개별 발송 실패 처리

- `email_send_logs`에 `status='failed'`, `error_message` 기록
- 실패해도 다음 수신자 계속 발송

### 12.2 재시도 정책

**Phase 1**: 재시도 없음 (수동 재발송만)

**Phase 2**: 
- 일시적 실패 (rate limit 등): 3회 재시도, 지수 백오프
- 영구 실패 (invalid email 등): 재시도 없음

### 12.3 실패 리포트

- `email_runs.meta_json`에 실패 샘플 저장:
```json
{
  "total": 100,
  "success": 95,
  "failed": 5,
  "failed_samples": ["invalid@example.com", "bounce@example.com"]
}
```

---

## 13. 기존 시스템 통합

### 13.1 기존 sendWebinarRegistrationEmail()와의 관계

**현재**: `lib/email.ts`의 `sendWebinarRegistrationEmail()` 함수

**전환 전략**:
1. Phase 1: 새 캠페인 시스템과 병행 운영
2. Phase 2: 기존 함수를 내부적으로 새 시스템 사용하도록 리팩토링
3. Phase 3: 기존 함수 제거, 모든 발송을 캠페인 시스템으로 통합

**임시 호환성**:
- 기존 웨비나 등록 확인 이메일은 계속 작동
- 새 리마인드 메일은 캠페인 시스템 사용

### 13.2 웨비나 설정 연동

- `webinars.email_template_text`: 기존 등록 확인 이메일용 (유지)
- 새 캠페인 시스템: 별도 관리

---

## 14. WERT 리마인드 적용

### 14.1 캠페인 생성

**초기 데이터**:
```typescript
{
  client_id: 'WERT_CLIENT_ID',
  scope_type: 'webinar',
  scope_id: 'WEBINAR_ID',
  campaign_type: 'reminder_d1',
  status: 'draft',
  subject: '...', // 템플릿에서 생성
  body_md: '...', // 템플릿에서 생성
  // 발송 정책은 client_email_policies에서 자동 적용
}
```

### 14.2 운영 플로우

1. **초안 생성** (draft)
   - 템플릿 기반으로 자동 생성
   - 고객이 문구 수정 가능

2. **고객 문구 수정**
   - 대시보드에서 `subject`, `body_md` 수정

3. **승인** (ready)
   - 운영자가 승인

4. **테스트 발송** (오늘)
   - 테스트 이메일로 발송 확인

5. **실발송** (내일)
   - 실제 대상자에게 발송

---

## 15. 리스크/가드레일

### 15.1 도메인 인증

- 도메인 인증 안 된 `from_domain`은 선택 불가 (화이트라벨)
- Resend 대시보드에서 인증 확인

### 15.2 From localpart allowlist

- 허용된 localpart만 사용 가능
- 화이트라벨 모드에서도 동일 적용

### 15.3 중복 발송 방지

- `dedupe_key` 유니크 인덱스로 강제
- 동일 `dedupe_key`로 재발송 시도 시 에러
- **재발송 정책**: 
  - 같은 캠페인에서 재시도는 불가 (dedupe_key로 차단)
  - 재발송은 **새 캠페인을 복제하여 생성** 후 발송 (권장)
  - 부분 재발송(실패자만)은 Phase 2에서 별도 API 제공 예정

### 15.4 도메인 하드코딩 금지

- "현재 접속 도메인(host)"로 링크/From 결정 금지
- 모든 도메인은 정책 테이블 또는 환경 변수에서 가져오기

### 15.5 상태 전이 제어

- `send`는 반드시 `ready`에서만
- 원자적 lock 실패 시 중복 실행 방지 (트랜잭션 사용)

### 15.6 sending 고착 복구

- `sending_started_at`이 1시간 이상 경과한 `sending` 상태 캠페인은 자동으로 `failed` 전이
- 또는 운영자가 `POST /api/client/emails/[id]/reset-stuck` 호출하여 강제 복구 가능
- 배치 발송 중 서버리스 타임아웃/예외 발생 시 고착 방지

### 15.7 org_fields 트리거 안정성

- `fill_email_campaign_org_fields()` 트리거에서 지원하지 않는 `scope_type`은 **명시적으로 예외 발생**
- `registration_campaign`은 Phase 1에서 미지원이므로 예외 처리 (조용히 null 통과 금지)
- **`strict` 키워드 사용**: `select ... into strict`로 `no_data_found` 시 자동 예외 발생
- 존재하지 않는 `scope_id`로 캠페인 생성 방지 (데이터 정합성 보장)
- `client_id`는 NOT NULL 제약이 있으므로 API 레벨에서 검증, 트리거는 `agency_id`만 보조 채움

### 15.10 XSS 방지

- 마크다운→HTML 변환 시 DOMPurify 등으로 sanitization 필수
- 템플릿 변수 값은 HTML escape 필수 (`<script>` 등 차단)
- 프리뷰 iframe은 `sandbox` 속성으로 스크립트 실행 차단
- 이메일 클라이언트는 자체적으로 막지만, **우리 서비스 UI에서 실행되는 스크립트**가 문제이므로 반드시 차단

### 15.8 IDOR 방지

- 모든 API에서 `campaignId` 또는 `scopeId`로 접근 시 반드시 `client_id` 소유 검증
- RLS만으로는 부족 (서버에서 Admin Supabase 사용 시 우회 가능)
- 앱 레벨에서 이중 검증 필수

### 15.9 로그 테이블 INSERT 권한 제한

- `email_runs`와 `email_send_logs`는 **서버(service role)에서만 INSERT 가능**
- 클라이언트는 SELECT만 허용 (RLS 정책으로 INSERT/UPDATE 차단)
- 대시보드 사용자 조작으로 로그 오염 방지

### 15.11 RLS 정책 행위별 분리

- **`for all` 사용 금지**: SELECT, INSERT, UPDATE, DELETE를 각각 별도 정책으로 분리
- 디버깅 난이도 감소 및 운영 중 정책 추가 시 예상치 못한 접근 결과 방지
- `email_campaigns`와 `client_email_policies` 모두 행위별 정책 적용

---

## 16. DoD (완료 기준)

### 16.1 기능 요구사항

- ✅ 고객이 대시보드에서 `subject`/`body_md`를 수정할 수 있다
- ✅ 테스트 발송이 가능하다 (`ready` 상태)
- ✅ 승인/승인취소가 가능하다
- ✅ 캠페인 취소가 가능하다 (`ready` → `canceled`)
- ✅ 실발송 시 중복 발송이 발생하지 않는다 (`dedupe_key`)
- ✅ 발송 결과가 `run`/`log`로 추적된다 (성공/실패/카운트)
- ✅ WERT 리마인드가 이 플로우로 오늘 테스트 가능

### 16.2 보안/운영 요구사항

- ✅ **RLS/권한정책이 적용되어 다른 클라이언트 데이터 접근이 불가능하다**
- ✅ **발송/승인/취소/정책수정이 audit_logs에 남는다**
- ✅ **sending 고착 복구가 가능하다** (자동 또는 수동)
- ✅ **프리뷰 XSS가 차단되어 있다** (iframe sandbox + HTML sanitization)
- ✅ **API 응답이 시스템 표준 포맷(`{ success: true, data: ... }`)을 따른다**
- ✅ **IDOR 방지**: `campaignId`로 접근 시 반드시 `client_id` 소유 검증
- ✅ **템플릿 변수 값이 HTML escape되어 XSS가 방지된다**
- ✅ **로그 테이블(email_runs, email_send_logs) INSERT는 서버에서만 가능하다**
- ✅ **org_fields 트리거가 지원하지 않는 scope_type에서 예외를 발생시킨다**
- ✅ **org_fields 트리거가 존재하지 않는 scope_id에서 예외를 발생시킨다** (`strict` 사용)
- ✅ **RLS 정책이 행위별로 분리되어 있다** (`for all` 사용 금지)
- ✅ **재발송 정책이 명확하다** (새 캠페인 복제 방식)

---

## 17. 구현 우선순위

### Phase 1 (즉시 구현)

1. **데이터베이스 스키마**
   - `email_campaigns` 테이블 생성
   - `email_runs` 테이블 생성
   - `email_send_logs` 테이블 생성
   - `client_email_policies` 테이블 생성 (WERT 기본값 삽입)
   - **RLS 활성화 및 정책 적용** (필수)
   - **fill_org_fields 트리거 적용** (필수)

2. **Resend 통합**
   - `lib/email/resend.ts` 생성
   - 환경 변수 설정 확인 (실키 제거 확인)

3. **최소 API** (모든 API에 IDOR 방지 + audit_logs 적용)
   - `POST /api/client/emails/generate` (하드코딩 템플릿)
   - `PUT /api/client/emails/[id]`
   - `POST /api/client/emails/[id]/approve`
   - `POST /api/client/emails/[id]/cancel-approval`
   - `POST /api/client/emails/[id]/cancel` (캠페인 취소)
   - `POST /api/client/emails/[id]/test-send`
   - `POST /api/client/emails/[id]/send`
   - `POST /api/client/emails/[id]/reset-stuck` (고착 복구)
   - `GET /api/client/emails/[id]/audience-preview`
   - **모든 API 응답을 `{ success: true, data: ... }` 형식으로 통일**

4. **발송 로직**
   - `lib/email/send-campaign.ts` (배치 발송, 환경변수로 설정 가능)
   - `lib/email/audience-query.ts` (대상자 조회, exclude_entered=false만)
   - `lib/email/template-processor.ts` (변수 치환, HTML escape)

5. **보안**
   - 마크다운→HTML 변환 시 sanitization 적용
   - 템플릿 변수 값 HTML escape
   - 프리뷰 iframe sandbox 적용

6. **WERT 테스트**
   - WERT 리마인드 캠페인 생성
   - 테스트 발송 확인

### Phase 2 (추가 기능)

1. **대시보드 UI**
   - 초안 생성 페이지
   - 상세/편집 페이지
   - 목록 페이지

2. **템플릿 시스템**
   - `email_templates` 테이블 활용
   - 템플릿 관리 UI

3. **클라이언트별 정책 설정**
   - 정책 설정 UI
   - 화이트라벨 도메인 관리

### Phase 3 (고급 기능)

1. **AI 기반 초안 생성**
   - Gemini API 연동
   - 자동 템플릿 생성

2. **자동화/스케줄링**
   - `scheduled_send_at` 활용
   - Vercel Cron Job 연동

3. **고급 분석**
   - 발송 통계 대시보드
   - 열람률/클릭률 추적

---

## 부록 A: SQL 마이그레이션 파일

**파일**: `supabase/migrations/083_create_email_campaigns.sql`

```sql
begin;

-- email_templates (Phase 2용, 지금은 생략 가능)
-- create table public.email_templates (...);

-- email_campaigns
create table public.email_campaigns (
  id uuid primary key default gen_random_uuid(),
  agency_id uuid references public.agencies(id) on delete cascade,
  client_id uuid not null references public.clients(id) on delete cascade,
  scope_type text not null check (scope_type in ('webinar', 'registration_campaign', 'survey_campaign')),
  scope_id uuid not null,
  campaign_type text not null check (campaign_type in ('reminder_d1', 'reminder_h1', 'confirmation', 'custom')),
  status text not null default 'draft' check (status in ('draft', 'ready', 'sending', 'sent', 'failed', 'canceled')),
  subject text not null,
  preheader text,
  body_md text not null,
  variables_json jsonb default '{}',
  audience_query_json jsonb default '{}',
  scheduled_send_at timestamptz,
  approved_at timestamptz,
  approved_by uuid references public.profiles(id),
  sending_started_at timestamptz,
  sent_at timestamptz,
  from_domain text,
  from_localpart text,
  from_name text,
  reply_to text,
  created_by uuid not null references public.profiles(id),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index idx_email_campaigns_client_id on public.email_campaigns(client_id);
create index idx_email_campaigns_scope on public.email_campaigns(scope_type, scope_id);
create index idx_email_campaigns_status on public.email_campaigns(status);
create index idx_email_campaigns_created_at on public.email_campaigns(created_at desc);

-- email_runs
create table public.email_runs (
  id uuid primary key default gen_random_uuid(),
  email_campaign_id uuid not null references public.email_campaigns(id) on delete cascade,
  run_type text not null check (run_type in ('generate', 'test_send', 'send')),
  status text not null check (status in ('success', 'failed')),
  provider text not null default 'resend' check (provider in ('resend', 'smtp')),
  meta_json jsonb default '{}',
  error text,
  created_by uuid references public.profiles(id),
  created_at timestamptz not null default now()
);

create index idx_email_runs_campaign_id on public.email_runs(email_campaign_id);
create index idx_email_runs_created_at on public.email_runs(created_at desc);

-- email_send_logs
create table public.email_send_logs (
  id uuid primary key default gen_random_uuid(),
  email_campaign_id uuid not null references public.email_campaigns(id) on delete cascade,
  recipient_email text not null,
  status text not null check (status in ('queued', 'sent', 'failed')),
  provider_message_id text,
  error_message text,
  dedupe_key text not null,
  created_at timestamptz not null default now()
);

create unique index uniq_email_send_logs_dedupe_key on public.email_send_logs(dedupe_key);
create index idx_email_send_logs_campaign_id on public.email_send_logs(email_campaign_id);
create index idx_email_send_logs_status on public.email_send_logs(status);
create index idx_email_send_logs_recipient_email on public.email_send_logs(recipient_email);

-- client_email_policies
create table public.client_email_policies (
  id uuid primary key default gen_random_uuid(),
  client_id uuid not null unique references public.clients(id) on delete cascade,
  send_mode text not null default 'platform' check (send_mode in ('platform', 'white_label', 'customer_smtp')),
  from_domain text not null,
  from_localpart_default text not null default 'notify',
  from_name_default text not null,
  reply_to_default text not null,
  link_base_url_default text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index idx_client_email_policies_client_id on public.client_email_policies(client_id);

-- updated_at 트리거
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

create trigger update_email_campaigns_updated_at
  before update on public.email_campaigns
  for each row
  execute function update_updated_at_column();

create trigger update_client_email_policies_updated_at
  before update on public.client_email_policies
  for each row
  execute function update_updated_at_column();

-- fill_org_fields 트리거: agency_id 자동 채움
-- email_campaigns: scope_id로부터 agency_id, client_id 조회
create or replace function public.fill_email_campaign_org_fields() returns trigger as $$
declare
  agency_id_val uuid;
  client_id_val uuid;
begin
  -- scope_type에 따라 조회
  if new.scope_type = 'webinar' then
    select agency_id, client_id into strict agency_id_val, client_id_val
    from public.webinars
    where id = new.scope_id;
  elsif new.scope_type = 'registration_campaign' then
    -- ⚠️ Phase 1에서는 registration_campaign 미지원
    -- 조용히 null로 통과하면 RLS/리포트가 꼬이므로 명시적으로 예외 발생
    raise exception 'registration_campaign scope_type은 Phase 1에서 지원되지 않습니다. Phase 2에서 구현 예정입니다.'
      using hint = '현재는 webinar 또는 survey_campaign만 사용 가능합니다';
  elsif new.scope_type = 'survey_campaign' then
    select agency_id, client_id into strict agency_id_val, client_id_val
    from public.event_survey_campaigns
    where id = new.scope_id;
  else
    -- 알 수 없는 scope_type
    raise exception '지원되지 않는 scope_type: %', new.scope_type;
  end if;
  
  -- ⚠️ 중요: scope_id가 존재하지 않으면 strict로 인해 자동 예외 발생
  -- (존재하지 않는 scope_id로 캠페인 생성 방지 - 데이터 정합성 보장)
  
  -- agency_id 보조 채움 (null이면 자동 채움)
  if new.agency_id is null then
    new.agency_id := agency_id_val;
  end if;
  
  -- ⚠️ 중요: client_id는 NOT NULL 제약이 있으므로 요청에서 반드시 제공되어야 함
  -- 트리거는 agency_id만 보조 채움 (시스템 표준 fill_org_fields 패턴 준수)
  -- client_id는 API 레벨에서 검증 후 제공
  
  return new;
end;
$$ language plpgsql;

create trigger tg_fill_email_campaign_org_fields
  before insert on public.email_campaigns
  for each row execute function public.fill_email_campaign_org_fields();

-- RLS 활성화
alter table public.email_campaigns enable row level security;
alter table public.email_runs enable row level security;
alter table public.email_send_logs enable row level security;
alter table public.client_email_policies enable row level security;

-- RLS 정책: email_campaigns
-- ⚠️ 중요: 행위별로 정책 분리 (for all 사용 금지 - 디버깅 난이도 증가 방지)

-- SELECT: 클라이언트 멤버만 조회 가능
create policy "read_campaigns_in_scope" on public.email_campaigns
  for select
  using (
    (select is_super_admin from public.me) is true
    or exists (
      select 1 from public.my_clients c 
      where c.client_id = email_campaigns.client_id
    )
  );

-- INSERT: owner/admin/operator만
create policy "insert_campaigns_by_operator" on public.email_campaigns
  for insert
  with check (
    (select is_super_admin from public.me) is true
    or exists (
      select 1 from public.client_members cm
      where cm.client_id = email_campaigns.client_id
        and cm.user_id = auth.uid()
        and cm.role in ('owner', 'admin', 'operator')
    )
  );

-- UPDATE: owner/admin/operator만
create policy "update_campaigns_by_operator" on public.email_campaigns
  for update
  using (
    (select is_super_admin from public.me) is true
    or exists (
      select 1 from public.client_members cm
      where cm.client_id = email_campaigns.client_id
        and cm.user_id = auth.uid()
        and cm.role in ('owner', 'admin', 'operator')
    )
  )
  with check (
    (select is_super_admin from public.me) is true
    or exists (
      select 1 from public.client_members cm
      where cm.client_id = email_campaigns.client_id
        and cm.user_id = auth.uid()
        and cm.role in ('owner', 'admin', 'operator')
    )
  );

-- DELETE: owner/admin/operator만
create policy "delete_campaigns_by_operator" on public.email_campaigns
  for delete
  using (
    (select is_super_admin from public.me) is true
    or exists (
      select 1 from public.client_members cm
      where cm.client_id = email_campaigns.client_id
        and cm.user_id = auth.uid()
        and cm.role in ('owner', 'admin', 'operator')
    )
  );

-- RLS 정책: email_runs (읽기 전용, 서버에서만 생성)
-- ⚠️ 중요: INSERT/UPDATE는 서버(service role)에서만 가능, 클라이언트는 SELECT만
create policy "read_runs_in_scope" on public.email_runs
  for select
  using (
    exists (
      select 1 from public.email_campaigns ec
      where ec.id = email_runs.email_campaign_id
        and (
          (select is_super_admin from public.me) is true
          or exists (
            select 1 from public.my_clients c 
            where c.client_id = ec.client_id
          )
        )
    )
  );

-- INSERT/UPDATE 정책은 명시적으로 생성하지 않음 (서버 전용)
-- 클라이언트가 INSERT 시도하면 RLS에 의해 자동 차단됨

-- RLS 정책: email_send_logs (읽기 전용, 서버에서만 생성)
-- ⚠️ 중요: INSERT/UPDATE는 서버(service role)에서만 가능, 클라이언트는 SELECT만
-- PII 테이블이므로 엄격한 접근 제어
create policy "read_logs_in_scope" on public.email_send_logs
  for select
  using (
    exists (
      select 1 from public.email_campaigns ec
      where ec.id = email_send_logs.email_campaign_id
        and (
          (select is_super_admin from public.me) is true
          or exists (
            select 1 from public.my_clients c 
            where c.client_id = ec.client_id
          )
        )
    )
  );

-- INSERT/UPDATE 정책은 명시적으로 생성하지 않음 (서버 전용)
-- 클라이언트가 INSERT 시도하면 RLS에 의해 자동 차단됨

-- RLS 정책: client_email_policies
-- ⚠️ 중요: 행위별로 정책 분리 (for all 사용 금지)

-- SELECT: 클라이언트 멤버만 조회 가능
create policy "read_policies_in_scope" on public.client_email_policies
  for select
  using (
    (select is_super_admin from public.me) is true
    or exists (
      select 1 from public.my_clients c 
      where c.client_id = client_email_policies.client_id
    )
  );

-- INSERT: owner/admin만
create policy "insert_policies_by_admin" on public.client_email_policies
  for insert
  with check (
    (select is_super_admin from public.me) is true
    or exists (
      select 1 from public.client_members cm
      where cm.client_id = client_email_policies.client_id
        and cm.user_id = auth.uid()
        and cm.role in ('owner', 'admin')
    )
  );

-- UPDATE: owner/admin만
create policy "update_policies_by_admin" on public.client_email_policies
  for update
  using (
    (select is_super_admin from public.me) is true
    or exists (
      select 1 from public.client_members cm
      where cm.client_id = client_email_policies.client_id
        and cm.user_id = auth.uid()
        and cm.role in ('owner', 'admin')
    )
  )
  with check (
    (select is_super_admin from public.me) is true
    or exists (
      select 1 from public.client_members cm
      where cm.client_id = client_email_policies.client_id
        and cm.user_id = auth.uid()
        and cm.role in ('owner', 'admin')
    )
  );

-- DELETE: owner/admin만
create policy "delete_policies_by_admin" on public.client_email_policies
  for delete
  using (
    (select is_super_admin from public.me) is true
    or exists (
      select 1 from public.client_members cm
      where cm.client_id = client_email_policies.client_id
        and cm.user_id = auth.uid()
        and cm.role in ('owner', 'admin')
    )
  );

commit;
```

---

## 부록 B: 파일 구조

```
lib/
  email/
    resend.ts              # Resend SDK 래퍼
    send-campaign.ts       # 배치 발송 로직
    audience-query.ts      # 대상자 조회
    template-processor.ts # 템플릿 변수 치환
    markdown-to-html.ts   # 마크다운 → HTML 변환

app/
  (client)/
    client/
      [clientId]/
        emails/
          page.tsx                    # 목록 페이지
          new/
            page.tsx                  # 초안 생성 페이지
          [campaignId]/
            page.tsx                  # 상세/편집 페이지

api/
  client/
    emails/
      generate/
        route.ts                      # POST /api/client/emails/generate
      [id]/
        route.ts                      # PUT /api/client/emails/[id]
        approve/
          route.ts                    # POST /api/client/emails/[id]/approve
        cancel-approval/
          route.ts                    # POST /api/client/emails/[id]/cancel-approval
        cancel/
          route.ts                    # POST /api/client/emails/[id]/cancel (캠페인 취소)
        test-send/
          route.ts                    # POST /api/client/emails/[id]/test-send
        send/
          route.ts                    # POST /api/client/emails/[id]/send
        reset-stuck/
          route.ts                    # POST /api/client/emails/[id]/reset-stuck (고착 복구)
        audience-preview/
          route.ts                    # GET /api/client/emails/[id]/audience-preview

supabase/
  migrations/
    083_create_email_campaigns.sql   # 데이터베이스 스키마
```

---

---

## 부록 C: 체크리스트 (구현 시 확인)

### DB/보안 (필수)
- [ ] `RESEND_API_KEY` 실키가 문서/레포에 남지 않도록 제거 + 키 로테이트(가능성 있으면 즉시)
- [ ] 이메일 관련 테이블에 **RLS 활성화/정책** 적용 (시스템 패턴 준수)
- [ ] `fill_org_fields()` 트리거 적용 여부 확인 (시스템 패턴 준수)
- [ ] **로그 테이블(email_runs, email_send_logs) INSERT는 서버(service role)에서만 가능하도록 RLS 정책 설정**
- [ ] **org_fields 트리거에서 지원하지 않는 scope_type은 예외 발생 (null 통과 금지)**
- [ ] **org_fields 트리거에서 `select ... into strict` 사용하여 존재하지 않는 scope_id 차단**
- [ ] **RLS 정책이 행위별로 분리되어 있는지 확인** (`for all` 사용 금지)
- [ ] 승인/발송/취소/정책수정 같은 이벤트는 `audit_logs` 기록

### API 일관성/권한 (필수)
- [ ] 이메일 API 응답을 `{ success: true, data: ... }`로 통일
- [ ] 모든 라우트는 `requireClientMember()`로 역할 제한(명세와 일치)
- [ ] `campaignId/scopeId`로 접근할 때 **반드시 client 소유 검증**(IDOR 방지)

### 상태 전이/운영 안전 (필수)
- [ ] "승인 취소(ready→draft)"와 "캠페인 취소(ready→canceled)"를 명세/라우트/UX에서 일치시키기
- [ ] `sending` 고착 복구 정책/액션 제공 (sending_started_at 활용)

### XSS/프리뷰 안전 (필수)
- [ ] markdown→html 렌더링 결과 sanitize 또는 iframe sandbox 적용
- [ ] 템플릿 변수 값 HTML escape

### 중복방지 정책 "의도 확인" (중요 결정)
- [ ] dedupe_key가 "캠페인 단위"로 설정되어 재발송 가능한지 확인
- [ ] 재발송 정책이 명확히 문서화되어 있는지 확인 (새 캠페인 복제 방식)

---

**명세서 버전**: v1.3  
**최종 업데이트**: 2026-02-03 (설계 감독관 최종 리뷰 반영 - RLS 정책/트리거 안정성 강화)

---

## 최종 결정 사항 요약 (v1.3)

### 1. 로그 테이블 INSERT 권한
- ✅ `email_runs`와 `email_send_logs`는 **서버(service role)에서만 INSERT 가능**
- ✅ 클라이언트는 SELECT만 허용 (RLS 정책으로 INSERT/UPDATE 차단)

### 2. org_fields 트리거 안정성
- ✅ `registration_campaign` scope_type은 Phase 1에서 미지원
- ✅ 지원하지 않는 scope_type은 **명시적으로 예외 발생** (null 통과 금지)
- ✅ **`select ... into strict` 사용**: 존재하지 않는 `scope_id`에서 자동 예외 발생
- ✅ `client_id`는 NOT NULL이므로 API 레벨 검증, 트리거는 `agency_id`만 보조 채움

### 3. 재발송 정책
- ✅ 같은 캠페인에서 재시도는 불가 (dedupe_key로 차단)
- ✅ 재발송은 **새 캠페인을 복제하여 생성** 후 발송 (권장)
- ⏳ 부분 재발송(실패자만)은 Phase 2에서 별도 API 제공 예정

### 4. RLS 정책 행위별 분리 (v1.3 추가)
- ✅ `for all` 사용 금지: SELECT, INSERT, UPDATE, DELETE를 각각 별도 정책으로 분리
- ✅ 디버깅 난이도 감소 및 운영 중 정책 추가 시 예상치 못한 접근 결과 방지
