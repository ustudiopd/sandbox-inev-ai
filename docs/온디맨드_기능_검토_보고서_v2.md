# 온디맨드(On-Demand) 기능 구현 검토 보고서 v2

**작성일**: 2026-02-03  
**검토 대상**: `온디맨드.md` 최종 작업 지시서  
**이전 검토**: `온디맨드_기능_검토_보고서.md` (2026-02-03)

---

## 📋 변경사항 요약

최종 작업 지시서는 이전 검토 보고서의 제안사항을 반영하여 **더 보수적이고 안전한 접근 방식**으로 개선되었습니다.

### 주요 개선사항

1. ✅ **type 컬럼 설계**: nullable 허용 (더 안전)
2. ✅ **트래킹 중복 방지**: NULL UNIQUE 함정 해결 방안 명시
3. ✅ **컴포넌트 위치**: YouTubePlayer 중립 위치 이동 제안
4. ✅ **구체적인 DoD**: Phase별 체크리스트 추가
5. ✅ **공통 리스크 방지**: 릴리즈 전 필수 체크리스트 추가

---

## ✅ 명세서 검토 결과

### 1. **절대 원칙 (Non-Negotiable)** ⭐⭐⭐⭐⭐

명세서의 5가지 절대 원칙은 **매우 명확하고 실용적**입니다:

1. ✅ **Add-only**: 기존 컬럼 변경 금지
2. ✅ **라우트 완전 분리**: `/ondemand/*` vs `/webinar/*`
3. ✅ **참가자 화면 무거운 작업 금지**: 집계/AI/Realtime 금지
4. ✅ **하드코딩 금지**: N개 세션 지원 구조
5. ✅ **멀티테넌시/권한 우선**: agency/client 스코프 확정

**평가**: 완벽합니다. 기존 시스템 보호와 확장성의 균형이 잘 맞습니다.

---

### 2. **DB 스키마 설계 개선** ⭐⭐⭐⭐⭐

#### type 컬럼 설계 (보수적 접근)

**명세서 제안**:
```sql
-- nullable 허용, 기존 row 영향 0
ALTER TABLE webinars 
ADD COLUMN type TEXT CHECK (type IN ('live', 'ondemand'));
```

**이전 검토 제안**: `NOT NULL DEFAULT 'live'`

**최종 평가**: ✅ **명세서 방식이 더 안전합니다**
- 기존 쿼리가 `type` 컬럼을 모르더라도 동작
- `type IS NULL` = 라이브로 간주 (기존 동작 유지)
- 마이그레이션 리스크 최소화

#### settings JSONB 컬럼

**현재 상태 확인**:
- ❌ `webinars` 테이블에 `settings` 또는 `config` JSONB 컬럼 없음
- ✅ 개별 컬럼들 존재 (`meta_title`, `email_template_text` 등)

**필요한 작업**:
```sql
-- settings JSONB 컬럼 추가
ALTER TABLE webinars 
ADD COLUMN IF NOT EXISTS settings JSONB DEFAULT '{}'::jsonb;

-- 주석 추가
COMMENT ON COLUMN webinars.settings IS '온디맨드 세션 설정 등 확장 가능한 설정 저장소';
```

**세션 저장 구조**:
```json
{
  "ondemand": {
    "sessions": [
      {
        "session_key": "s1_intro",
        "title": "Session 1. Overview",
        "provider": "youtube",
        "asset_id": "xxxx",
        "order": 1,
        "thumbnail": "url",
        "speaker": "optional",
        "description": "optional"
      }
    ],
    "qna_enabled": true,
    "notify_emails": ["support@eventflow.kr"]
  }
}
```

**평가**: ✅ 구조가 명확하고 확장 가능합니다.

---

### 3. **트래킹 시스템 중복 방지 개선** ⭐⭐⭐⭐⭐

#### 문제점 (이전 검토)

이전 검토에서 제안한 UNIQUE 제약:
```sql
UNIQUE(webinar_id, session_key, participant_id, visitor_id, event_type)
```

**문제**: `participant_id`와 `visitor_id`가 모두 NULL일 수 있어 중복 방지 실패

#### 해결 방안 (명세서)

**권장 방식**: `actor_key` 사용
```sql
CREATE TABLE ondemand_session_events (
  id BIGSERIAL PRIMARY KEY,
  webinar_id UUID NOT NULL REFERENCES webinars(id) ON DELETE CASCADE,
  session_key TEXT NOT NULL,
  participant_id UUID REFERENCES profiles(id),
  visitor_id TEXT,
  actor_key TEXT NOT NULL, -- 서버에서 COALESCE(participant_id, visitor_id)로 확정
  event_type TEXT NOT NULL CHECK (event_type IN (
    'play_start', 'progress_25', 'progress_50', 
    'progress_75', 'progress_90', 'complete'
  )),
  event_data JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- 중복 방지: actor_key 기반
  UNIQUE(webinar_id, session_key, actor_key, event_type)
);

-- 인덱스
CREATE INDEX idx_ondemand_events_webinar_session 
ON ondemand_session_events(webinar_id, session_key);
CREATE INDEX idx_ondemand_events_actor 
ON ondemand_session_events(actor_key);
```

**서버 측 로직**:
```typescript
// API에서 actor_key 확정
const actorKey = participantId || visitorId || `anonymous_${sessionId}`
// actorKey는 절대 NULL이 아님 보장
```

**대안**: Partial Unique Index
```sql
-- participant 전용
CREATE UNIQUE INDEX idx_ondemand_events_participant_unique
ON ondemand_session_events(webinar_id, session_key, participant_id, event_type)
WHERE participant_id IS NOT NULL;

-- visitor 전용
CREATE UNIQUE INDEX idx_ondemand_events_visitor_unique
ON ondemand_session_events(webinar_id, session_key, visitor_id, event_type)
WHERE visitor_id IS NOT NULL;
```

**평가**: ✅ **actor_key 방식이 더 단순하고 명확합니다**
- 서버에서 한 번 확정하면 끝
- Partial Unique는 복잡하지만 더 엄격함
- 프로젝트 특성에 따라 선택 가능

---

### 4. **컴포넌트 위치 제안** ⭐⭐⭐⭐

#### 명세서 제안

**문제**: `components/webinar/YouTubePlayer.tsx`는 라이브 의존성이 섞일 수 있음

**해결**: 중립 위치로 이동/복제
```
components/
  media/              # 새 폴더 (중립)
    YouTubePlayer.tsx # 온디맨드용
  webinar/           # 기존 (라이브용)
    YouTubePlayer.tsx # 기존 유지 (호환성)
```

**평가**: ✅ **좋은 제안입니다**
- 라이브와 온디맨드 분리 명확화
- 기존 코드 호환성 유지
- 추후 확장 시 혼선 방지

**구현 옵션**:
1. **복제 후 확장**: `media/YouTubePlayer.tsx`에 진행률 추적 추가
2. **공통 베이스**: `media/YouTubePlayerBase.tsx` + 각각 확장
3. **조건부 기능**: props로 `onProgress` 등 추가 (단순)

**권장**: 옵션 3 (조건부 기능) - 코드 중복 최소화

---

### 5. **QnA 시스템 확장** ⭐⭐⭐⭐⭐

#### 명세서 제안

**기존 status 체계 유지**:
- `published`, `answered`, `hidden`, `pinned` (DB 변경 금지)
- 온디맨드 UI에서만 매핑:
  - `published` → `new` (표시용)
  - `hidden` → `closed` (표시용)
  - `answered` → `answered` (공통)

**평가**: ✅ **완벽한 접근입니다**
- 기존 라이브 QnA 영향 0
- UI 레벨 매핑으로 유연성 확보
- DB 스키마 변경 없이 구현 가능

**필요한 작업**:
```sql
-- session_key 추가
ALTER TABLE questions 
ADD COLUMN session_key TEXT;

-- 인덱스 추가
CREATE INDEX idx_questions_session_key 
ON questions(webinar_id, session_key) 
WHERE session_key IS NOT NULL;
```

---

### 6. **이벤트 폭주 방지** ⭐⭐⭐⭐⭐

#### 명세서 제안

1. **progress는 25% 단위로 1회만 전송**
2. **폴링 간격**: 1~2초 수준 권장
3. **탭 비활성 시 중지/완화**
4. **참가자 화면 집계 금지**: 원장 적재만

**평가**: ✅ **매우 실용적입니다**
- YouTube API 제한 고려
- 성능 최적화
- 사용자 경험 고려

**구현 예시**:
```typescript
// 진행률 추적 (디바운싱)
let lastProgress = 0
const progressThresholds = [25, 50, 75, 90]
const trackedProgress = new Set<number>()

const checkProgress = () => {
  const currentProgress = Math.floor((currentTime / duration) * 100)
  
  // 25% 단위로만 체크
  const threshold = progressThresholds.find(t => 
    currentProgress >= t && !trackedProgress.has(t)
  )
  
  if (threshold) {
    trackedProgress.add(threshold)
    sendEvent(`progress_${threshold}`)
  }
}

// 1~2초 간격 폴링
const interval = setInterval(checkProgress, 1500)

// 탭 비활성 시 중지
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    clearInterval(interval)
  } else {
    // 재개
  }
})
```

---

## 🔍 Phase별 상세 검토

### Phase 1: 라우트 분리 + 프론트 스켈레톤 ⭐⭐⭐⭐⭐

**DoD 체크리스트**:
- [ ] `/ondemand/*` 3개 라우트 렌더링 OK
- [ ] 세션 리스트는 배열 렌더(N개 가능)로 구현(4개 하드코딩 금지)
- [ ] 온디맨드 트리에서 live/realtime 관련 import 0
- [ ] 기존 `/webinar/*` 및 라이브 2건 회귀 테스트 통과(동작 동일)

**평가**: ✅ **명확하고 실현 가능합니다**

**구현 가이드**:
```
app/
  (ondemand)/              # 라우트 그룹
    layout.tsx             # 온디맨드 전용 레이아웃
    ondemand/
      [id]/
        page.tsx           # 랜딩 페이지
        watch/
          page.tsx         # 세션 목록
          [sessionKey]/
            page.tsx       # 영상 시청
```

---

### Phase 2: DB Add-only 확장 + 읽기 연결 ⭐⭐⭐⭐⭐

**DoD 체크리스트**:
- [ ] `webinars`에 type 추가(기존 row 영향 없음)
- [ ] 세션 JSON 저장/조회 가능
- [ ] `questions.session_key` 추가 + 온디맨드 전용 조회 인덱스/조건 준비
- [ ] 기존 라이브 QnA 화면/쿼리 영향 없음(회귀 테스트)

**평가**: ✅ **안전한 마이그레이션 계획입니다**

**마이그레이션 스크립트 예시**:
```sql
-- 1. type 컬럼 추가
ALTER TABLE webinars 
ADD COLUMN type TEXT CHECK (type IN ('live', 'ondemand'));

-- 2. settings JSONB 추가
ALTER TABLE webinars 
ADD COLUMN IF NOT EXISTS settings JSONB DEFAULT '{}'::jsonb;

-- 3. questions.session_key 추가
ALTER TABLE questions 
ADD COLUMN session_key TEXT;

-- 4. 인덱스 추가
CREATE INDEX idx_questions_session_key 
ON questions(webinar_id, session_key) 
WHERE session_key IS NOT NULL;

-- 5. 트래킹 테이블 생성
CREATE TABLE ondemand_session_events (
  id BIGSERIAL PRIMARY KEY,
  webinar_id UUID NOT NULL REFERENCES webinars(id) ON DELETE CASCADE,
  session_key TEXT NOT NULL,
  participant_id UUID REFERENCES profiles(id),
  visitor_id TEXT,
  actor_key TEXT NOT NULL,
  event_type TEXT NOT NULL CHECK (event_type IN (
    'play_start', 'progress_25', 'progress_50', 
    'progress_75', 'progress_90', 'complete'
  )),
  event_data JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(webinar_id, session_key, actor_key, event_type)
);

CREATE INDEX idx_ondemand_events_webinar_session 
ON ondemand_session_events(webinar_id, session_key);
CREATE INDEX idx_ondemand_events_actor 
ON ondemand_session_events(actor_key);
```

---

### Phase 3: 세션별 트래킹 ⭐⭐⭐⭐⭐

**DoD 체크리스트**:
- [ ] 세션별 `play_start` 이벤트가 1회만 적재(dedupe 검증)
- [ ] progress 25/50/75/90이 각 1회만 적재
- [ ] 익명(visitor)도 dedupe가 깨지지 않음(NULL unique 구멍 제거)
- [ ] 참가자 화면에 집계 쿼리 없음

**평가**: ✅ **명확한 검증 기준입니다**

**구현 포인트**:
1. **actor_key 확정**: 서버에서 `COALESCE(participant_id, visitor_id)` 처리
2. **클라이언트 측 중복 방지**: Set으로 이미 전송한 이벤트 추적
3. **서버 측 UNIQUE 제약**: 최종 안전장치

---

### Phase 4: 온디맨드 QnA ⭐⭐⭐⭐⭐

**DoD 체크리스트**:
- [ ] 세션별 질문 저장(`session_key` NOT NULL in ondemand)
- [ ] 관리자가 인박스에서 세션 필터로 질문 확인 가능
- [ ] 기존 라이브 QnA UX/데이터 영향 없음
- [ ] 참가자는 기본적으로 "내 질문"만 접근 가능(타인 질문 공개 기본 OFF)

**평가**: ✅ **기존 시스템과의 분리가 명확합니다**

**구현 포인트**:
1. **QnA 생성 시**: `session_key` 필수 (온디맨드)
2. **관리자 인박스**: 세션 필터 추가
3. **권한**: 참가자는 본인 질문만 조회 (기존과 동일)

---

### Phase 5: 알림(Email) ⭐⭐⭐⭐⭐

**DoD 체크리스트**:
- [ ] 질문 작성 시 알림이 큐/후처리로 실행(동기 blocking 금지)
- [ ] 실패 재시도 동작
- [ ] 수신자는 설정 기반(하드코딩 없음)

**평가**: ✅ **비동기 처리 원칙이 명확합니다**

**구현 옵션**:
1. **Vercel Queue**: 간단하지만 Vercel 전용
2. **Supabase Edge Functions**: 크론 기반 재시도
3. **간단한 큐 테이블**: `email_queue` 테이블 + 크론 작업

**권장**: 옵션 3 (큐 테이블) - 가장 유연하고 디버깅 용이

---

## ⚠️ 공통 리스크 방지 체크리스트

### A. 기존 라이브 보호 ⭐⭐⭐⭐⭐

- [ ] 라이브 2건 입장/시청/등록/설문/QnA 회귀 테스트 통과
- [ ] `/webinar/*` 라우트에 변경 없음(또는 변경이 있더라도 UI/동작 동일)

**평가**: ✅ **필수 검증 항목입니다**

---

### B. 코드 오염 방지 ⭐⭐⭐⭐⭐

- [ ] ondemand 트리에서 realtime/live 관련 import 0
- [ ] Player 컴포넌트가 `components/webinar/*`에 있으면 **중립 위치로 이동/복제**

**평가**: ✅ **명확한 가이드라인입니다**

**ESLint 규칙 제안**:
```json
{
  "rules": {
    "no-restricted-imports": [
      "error",
      {
        "paths": [
          {
            "name": "@/components/webinar/Chat",
            "message": "온디맨드에서는 Chat 컴포넌트 사용 금지"
          },
          {
            "name": "@/components/webinar/hooks/usePresencePing",
            "message": "온디맨드에서는 Presence Ping 사용 금지"
          }
        ],
        "patterns": [
          {
            "group": ["**/realtime/**", "**/attendance/**"],
            "message": "온디맨드에서는 realtime/attendance 모듈 사용 금지"
          }
        ]
      }
    ]
  },
  "overrides": [
    {
      "files": ["app/(ondemand)/**/*"],
      "rules": {
        "no-restricted-imports": "error"
      }
    }
  ]
}
```

---

### C. 데이터 정합성 ⭐⭐⭐⭐⭐

- [ ] 세션 식별자는 URL/asset_id가 아니라 `session_key` 기준
- [ ] 트래킹 dedupe가 익명에서도 깨지지 않음(NULL unique 구멍 제거)

**평가**: ✅ **핵심 검증 항목입니다**

---

### D. 성능 ⭐⭐⭐⭐⭐

- [ ] 참가자 화면에서 집계 쿼리/대형 조인 없음
- [ ] progress 이벤트 과다 전송 없음(25% 단위, 최대 4~5개)

**평가**: ✅ **성능 최적화 원칙이 명확합니다**

---

## 📝 추가 제안사항

### 1. **테스트 전략 강화**

**단위 테스트**:
- [ ] `actor_key` 생성 로직 테스트 (participant/visitor/null 케이스)
- [ ] 진행률 이벤트 중복 방지 로직 테스트
- [ ] 세션 JSON 파싱/검증 테스트

**통합 테스트**:
- [ ] 온디맨드 라우트에서 라이브 기능 접근 불가 확인
- [ ] 기존 라이브 웨비나 2건 회귀 테스트
- [ ] 트래킹 이벤트 적재/중복 방지 검증

---

### 2. **모니터링 추가**

**로그**:
- [ ] 온디맨드 페이지 접근 로그
- [ ] 트래킹 이벤트 적재 실패 로그
- [ ] 이메일 발송 실패 로그

**알림**:
- [ ] 트래킹 이벤트 적재 실패 알림 (임계값 초과 시)
- [ ] 이메일 큐 백로그 알림 (큐 크기 임계값)

---

### 3. **문서화**

**관리자 가이드**:
- [ ] 온디맨드 웨비나 생성 방법
- [ ] 세션 추가/수정 방법
- [ ] QnA 관리 방법

**개발자 가이드**:
- [ ] 온디맨드 라우트 구조
- [ ] 트래킹 이벤트 스키마
- [ ] QnA API 명세

---

## ✅ 최종 결론

**온디맨드 최종 작업 지시서는 매우 잘 설계되었습니다.**

### 구현 가능성: ⭐⭐⭐⭐⭐ (5/5)

### 주요 강점

1. ✅ **보수적 접근**: 기존 시스템 보호 최우선
2. ✅ **명확한 DoD**: 각 Phase별 검증 기준 명확
3. ✅ **실용적 설계**: NULL UNIQUE 함정 등 실제 문제 해결
4. ✅ **확장 가능**: N개 세션 지원 구조
5. ✅ **안전장치**: 공통 리스크 방지 체크리스트

### 개선된 사항 (이전 검토 대비)

1. ✅ **type 컬럼**: nullable로 더 안전하게 변경
2. ✅ **트래킹 중복 방지**: actor_key 방식으로 명확화
3. ✅ **컴포넌트 위치**: 중립 위치 이동 제안 추가
4. ✅ **DoD 체크리스트**: Phase별 명확한 검증 기준
5. ✅ **공통 리스크**: 릴리즈 전 필수 체크리스트

### 다음 단계

1. ✅ **Phase 1 시작**: 라우트 구조 생성 + Mock UI
2. ✅ **DB 마이그레이션 준비**: Phase 2용 스크립트 작성
3. ✅ **ESLint 규칙 추가**: 코드 오염 방지
4. ✅ **회귀 테스트 계획**: 기존 라이브 웨비나 보호

---

**검토 완료일**: 2026-02-03  
**검토 버전**: v2 (최종 작업 지시서 반영)
