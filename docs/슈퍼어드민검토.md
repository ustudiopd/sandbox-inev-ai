훌륭한 초안입니다. 다만 **보안·권한·데이터 접근 구조**를 몇 가지 보완하면 더 안전하고 유지보수하기 쉬운 “슈퍼어드민” 체계를 만들 수 있어요. 아래는 **Go/No‑Go 검토 + 권장 수정안**입니다. (요약 → 위험/개선 → 수정된 작업계획 → 코드 스니펫 → 체크리스트)

---

## 한 줄 요약 (결론)

* **대시보드/페이지 구성은 그대로 진행**하되,

  1. **슈퍼어드민 계정 생성은 HTTP API가 아니라 “시드 스크립트/마이그레이션”**로 처리,
  2. **RBAC + RLS 정책 일관화(roles 테이블/뷰) + 미들웨어 보호**,
  3. 대시보드 **번들형 RPC(집계 한 방 조회) + 캐시/리전 최적화**
     로 변경하는 것을 권장합니다.
* “admin / uslab3300” 같은 **고정 자격 증명은 금지**(2FA/SSO·1회성 토큰으로 대체).

---

## 주요 위험 포인트 (Blockers) & 개선

1. **고정 자격 정보(이메일/비밀번호) 노출 위험**

   * *문제*: `admin / uslab3300`는 즉시 유출·브루트포스 표적.
   * *개선*: **CLI/마이그레이션 시드**로 계정을 만들고, **임시 패스워드 + 최초 로그인 시 강제 변경** 또는 **Magic Link/SSO(구글/OIDC)** 사용.

2. **공개 HTTP로 “슈퍼어드민 생성 API” 제공**

   * *문제*: 라우트 남아 있으면 언제든 오용 가능(레이트리밋·CSRF·리스키).
   * *개선*: **HTTP 라우트 자체를 두지 않는 것**이 최선. 꼭 필요하면 **환경변수로 SETUP 모드 + HMAC 서명 + 1회성 토큰 + 실행 후 자동 폐기**까지 걸어야 합니다.

3. **권한 체크 위치 불분명**

   * *개선*:

     * **미들웨어**에서 `/super/**` 경로 접근을 **서버 측**에서 가로채고(클라 보호만으로는 불충분),
     * **서버 컴포넌트/Route Handler** 내부에서도 **2차 검증**(defense-in-depth).
     * DB에는 **roles/user_roles**로 RBAC를 명시하고 **RLS 정책**이 그 역할을 그대로 반영.

4. **집계 쿼리 다중 호출로 인한 지연**

   * *개선*: 대시보드 상단 카드(에이전시/클라이언트/웨비나 수), 최근 목록들을 **단일 RPC/뷰**로 **한 번에 반환**(번들형 Read‑API). 재방문은 **Edge 캐시 + 태깅/ETag**.

---

## 수정된 작업 계획 (제안)

### A. 슈퍼어드민 생성 (API → 시드 스크립트로 변경)

* **삭제**: `app/api/admin/create-super-admin/route.ts`
* **신규**: `scripts/seed-super-admin.ts` (Node 스크립트) 또는 SQL 마이그레이션

  * 서비스 롤 키 사용(서버에서만), 이메일은 환경변수로, 비밀번호는 **임시** + **초기 로그인 시 강제 변경**.
  * 실행 후 **감사 로그**에 기록.

> *불가피하게 API가 필요하면 하단 “대안 API(초강화 가드)” 참고.*

### B. RBAC + RLS 기본선

* **스키마(권장)**

  * `roles(id, name)` – 예: `super_admin`, `agency_admin`, `staff`
  * `user_roles(user_id uuid, role_id)` (+ 고유 키)
  * `agencies`, `clients`, `webinars` …
  * `is_super_admin(uid uuid)` 헬퍼 함수(또는 `exists` 서브쿼리)
* **RLS 정책**

  * Super‑admin: `exists(select 1 from user_roles where user_id = auth.uid() and role_id = (select id from roles where name='super_admin'))` 이면 `USING true`.
  * 나머지는 소속 agency/client 기준 세분화.
* **JWT/세션**

  * 세션에서 사용자 id만 쓰고, 권한 판단은 DB(RLS)와 서버 가드에서 **중복 확인**.

### C. 라우팅/레이아웃/보안

* **레이아웃**: `app/(super)/super/layout.tsx`(서버 컴포넌트)에서 **서버 측 권한 검사**.
* **미들웨어**: `/super/:path*` 접근 시 **세션 확인 + 슈퍼 권한 체크**.
* **페이지**: 대시보드/클라이언트/에이전시 페이지는 **Server Components**로 데이터 패칭(RPC 1~2회), 목록은 **키셋 페이지네이션**.

### D. 데이터 조회 최적화(대시보드)

* **단일 RPC** `admin_overview()` →

  * 상단 카드(카운트 3종)
  * 최근 에이전시/클라이언트 목록(상위 N)
  * 선택적으로 “빠른 액션”에 필요한 최소 메타
* **인덱스**: `(created_at DESC)` + `(agency_id)` 커버링 인덱스.
* **캐시**: 공개 메타는 **Edge 캐시** + `revalidateTag('admin_overview')` 패턴. 권한 데이터는 **no-store**.

---

## 코드 스니펫 (핵심 부분 요약)

### 1) (권장) 슈퍼어드민 시드 스크립트 – `scripts/seed-super-admin.ts`

```ts
// node -r dotenv/config scripts/seed-super-admin.ts
import { createClient } from '@supabase/supabase-js';

const url = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const serviceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;
const email = process.env.SUPER_ADMIN_EMAIL!; // e.g. security@your.co
const tempPassword = crypto.randomUUID();     // 임시 비번

(async () => {
  const supa = createClient(url, serviceKey);

  // 1) 유저 조회/생성
  const { data: existing } = await supa.auth.admin.listUsers({ page: 1, perPage: 1, email });
  let userId: string | undefined = existing?.users?.[0]?.id;

  if (!userId) {
    const { data, error } = await supa.auth.admin.createUser({
      email,
      password: tempPassword,
      email_confirm: true,
      user_metadata: { force_password_reset: true }
    });
    if (error) throw error;
    userId = data.user?.id!;
    console.log('Super admin created:', email, '(temporary password issued)');
  } else {
    console.log('Super admin exists:', email);
  }

  // 2) 역할 부여
  const { error: roleErr } = await supa
    .from('user_roles')
    .upsert({ user_id: userId, role_id: 1 /* super_admin id */ }, { onConflict: 'user_id,role_id' });
  if (roleErr) throw roleErr;

  // 3) 감사 로그
  await supa.from('audit_logs').insert({
    actor_user_id: userId,
    action: 'SEED_SUPER_ADMIN',
    meta: { email },
  });

  console.log('Done.');
})();
```

### 2) (차선) 초기화용 “한시적 API”를 꼭 써야 할 때

* **필수 가드**

  * `NODE_ENV === 'production'`면 **기본 차단**
  * `process.env.SETUP_TOKEN`과 `x-setup-token` HMAC 상호검증(상수시간 비교)
  * **1회성 토큰** 및 **실행 후 즉시 비활성화**(파일 플래그/키 회전)
  * IP allowlist(사내 VPN) + 짧은 레이트리밋
* 라우트 실행 성공 시, **환경변수 플래그 OFF** + **라우트 410 Gone** 처리.

> *가능하면 이 경로는 피하는 것이 최선입니다.*

### 3) 미들웨어 보호 – `middleware.ts`

```ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { getSessionAndRole } from './server/auth'; // 서버 유틸, 쿠키→세션

export async function middleware(req: NextRequest) {
  const path = req.nextUrl.pathname;
  if (path.startsWith('/super')) {
    const { isAuthenticated, isSuper } = await getSessionAndRole(req);
    if (!isAuthenticated) return NextResponse.redirect(new URL('/login', req.url));
    if (!isSuper) return NextResponse.json({ message: 'Forbidden' }, { status: 403 });
  }
  return NextResponse.next();
}

export const config = { matcher: ['/super/:path*'] };
```

### 4) 레이아웃에서 2차 방어 – `app/(super)/super/layout.tsx`

```tsx
import 'server-only';
import { assertSuper } from '@/server/auth';
import Sidebar from './_components/Sidebar';

export default async function SuperLayout({ children }: { children: React.ReactNode }) {
  await assertSuper(); // 서버에서 확정적으로 권한 확인
  return (
    <div className="flex min-h-dvh">
      <Sidebar />
      <main className="flex-1 p-6">{children}</main>
    </div>
  );
}
```

### 5) 대시보드 데이터 “한 방” – RPC/뷰 예시

**SQL(View or Function)**

```sql
-- admin_overview(view or stable function)
-- 결과: counts + 최근 목록 2종
-- 뷰 예시(간단형)
create or replace view admin_overview as
select
  (select count(*) from agencies) as agencies_count,
  (select count(*) from clients) as clients_count,
  (select count(*) from webinars) as webinars_count;

-- 최근 목록은 별도 view 두 개 + 조인 또는 함수에서 json_build_object로 번들
```

**서버 컴포넌트에서 호출**

```tsx
import { serverSupabase } from '@/server/supabase';

export default async function DashboardPage() {
  const supa = serverSupabase(); // 서비스롤 X, 권한 체크가 확실하면 서비스롤로도 가능(서버 한정)
  const [{ data: overview }, { data: recentAgencies }, { data: recentClients }] = await Promise.all([
    supa.from('admin_overview').select('*').single(),
    supa.from('agencies').select('id,name,created_at').order('created_at', { ascending: false }).limit(5),
    supa.from('clients').select('id,name,agency_id,created_at').order('created_at', { ascending: false }).limit(5),
  ]);

  // ...카드/테이블 렌더
}
```

> 트래픽이 커지면 **함수 하나가 JSON으로 “번들” 반환**하도록 바꾸고, 공개 메타는 Edge 캐시로 감쌉니다.

### 6) 페이지네이션/인덱스(클라이언트/에이전시)

```sql
-- 최근순 그룹핑/페이지네이션 최적화
create index if not exists idx_clients_agency_created on clients(agency_id, created_at desc, id desc) include (name);
create index if not exists idx_agencies_created on agencies(created_at desc, id desc) include (name);
```

프론트는 **키셋 커서**(예: `beforeId`)로 “이전 N개” 로딩.

---

## 네비게이션/UI (요구사항 반영)

* **사이드바 항목**: 대시보드 / 에이전시 관리 / 클라이언트 관리 / 감사 로그
* **대시보드 카드**: 총 에이전시 / 총 클라이언트 / 총 웨비나
* **최근 목록**: 에이전시 5개, 클라이언트 5개(각 이름/생성일/바로가기)
* **빠른 액션**: 에이전시 생성, 클라이언트 관리, 감사 로그 열람
* **표준 UX**: 스켈레톤, 비동기 전환 시 토스트, 실패시 재시도 버튼

---

## 감사 로그 & 운영

* `audit_logs(id, actor_user_id, action, resource_type, resource_id, meta jsonb, ip, ua, created_at)`
* 모든 **생성/수정/삭제**는 **서버에서** 감사 로그에 기록(트랜잭션 내).
* `/super/audit-logs`에서 필터/검색 제공.

---

## 보안 체크리스트 (필수)

* [ ] **슈퍼어드민 생성은 시드/CLI**, API 라우트 제거
* [ ] **고정 비밀번호 금지**, 최초 로그인 비번 변경 또는 SSO/Magic Link
* [ ] `/super/**` **미들웨어 + 서버 레이아웃** 이중 보호
* [ ] **RLS 정책**: super_admin 전역 허용 + 하위 롤 세분 권한
* [ ] **레이트리밋/CSRF**(POST/변경 API), **로그인 시 2FA**(TOTP/SMS)
* [ ] **감사 로그** 전 경로에 삽입, 관리자 액션 알림(옵션)

---

## 성능 체크리스트 (권장)

* [ ] 대시보드 **번들형 RPC** 1~2회로 데이터 수집
* [ ] **키셋 페이지네이션** 전면 도입 + 커버링 인덱스
* [ ] **리전 맞춤**(DB와 함수 리전 일치), 공개 메타 **Edge 캐시**
* [ ] 목록 **가상 스크롤**(규모 커질 때)

---

### 최종 판단

* **진행 승인 (단, 위 수정 적용 전제)**: 페이지 구조·네비게이션·기능 목록은 매우 적절합니다.
* 가장 중요한 변경은 **“슈퍼어드민 생성 경로의 보안 강도”**입니다. API를 **시드/마이그레이션**로 대체하는 방향으로 바꾸고, RBAC/RLS/미들웨어 이중화까지 반영하면 **안전하고 빠른** 슈퍼어드민 대시보드가 됩니다.

원하시면, 위 시드 스크립트와 RLS/역할 테이블용 **SQL 마이그레이션 템플릿**까지 바로 드릴게요.
