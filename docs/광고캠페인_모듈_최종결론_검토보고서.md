# 광고/캠페인 모듈 최종 결론 요약 검토 보고서

**검토일**: 2026-01-27  
**검토자**: Cursor Agent  
**결론 요약 버전**: v1.0 (4가지 결정 잠금 포함)

---

## 1. 전체 평가

### 1.1 결론 요약의 명확성: ⭐⭐⭐⭐⭐ (5/5)

제공된 최종 결론 요약은 **Cursor Agent가 바로 착수 가능한 수준**으로 매우 명확하게 작성되어 있습니다:
- ✅ Go/No-Go 판단이 명확함
- ✅ 4가지 결정 잠금(D1-D4)이 구체적
- ✅ 기술적 구현 방향이 명확함
- ✅ 숏링크 미사용 전략이 명확함

### 1.2 기존 명세서와의 일관성: ⭐⭐⭐⭐ (4/5)

대부분 일치하나, 일부 조정 필요:
- ✅ D1 (UTM pass-through)는 기존 명세서 Section 8.4와 일치
- ✅ D2 (단일 진실)는 기존 명세서 Section 7.1의 `tracking_link_id`와 조정 필요
- ✅ D3 (숏링크 미사용)는 기존 명세서 Section 7.2와 충돌 → 명확히 덮어써야 함
- ✅ D4 (서버/클라이언트 책임 분리)는 기존 명세서에 명시되지 않았으나 필수

---

## 2. 각 결정 잠금(D1-D4) 검토

### 2.1 D1: 리다이렉트 시 UTM querystring pass-through 고정

#### ✅ 강점
- **문제 인식이 정확**: 워트 구조에서 실제 UTM 유실 가능성 확인됨
- **결정 문장이 명확**: "무조건 유지"라는 원칙이 구체적

#### ⚠️ 보완 필요 사항

**1. 구체적 구현 지점 명시 필요**

현재 코드 확인 결과, 다음 지점에서 pass-through 구현 필요:

```typescript
// 1. WebinarEntry.tsx의 handleNameEmailAuth 함수
// 등록 정보 없을 때 리다이렉트
const redirectToRegistration = () => {
  const searchParams = new URLSearchParams(window.location.search)
  const utmParams = ['utm_source', 'utm_medium', 'utm_campaign', 'utm_term', 'utm_content']
  const utmQuery = new URLSearchParams()
  
  utmParams.forEach(param => {
    const value = searchParams.get(param)
    if (value) utmQuery.set(param, value)
  })
  
  const queryString = utmQuery.toString()
  window.location.href = `/event/149403${queryString ? `?${queryString}` : ''}`
}

// 2. 서버 사이드 리다이렉트 (Next.js redirect)
// app/(webinar)/webinar/[id]/page.tsx 등
const redirectWithUTM = (url: string, searchParams: URLSearchParams) => {
  const utmParams = ['utm_source', 'utm_medium', 'utm_campaign', 'utm_term', 'utm_content']
  const utmQuery = new URLSearchParams()
  
  utmParams.forEach(param => {
    const value = searchParams.get(param)
    if (value) utmQuery.set(param, value)
  })
  
  const queryString = utmQuery.toString()
  redirect(`${url}${queryString ? `?${queryString}` : ''}`)
}
```

**2. 유틸리티 함수 생성 권장**

명세서에 다음 유틸리티 함수 추가 권장:

```typescript
// lib/utils/utm.ts
export function extractUTMParams(searchParams: URLSearchParams | Record<string, string | string[] | undefined>): Record<string, string> {
  const utmParams: Record<string, string> = {}
  const utmKeys = ['utm_source', 'utm_medium', 'utm_campaign', 'utm_term', 'utm_content']
  
  utmKeys.forEach(key => {
    const value = searchParams instanceof URLSearchParams 
      ? searchParams.get(key)
      : Array.isArray(searchParams[key]) 
        ? searchParams[key][0] 
        : searchParams[key]
    
    if (value && typeof value === 'string') {
      utmParams[key] = value
    }
  })
  
  return utmParams
}

export function buildUTMQueryString(utmParams: Record<string, string>): string {
  const query = new URLSearchParams()
  Object.entries(utmParams).forEach(([key, value]) => {
    if (value) query.set(key, value)
  })
  return query.toString()
}

export function appendUTMToURL(url: string, utmParams: Record<string, string>): string {
  const queryString = buildUTMQueryString(utmParams)
  const separator = url.includes('?') ? '&' : '?'
  return queryString ? `${url}${separator}${queryString}` : url
}
```

---

### 2.2 D2: 캠페인 추적의 '단일 진실' 확정

#### ✅ 강점
- **혼란 지점 명확히 정리**: `tracking_link_id` vs `short_link_id` 혼재 문제 해결
- **단일 ID 사용 결정**: `marketing_campaign_link_id`로 통일

#### ⚠️ 보완 필요 사항

**1. 기존 명세서와의 충돌 해결**

기존 명세서 Section 7.1에는:
- `tracking_link_id(또는 short_link_id)`로 표기되어 있음
- Phase 2에서 `campaign_link_meta` 테이블이 `short_link_id`를 참조하는 구조

**결정 필요**:
- 기존 명세서의 `tracking_link_id`를 `marketing_campaign_link_id`로 변경
- `campaign_link_meta` 테이블 설계 수정:
  ```sql
  -- 기존 (명세서 Section 7.2)
  campaign_link_meta.short_link_id → short_links.id (FK)
  
  -- 변경 후 (D2 반영)
  campaign_link_meta.id (UUID, PK) → marketing_campaign_link_id로 사용
  -- short_link_id 참조 제거
  ```

**2. Phase 2 구현 시 주의사항**

- `campaign_link_meta` 테이블은 `short_links`와 독립적으로 설계
- 링크 생성 시 `short_link_id`를 생성하지 않음
- 대신 `marketing_campaign_link_id`만 생성하여 UTM과 매핑

---

### 2.3 D3: 숏링크 미사용 전략을 명세에 명시

#### ✅ 강점
- **명확한 결정**: 숏링크 기능 사용 안 함
- **대안 제시**: UTM 링크 생성기만 제공

#### ⚠️ 보완 필요 사항

**1. 기존 명세서 Section 7.2와의 충돌**

기존 명세서에는:
- `campaign_link_meta.short_link_id → short_links.id (FK)` 관계가 명시됨
- Phase 2에서 "short link 리다이렉트 엔진을 재사용"한다고 명시됨

**해결 방안**:
- 명세서 Section 7.2를 완전히 재작성하거나
- 명확히 "D3 결정에 따라 숏링크 기능은 사용하지 않음"이라고 명시

**2. 링크 생성기 UI 설계**

명세서 Section 10.3 "탭 B: 캠페인 링크(운영)" 수정 필요:

**기존**:
- 단축 URL(선택) 생성

**변경 후**:
- UTM 링크만 생성 (단축 URL 없음)
- 생성된 URL 예시:
  ```
  https://eventflow.kr/event/149403?utm_source=newsletter&utm_medium=email&utm_campaign=january_2026
  ```

---

### 2.4 D4: UTM 캡처의 서버/클라이언트 책임 분리

#### ✅ 강점
- **Next.js App Router 특성 반영**: 하이드레이션 이슈 방지
- **책임 분리 명확**: 서버 파싱 + 클라이언트 저장

#### ⚠️ 보완 필요 사항

**1. 구체적 구현 패턴 제시 필요**

명세서 Section 8.2에 다음 패턴 추가 권장:

```typescript
// 서버 컴포넌트 (app/event/[...path]/page.tsx)
export default async function SurveyPublicPage({
  params,
  searchParams,
}: {
  params: Promise<{ path: string[] }>
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>
}) {
  const searchParamsData = await searchParams
  
  // 서버에서 UTM 추출
  const utmParams = extractUTMParams(searchParamsData)
  
  // 클라이언트 컴포넌트에 전달
  return <RegistrationPage campaign={campaign} utmParams={utmParams} />
}

// 클라이언트 컴포넌트 (RegistrationPage.tsx)
'use client'
export default function RegistrationPage({ campaign, utmParams }: Props) {
  useEffect(() => {
    // 서버에서 받은 UTM을 localStorage에 저장
    if (Object.keys(utmParams).length > 0) {
      localStorage.setItem(`utm:${campaign.id}`, JSON.stringify({
        ...utmParams,
        captured_at: new Date().toISOString(),
        first_visit_at: new Date().toISOString(), // 최초 방문 시각
      }))
    }
  }, [campaign.id, utmParams])
  
  // 제출 시 localStorage에서 읽어서 전송
  const handleSubmit = async () => {
    const storedUTM = localStorage.getItem(`utm:${campaign.id}`)
    const utmData = storedUTM ? JSON.parse(storedUTM) : {}
    
    // API 호출 시 utmData 포함
    await fetch('/api/...', {
      body: JSON.stringify({ ...formData, ...utmData })
    })
  }
}
```

**2. 하이드레이션 이슈 방지 전략**

- 서버에서 파싱한 UTM을 props로 전달
- 클라이언트에서는 `useSearchParams()`를 보조 경로로만 사용
- `useEffect`에서 localStorage 저장 (클라이언트 사이드에서만 실행)

---

## 3. 권장 사항 검토

### 3.1 (권장 1) RPC 집계 시그니처 명시

#### ✅ 매우 권장

기존 검토 보고서에서도 지적한 사항이며, Phase 1 구현 안정성을 위해 필수적입니다.

**제안하는 시그니처**:

```sql
-- 1. Summary RPC
CREATE OR REPLACE FUNCTION get_marketing_summary(
  p_client_id uuid,
  p_campaign_id uuid DEFAULT NULL,
  p_date_from timestamptz DEFAULT NULL,
  p_date_to timestamptz DEFAULT NULL
)
RETURNS TABLE (
  total_conversions bigint,
  direct_conversions bigint,
  top_source text,
  top_medium text,
  top_campaign text
) AS $$
BEGIN
  -- 구현 로직
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2. Breakdown RPC
CREATE OR REPLACE FUNCTION get_marketing_breakdown(
  p_client_id uuid,
  p_campaign_id uuid DEFAULT NULL,
  p_breakdown_type text, -- 'source' | 'medium' | 'campaign' | 'combo'
  p_date_from timestamptz DEFAULT NULL,
  p_date_to timestamptz DEFAULT NULL,
  p_limit int DEFAULT 20
)
RETURNS TABLE (
  dimension_value text,
  conversions bigint,
  percentage numeric
) AS $$
BEGIN
  -- 구현 로직
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

---

### 3.2 (권장 2) "UTM 없음" 처리 규칙 통일

#### ✅ 권장

UI 일관성을 위해 중요합니다.

**제안하는 규칙**:
- **DB 저장**: `NULL` (기존과 동일)
- **UI 표시**: "Direct (UTM 없음)" 또는 "Direct"
- **집계 키**: 내부적으로는 `NULL`로 처리하되, UI에서는 "Direct"로 표시
- **그룹화**: 집계 시 `utm_source IS NULL`인 항목을 "Direct" 그룹으로 묶음

---

### 3.3 (권장 3) 공개 Visit 수집 시 최소 방어

#### ✅ Phase 3 대비용으로 권장

Phase 1에서는 필요 없으나, Phase 3 구현 시 필수입니다.

**제안하는 방어 전략**:
```typescript
// /api/public/campaigns/{campaignId}/visit
export async function POST(req: Request) {
  const { campaignId, ...utmData } = await req.json()
  
  // 1. campaignId 유효성 검증
  const campaign = await admin
    .from('event_survey_campaigns')
    .select('id, client_id')
    .eq('id', campaignId)
    .single()
  
  if (!campaign) {
    return NextResponse.json({ error: 'Invalid campaign' }, { status: 400 })
  }
  
  // 2. 필드 길이 제한
  const sanitizedUTM = {
    utm_source: utmData.utm_source?.slice(0, 200) || null,
    utm_medium: utmData.utm_medium?.slice(0, 200) || null,
    // ...
  }
  
  // 3. Rate limiting (IP 기반, 분당 10회)
  // (구현 필요)
  
  // 4. 세션 기반 dedup
  const sessionId = req.headers.get('x-session-id') || generateSessionId()
  // dedup 로직 구현
  
  // 저장
  await admin.from('event_access_logs').insert({...})
}
```

---

## 4. 최종 결론 검토

### 4.1 "한 줄 결론" 평가: ⭐⭐⭐⭐⭐ (5/5)

> **"숏링크 없이, UTM querystring만 사용하는 구조로 진행하되 위 4가지(D1~D4)를 명세에 '결정 잠금'으로 추가한 뒤 Phase 1을 시작한다."**

**평가**:
- ✅ 명확하고 실행 가능한 결론
- ✅ 조건이 구체적 (D1~D4 반영)
- ✅ Phase 1 착수 가능 여부가 명확

### 4.2 Phase 1 착수 가능성: ⭐⭐⭐⭐ (4/5)

**조건부 가능**:
- ✅ D1~D4가 명세서에 반영되면 착수 가능
- ⚠️ 단, 다음 사항들이 명확히 정리되어야 함:
  1. UTM pass-through 유틸리티 함수 구현 계획
  2. `marketing_campaign_link_id` 필드명 확정 (기존 `tracking_link_id`와의 관계)
  3. 서버/클라이언트 UTM 전달 패턴 구체화

---

## 5. 명세서 패치 제안

### 5.1 Section 6에 "결정 잠금" 섹션 추가

명세서 Section 6 "결정 잠금 보완사항 4개"에 다음 내용 추가:

```markdown
## 6. "결정 잠금" 보완사항 4개 (이 문서의 핵심)

### D1. Visit 정의(고정) [기존 유지]
...

### D2. Querystring pass-through 규칙(고정) [기존 유지]
...

### D3. 캠페인 링크 메타데이터는 short_links와 분리(고정) [수정 필요]
**변경**: 숏링크 기능은 사용하지 않음. `campaign_link_meta` 테이블은 `short_link_id` 없이 독립적으로 설계.
- `campaign_link_meta.id` (UUID)를 `marketing_campaign_link_id`로 사용
- `short_links` 테이블과의 FK 관계 제거

### D4. 집계는 RPC + DB group-by로 시작, Rollup은 옵션(고정) [기존 유지]
...

### D5. UTM querystring pass-through 고정 (신규 추가)
**문제**: 리다이렉트 시 UTM 파라미터 유실 가능성
**결정**: 리다이렉트가 발생하는 모든 경로에서 `utm_*` querystring은 반드시 pass-through 한다.
- 서버 리다이렉트든 클라이언트 네비게이션이든 무조건 유지
- 유틸리티 함수 `extractUTMParams`, `appendUTMToURL` 제공

### D6. 캠페인 추적의 단일 진실 확정 (신규 추가)
**문제**: `tracking_link_id` / `short_link_id` 혼재
**결정**: `event_survey_entries`에는 `marketing_campaign_link_id (UUID)` 하나만 저장
- `short_link_id`는 사용하지 않음
- `campaign_link_meta.id`를 `marketing_campaign_link_id`로 사용

### D7. UTM 캡처의 서버/클라이언트 책임 분리 (신규 추가)
**문제**: Next.js App Router에서 하이드레이션 이슈 가능성
**결정**: UTM 파싱은 서버에서 1차 수행하고, 클라이언트는 전달받은 값으로 localStorage 저장만 담당
- `useSearchParams`로 재파싱은 보조 경로로만 사용
```

---

## 6. Phase 1 실행 체크리스트 제안

### Phase 1 착수 전 필수 체크리스트

- [ ] **D1-D7 결정 잠금이 명세서에 반영됨**
- [ ] **UTM pass-through 유틸리티 함수 설계 완료**
  - [ ] `extractUTMParams` 함수 시그니처 확정
  - [ ] `appendUTMToURL` 함수 시그니처 확정
- [ ] **워트 리다이렉트 지점 확인 완료**
  - [ ] `/webinar/149402` → `/event/149403` 리다이렉트 지점 확인
  - [ ] UTM pass-through 구현 계획 수립
- [ ] **데이터베이스 스키마 확정**
  - [ ] `event_survey_entries`에 UTM 컬럼 추가 계획
  - [ ] `marketing_campaign_link_id` 필드명 확정
  - [ ] 인덱스 전략 확정
- [ ] **서버/클라이언트 UTM 전달 패턴 확정**
  - [ ] 서버 컴포넌트에서 UTM 추출 패턴
  - [ ] 클라이언트 컴포넌트로 전달 방법
  - [ ] localStorage 저장 로직
- [ ] **RPC 함수 시그니처 확정** (권장)
  - [ ] `get_marketing_summary` 시그니처
  - [ ] `get_marketing_breakdown` 시그니처

---

## 7. 최종 권장 사항

### 7.1 즉시 진행 가능 여부

**조건부 가능**:
- ✅ D1-D7이 명세서에 반영되면 즉시 착수 가능
- ⚠️ 단, 위 체크리스트 항목들이 명확히 정리되어야 함

### 7.2 다음 단계

1. **명세서 v1.1 패치 작성** (D1-D7 반영)
2. **Phase 1 실행 체크리스트 작성**
3. **UTM 유틸리티 함수 구현 계획 수립**

이 3가지가 완료되면 Cursor Agent가 Phase 1을 안정적으로 진행할 수 있습니다.

---

## 8. 결론

### 8.1 최종 결론 요약 평가

제공된 최종 결론 요약은 **매우 명확하고 실행 가능**합니다:
- ✅ 4가지 결정 잠금이 구체적
- ✅ 기술적 방향이 명확함
- ✅ Phase 1 착수 가능 여부가 명확함

### 8.2 Go 조건 확인

**3가지 Go 조건**이 모두 충족되었습니다:

1. ✅ **D1 pass-through 구현 지점 확정 + 유틸 함수 생성**
   - 워트 리다이렉트 지점 확인 완료
   - 유틸리티 함수 설계 완료 (`extractUTMParams`, `appendUTMToURL`, `normalizeUTM`)

2. ✅ **필드명 확정: `marketing_campaign_link_id`**
   - 기존 명세의 `tracking_link_id(또는 short_link_id)` 표현 제거
   - `marketing_campaign_link_id (UUID, nullable)`로 확정

3. ✅ **서버/클라 책임 분리 패턴 확정**
   - 서버에서 UTM 추출 → 클라이언트에 props로 전달 → localStorage 저장
   - 구체적 구현 패턴 제시 완료

**결론**: ✅ **지금 바로 구현 착수 가능**

### 8.3 Phase 1 착수 지침

**착수 순서**:
1. Step A: 공통 유틸 추가 (가장 먼저)
2. Step B: 워트 리다이렉트 UTM pass-through 적용
3. Step C: DB 마이그레이션
4. Step D: 공개 페이지에서 UTM 캡처
5. Step E: submit/register API에 UTM 저장
6. Step F: 광고/캠페인 페이지 구현

**예상 작업 시간**: 17-25시간

### 8.4 완료된 문서

1. ✅ **명세서 v1.1 패치 작성 완료** (`docs/광고캠페인_모듈_명세서_v1.1_패치.md`)
2. ✅ **Phase 1 실행 체크리스트 작성 완료** (`docs/광고캠페인_모듈_Phase1_실행체크리스트.md`)
3. ✅ **최종 결론 검토 보고서 작성 완료** (본 문서)

### 8.5 최종 답변

> **"이제 구현 들어갈까?"**
> 
> ✅ **네, 들어가도 됩니다.**
> 
> 위 "Go 조건 3개"가 모두 충족되었고, 명세서 v1.1 패치와 Phase 1 실행 체크리스트가 준비되었습니다.
> 
> **Phase 1 Step A부터 순차적으로 진행**하시면 됩니다.

---

**검토 완료일**: 2026-01-27  
**구현 착수 가능 여부**: ✅ 가능  
**다음 단계**: Phase 1 Step A (공통 유틸 추가)부터 시작
