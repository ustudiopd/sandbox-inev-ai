# 온디맨드 시청 세션 설계 (OnDemand Playback Session)

**작성일**: 2026-02-09  
**버전**: 1.1  
**상태**: 확정 결정 반영 완료

---

## ✅ 확정 결정 (Confirmed Decisions)

다음 10개 항목은 **온디맨드 시청 데이터 설계의 최종 확정안**입니다.

### D-OD-1. 2-레이어는 확정

* **Visit = `event_visits`** (유입/경로/UTM)
* **PlaybackSession = `event_playback_sessions`** (시청/체류/완주율)
* 둘은 **분리 유지**가 원칙(절대 합치지 않음).

---

### D-OD-2. Visit는 항상 저장, UTM은 모듈 ON일 때만 저장

* `module_utm=false`여도 **path/referrer는 저장**
* `module_utm=false`면 **utm_*는 null**
* 이건 지금 구현 그대로 **확정 유지**.

---

### D-OD-3. PlaybackSession의 "DB 쓰기"는 무조건 서버(Service role)만

* `/start`, `/ping`, `/end`는 **서버 API가 service role로 INSERT/UPDATE**
* DB RLS는 **SELECT는 관리자만**, 퍼블릭 직접 INSERT는 금지

> 결과: "온디맨드/게스트/비로그인"도 안정적으로 수집 가능 + 보안/테넌트 안전.

---

### D-OD-4. watched_seconds는 "시청중(playing)"일 때만 누적

* ping payload에 `is_playing: boolean` 필드 추가
* 서버는 `is_playing=false`면 `watched_seconds` 누적 금지(단, `last_seen_at`은 갱신 가능)

---

### D-OD-5. end에서는 "추가 시청시간 추정 누적" 금지

* `/end`는 **exited_at만 설정**
* 시청시간 누적의 권위는 **오직 ping**(결정론적)

---

### D-OD-6. 활성 세션 정의는 exited_at이 아니라 last_seen 기반

* "활성" = `exited_at IS NULL AND last_seen_at >= now() - interval '5 minutes'`
* 통계/대시보드에서 이 정의를 사용

(옵션) 배치로 유령 세션 정리: `exited_at = last_seen_at` (나중 Phase)

---

### D-OD-7. 중복탭(동일 session_id) 방지: server throttle을 "필수"로

* 서버에서 `last_seen_at`이 **30초 이내면 watched_seconds 누적 0** (last_seen만 갱신)
* 이렇게 하면 탭 중복이 들어와도 누적 폭주 방지

---

### D-OD-8. unique_viewers 지표는 혼합 계산 금지 (분리 고정)

* `unique_sessions` = `COUNT(DISTINCT session_id)`
* `unique_leads` = `COUNT(DISTINCT lead_id)` (null 제외)
* 대시보드에는 둘 다 표시("브라우저 기준 / 등록자 기준")

---

### D-OD-9. source_visit_id는 start에서 "가능하면 자동 연결"이 기본

* 클라가 `source_visit_id`를 주면 그대로 저장
* 없으면 서버가 `event_id + session_id + 최근 N분` 기준으로 가장 최근 visit 1개를 찾아 자동 연결
* **`event_visits`에 `session_id` 컬럼 추가** (자동 연결을 위해 필수)

---

### D-OD-10. session_id TTL은 "30일"로 확정

* `ef_session_id` 쿠키 TTL = **30일**
* 목적: 재방문/재입장 분석, 방문→시청 전환 연결 안정화

---

## 1. 개요

### 1.1 목적

온디맨드 웨비나의 **시청/체류 데이터**를 수집하고 집계하기 위한 2-레이어 시스템:

1. **Visit (유입/경로)**: `event_visits` 테이블 - 마케팅/경로 분석용
2. **PlaybackSession (시청/체류)**: `event_playback_sessions` 테이블 - 시청 시간/완주율 분석용

### 1.2 설계 원칙

- **경량화**: 라이브 웨비나(`webinar_user_sessions`)보다 부하를 낮춤
- **분리**: 이벤트 컨테이너 구조(inev)와 충돌 방지
- **확장성**: 향후 세션/챕터 단위 확장 가능
- **정합성**: Visit과 Session 연결 가능

---

## 2. 데이터 모델

### 2.1 `event_playback_sessions` 테이블

**목적**: 온디맨드 영상 시청 세션 추적

**스키마**:
```sql
CREATE TABLE public.event_playback_sessions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- 이벤트 및 사용자 연결
  event_id uuid NOT NULL REFERENCES public.events(id) ON DELETE CASCADE,
  lead_id uuid REFERENCES public.leads(id) ON DELETE SET NULL,
  
  -- 세션 식별
  session_id text NOT NULL,  -- 브라우저 세션 UUID (ef_session_id)
  
  -- 콘텐츠 식별 (향후 확장용)
  content_id text,  -- 온디맨드 영상/세션 식별자 (현재는 null, 향후 세션/챕터 구분용)
  
  -- 시간 정보
  entered_at timestamptz NOT NULL DEFAULT now(),
  last_seen_at timestamptz NOT NULL DEFAULT now(),  -- 마지막 heartbeat 시간
  exited_at timestamptz,  -- null이면 아직 시청 중
  
  -- 시청 시간 추적
  watched_seconds integer DEFAULT 0,  -- 누적 시청 시간 (초)
  heartbeat_count integer DEFAULT 0,  -- heartbeat 호출 횟수 (옵션, 디버깅용)
  
  -- 유입 연결
  source_visit_id uuid REFERENCES public.event_visits(id) ON DELETE SET NULL,  -- 유입 visit 연결
  
  -- 디바이스/환경 정보 (옵션)
  user_agent_hash text,  -- user_agent 해시 (중복탭/디바이스 분석용)
  device_hint text,  -- 'mobile', 'desktop', 'tablet' (옵션)
  
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- 인덱스
CREATE INDEX idx_playback_sessions_event ON public.event_playback_sessions(event_id);
CREATE INDEX idx_playback_sessions_event_entered ON public.event_playback_sessions(event_id, entered_at DESC);
CREATE INDEX idx_playback_sessions_lead ON public.event_playback_sessions(lead_id) WHERE lead_id IS NOT NULL;
CREATE INDEX idx_playback_sessions_session ON public.event_playback_sessions(session_id);
-- 활성 세션 인덱스 (D-OD-6: last_seen 기반)
CREATE INDEX idx_playback_sessions_active ON public.event_playback_sessions(event_id, session_id, last_seen_at) 
  WHERE exited_at IS NULL;
CREATE INDEX idx_playback_sessions_visit ON public.event_playback_sessions(source_visit_id) WHERE source_visit_id IS NOT NULL;

-- RLS (D-OD-3: SELECT만 관리자용, INSERT/UPDATE는 서버 API가 service role로 처리)
ALTER TABLE public.event_playback_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "playback_sessions_select_own" ON public.event_playback_sessions FOR SELECT
  USING (event_id IN (SELECT id FROM public.events WHERE client_id IN (SELECT my_client_ids())));

-- INSERT/UPDATE 정책 없음: 서버 API가 service role로 직접 INSERT/UPDATE
-- 퍼블릭 직접 INSERT는 금지

COMMENT ON TABLE public.event_playback_sessions IS 'inev: 온디맨드 시청 세션 추적 (Visit과 분리된 시청/체류 레이어). INSERT/UPDATE는 서버 API(service role)만 가능.';
```

**주요 특징**:
- `lead_id`는 nullable: 등록 전 접속도 추적 가능
- `source_visit_id`로 유입 경로 연결 가능
- `content_id`는 향후 세션/챕터 구분용 (현재는 null)
- **활성 세션 정의**: `exited_at IS NULL AND last_seen_at >= now() - interval '5 minutes'` (D-OD-6)

---

## 3. Heartbeat 메커니즘 (경량화)

### 3.1 설계 원칙

EventFlow의 라이브 웨비나 heartbeat와 비교:

| 항목 | 라이브 웨비나 | 온디맨드 (권장) |
|------|--------------|----------------|
| 주기 | 120초 ± 10초 | **30~60초** |
| Cap (Δt 최대값) | 360초 | **120초** |
| Throttle (최소 간격) | 60초 | **30초** |
| Visibility 체크 | 없음 | **있음** (hidden 시 중단) |
| beforeunload 처리 | 있음 | **있음** (best-effort) |

### 3.2 클라이언트 구현 규칙

```typescript
// 경량 heartbeat 설정
const HEARTBEAT_INTERVAL = 45 * 1000;  // 45초 (30~60초 범위)
const HEARTBEAT_CAP = 120 * 1000;  // 120초 cap
const HEARTBEAT_THROTTLE = 30 * 1000;  // 30초 throttle

let heartbeatTimer: NodeJS.Timeout | null = null;
let lastHeartbeatTime = 0;

function startHeartbeat(eventId: string, sessionId: string) {
  // 첫 heartbeat는 즉시 전송
  sendHeartbeat(eventId, sessionId);
  
  // 이후 주기적으로 전송
  heartbeatTimer = setInterval(() => {
    // Visibility 체크: hidden이면 스킵
    if (document.visibilityState === 'hidden') {
      return;
    }
    
    // Throttle 체크
    const now = Date.now();
    if (now - lastHeartbeatTime < HEARTBEAT_THROTTLE) {
      return;
    }
    
    sendHeartbeat(eventId, sessionId);
  }, HEARTBEAT_INTERVAL);
}

function sendHeartbeat(eventId: string, sessionId: string, isPlaying: boolean) {
  const now = Date.now();
  const deltaTime = now - lastHeartbeatTime;
  
  // Cap 적용: 최대 120초까지만 인정
  const cappedDelta = Math.min(deltaTime, HEARTBEAT_CAP);
  
  fetch(`/api/inev/events/${eventId}/ondemand/sessions/ping`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      session_id: sessionId,
      delta_seconds: Math.floor(cappedDelta / 1000),
      is_playing: isPlaying,  // D-OD-4: 시청 중일 때만 누적
    }),
  }).catch(() => {
    // 실패해도 무시 (graceful failure)
  });
  
  lastHeartbeatTime = now;
}

// 페이지 종료 시 exited_at 마감 (best-effort)
window.addEventListener('beforeunload', () => {
  if (heartbeatTimer) {
    clearInterval(heartbeatTimer);
  }
  
  // navigator.sendBeacon 사용 (비동기, 페이지 종료 후에도 전송)
  const sessionId = getOrCreateSessionId('ef_session_id', 30 * 24 * 60 * 60 * 1000);  // D-OD-10: 30일 TTL
  navigator.sendBeacon(
    `/api/inev/events/${eventId}/ondemand/sessions/end`,
    JSON.stringify({ session_id: sessionId })
  );
});

// pagehide도 처리 (모바일 등)
window.addEventListener('pagehide', () => {
  // beforeunload와 동일 처리
});
```

---

## 4. API 엔드포인트

### 4.1 세션 시작

**엔드포인트**: `POST /api/inev/events/[eventId]/ondemand/sessions/start`

**Request Body**:
```typescript
{
  session_id: string;  // 필수: 브라우저 세션 UUID
  lead_id?: string;  // 옵션: 등록된 경우
  content_id?: string;  // 옵션: 향후 세션/챕터 구분용
  source_visit_id?: string;  // 옵션: 유입 visit 연결
  user_agent?: string;  // 옵션
  device_hint?: string;  // 옵션: 'mobile', 'desktop', 'tablet'
}
```

**Response**:
```typescript
{
  success: true;
  session_id: string;
  playback_session_id: string;  // 생성된 세션 ID
}
```

**처리 로직**:
1. 이벤트 존재 확인 (`module_ondemand` 활성화 여부 확인)
2. 기존 활성 세션 확인 (`event_id` + `session_id` + 활성 세션 조건: D-OD-6)
   - 있으면 기존 세션 반환 (재입장)
   - 없으면 새 세션 생성
3. `source_visit_id` 자동 연결 (D-OD-9):
   - 클라가 제공하면 그대로 저장
   - 없으면 `event_id + session_id + 최근 10분` 기준으로 가장 최근 visit 1개 찾아 연결
4. `lead_id`가 있으면 연결 (없으면 null, 나중에 업데이트 가능)
5. **서버 API는 service role로 INSERT** (D-OD-3)

---

### 4.2 Heartbeat (Ping)

**엔드포인트**: `POST /api/inev/events/[eventId]/ondemand/sessions/ping`

**Request Body**:
```typescript
{
  session_id: string;  // 필수
  delta_seconds: number;  // 필수: 마지막 heartbeat 이후 경과 시간 (cap 적용된 값)
  is_playing: boolean;  // 필수: D-OD-4 - 시청 중일 때만 true
}
```

**Response**:
```typescript
{
  success: true;
  watched_seconds: number;  // 누적 시청 시간
  last_seen_at: string;  // ISO timestamp
}
```

**처리 로직**:
1. 활성 세션 조회 (`event_id` + `session_id` + 활성 세션 조건: D-OD-6)
2. 없으면 404 반환
3. **서버 측 Throttle (필수, D-OD-7)**:
   - `last_seen_at`이 30초 이내면 `watched_seconds` 누적 0 (last_seen_at만 갱신)
   - 이렇게 하면 탭 중복이 들어와도 누적 폭주 방지
4. `last_seen_at` 업데이트: `now()`
5. **시청 시간 누적 (D-OD-4)**:
   - `is_playing === true`일 때만: `watched_seconds = watched_seconds + delta_seconds`
   - `is_playing === false`면 누적하지 않음 (last_seen_at만 갱신)
6. `heartbeat_count` 증가 (옵션)
7. `updated_at` 업데이트
8. **서버 API는 service role로 UPDATE** (D-OD-3)

---

### 4.3 세션 종료

**엔드포인트**: `POST /api/inev/events/[eventId]/ondemand/sessions/end`

**Request Body**:
```typescript
{
  session_id: string;  // 필수
}
```

**Response**:
```typescript
{
  success: true;
  total_watched_seconds: number;  // 최종 시청 시간
}
```

**처리 로직** (D-OD-5):
1. 활성 세션 조회
2. `exited_at` 설정: `now()` (추가 시청시간 추정 누적 금지)
3. `updated_at` 업데이트
4. **서버 API는 service role로 UPDATE** (D-OD-3)

**Best-effort 처리**:
- `beforeunload`/`pagehide`에서 호출
- 실패해도 무시 (graceful failure)
- `navigator.sendBeacon` 사용 권장

---

### 4.4 통계 조회

**엔드포인트**: `GET /api/inev/events/[eventId]/stats/ondemand`

**Query Parameters**:
- `start_date` (옵션): 시작 날짜 (ISO string)
- `end_date` (옵션): 종료 날짜 (ISO string)

**Response**:
```typescript
{
  // 기본 통계
  total_sessions: number;  // 총 세션 수
  unique_sessions: number;  // 고유 세션 수 (D-OD-8: COUNT(DISTINCT session_id))
  unique_leads: number;  // 고유 등록자 수 (D-OD-8: COUNT(DISTINCT lead_id), null 제외)
  total_watched_seconds: number;  // 총 시청 시간
  avg_watched_seconds: number;  // 평균 시청 시간
  
  // 완주율 (콘텐츠 길이 기준, 향후 구현)
  completion_rate: {
    "0-10%": number;  // 0~10% 본 사람 수
    "10-50%": number;
    "50-80%": number;
    "80-100%": number;  // 완주
  };
  
  // 재방문
  re_entry_rate: number;  // 재입장 비율 (같은 session_id로 여러 세션)
  
  // 전환율
  visit_to_session_rate: number;  // Visit → Session 전환율 (source_visit_id 연결 기준)
  
  // 시간대별 통계 (옵션)
  hourly_stats?: Array<{
    hour: string;  // "2026-02-09T14:00:00Z"
    sessions: number;
    unique_sessions: number;  // D-OD-8
    unique_leads: number;  // D-OD-8
    total_watched_seconds: number;
  }>;
}
```

**집계 SQL 예시**:
```sql
-- 기본 통계 (D-OD-8: unique_viewers 분리)
SELECT 
  COUNT(*) as total_sessions,
  COUNT(DISTINCT session_id) as unique_sessions,  -- 브라우저 기준
  COUNT(DISTINCT lead_id) FILTER (WHERE lead_id IS NOT NULL) as unique_leads,  -- 등록자 기준
  SUM(watched_seconds) as total_watched_seconds,
  AVG(watched_seconds) as avg_watched_seconds
FROM event_playback_sessions
WHERE event_id = $1
  AND entered_at BETWEEN $2 AND $3;

-- 완주율 (콘텐츠 길이 필요, 향후 구현)
-- SELECT 
--   CASE 
--     WHEN watched_seconds / content_duration < 0.1 THEN '0-10%'
--     WHEN watched_seconds / content_duration < 0.5 THEN '10-50%'
--     WHEN watched_seconds / content_duration < 0.8 THEN '50-80%'
--     ELSE '80-100%'
--   END as bucket,
--   COUNT(*) as count
-- FROM event_playback_sessions
-- WHERE event_id = $1
-- GROUP BY bucket;

-- 재입장 비율
SELECT 
  COUNT(*) FILTER (WHERE session_count > 1)::float / NULLIF(COUNT(*), 0) as re_entry_rate
FROM (
  SELECT session_id, COUNT(*) as session_count
  FROM event_playback_sessions
  WHERE event_id = $1
  GROUP BY session_id
) sub;

-- Visit → Session 전환율 (D-OD-9: session_id로 자동 연결 가능)
SELECT 
  COUNT(DISTINCT eps.source_visit_id)::float / NULLIF(COUNT(DISTINCT ev.id), 0) as visit_to_session_rate
FROM event_visits ev
LEFT JOIN event_playback_sessions eps ON ev.id = eps.source_visit_id
WHERE ev.event_id = $1;
```

---

## 5. lead_id 연결 규칙

### 5.1 세션 시작 시점

- `lead_id`가 있으면 저장 (등록 완료 후 접속)
- `lead_id`가 없으면 `null`로 저장 (등록 전 접속)

### 5.2 나중에 연결하기

**시나리오**: 사용자가 등록 전에 접속 → 나중에 등록/로그인

**해결 방법**:
1. 등록/로그인 시점에 `session_id`로 활성 세션 찾기
2. `lead_id` 업데이트:
   ```sql
   UPDATE event_playback_sessions
   SET lead_id = $1, updated_at = now()
   WHERE event_id = $2
     AND session_id = $3
     AND lead_id IS NULL;
   ```
3. Visit도 동일하게 업데이트 가능 (D-OD-9: event_visits에 session_id 컬럼 추가 필요):
   ```sql
   UPDATE event_visits
   SET lead_id = $1
   WHERE event_id = $2
     AND session_id = $3  -- D-OD-9: session_id 컬럼 추가 확정
     AND lead_id IS NULL;
   ```

**주의사항**:
- `session_id`는 브라우저 세션 UUID이므로, 같은 브라우저에서 등록하면 연결 가능
- 다른 디바이스/브라우저에서는 연결 불가 (정상 동작)

---

## 6. 구현 단계 (Phase)

### Phase 1: 기본 구조 (필수)

**작업 목록**:
1. ✅ `event_visits` 테이블 및 API (완료)
2. `event_visits`에 `session_id` 컬럼 추가 (D-OD-9: 자동 연결을 위해 필수)
3. `event_playback_sessions` 테이블 생성 (마이그레이션)
4. 세션 시작 API (`/start`) - service role로 INSERT, source_visit_id 자동 연결
5. Heartbeat API (`/ping`) - service role로 UPDATE, is_playing 체크, 서버 throttle 필수
6. 세션 종료 API (`/end`) - service role로 UPDATE, exited_at만 설정
7. 클라이언트 heartbeat 구현 (온디맨드 페이지) - is_playing 전달, 30일 TTL

**DoD**:
- 온디맨드 페이지 접속 시 세션 시작
- 45초마다 heartbeat 전송
- 페이지 종료 시 세션 종료 (best-effort)
- DB에 시청 시간 저장 확인

---

### Phase 2: 통계 집계 (필수)

**작업 목록**:
1. 통계 API (`/stats/ondemand`) 구현
2. 기본 통계 (총 세션, 고유 시청자, 총/평균 시청 시간)
3. 재입장 비율 계산
4. Visit → Session 전환율 계산

**DoD**:
- 대시보드에서 온디맨드 통계 조회 가능
- 기본 지표 정확도 검증

---

### Phase 3: 고급 기능 (옵션)

**작업 목록**:
1. 완주율 계산 (콘텐츠 길이 정보 필요)
2. 시간대별 통계
3. `content_id` 기반 세션/챕터 구분
4. `lead_id` 자동 연결 (등록 시점)

**DoD**:
- 완주율 집계 정확도 검증
- 세션/챕터별 통계 분리 가능

---

## 7. 라이브 웨비나와의 차이점

| 항목 | 라이브 웨비나 | 온디맨드 |
|------|--------------|---------|
| **동접 추적** | 필수 (`webinar_live_presence`) | 불필요 (옵션) |
| **5분 버킷 스냅샷** | 필수 | 불필요 (옵션) |
| **Heartbeat 주기** | 120초 | 30~60초 (경량) |
| **Heartbeat Cap** | 360초 | 120초 |
| **세션 종료 처리** | 중요 (동접 계산) | 중요 (시청 시간 정확도) |
| **재입장 처리** | 중요 (동접 중복 방지) | 중요 (재방문 분석) |

**결론**: 온디맨드는 "동접"보다 "시청 시간/완주율"이 핵심이므로, 라이브보다 가볍게 구현 가능.

---

## 8. 테스트 시나리오

### 8.1 기본 시청 흐름

1. 사용자가 온디맨드 페이지 접속
   - ✅ Visit 기록 (`event_visits`)
   - ✅ Session 시작 (`event_playback_sessions`)
2. 45초 후 heartbeat 전송
   - ✅ `watched_seconds` 증가 확인
3. 페이지 종료
   - ✅ `exited_at` 설정 확인

### 8.2 재입장 시나리오

1. 사용자가 온디맨드 페이지 접속 (Session 1)
2. 페이지 종료
3. 다시 접속 (Session 2)
   - ✅ 새로운 세션 생성 확인
   - ✅ 재입장 비율 집계 확인

### 8.3 등록 후 연결 시나리오

1. 사용자가 등록 전 접속 (Session, `lead_id = null`)
2. 등록 완료 (`lead_id` 생성)
3. 세션 업데이트
   - ✅ `lead_id` 연결 확인
   - ✅ 통계에서 고유 시청자 수 정확도 확인

### 8.4 Visit → Session 연결 시나리오

1. 사용자가 랜딩 페이지 접속 (Visit 생성)
2. 온디맨드 페이지 접속 (Session 시작, `source_visit_id` 연결)
   - ✅ Visit과 Session 연결 확인
   - ✅ 전환율 집계 정확도 확인

---

## 9. 마이그레이션 파일

**파일**: `supabase/inev/004_event_playback_sessions.sql`

```sql
-- inev Phase 4: 온디맨드 시청 세션 추적
CREATE TABLE IF NOT EXISTS public.event_playback_sessions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  event_id uuid NOT NULL REFERENCES public.events(id) ON DELETE CASCADE,
  lead_id uuid REFERENCES public.leads(id) ON DELETE SET NULL,
  session_id text NOT NULL,
  content_id text,
  entered_at timestamptz NOT NULL DEFAULT now(),
  last_seen_at timestamptz NOT NULL DEFAULT now(),
  exited_at timestamptz,
  watched_seconds integer DEFAULT 0,
  heartbeat_count integer DEFAULT 0,
  source_visit_id uuid REFERENCES public.event_visits(id) ON DELETE SET NULL,
  user_agent_hash text,
  device_hint text,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_playback_sessions_event ON public.event_playback_sessions(event_id);
CREATE INDEX IF NOT EXISTS idx_playback_sessions_event_entered ON public.event_playback_sessions(event_id, entered_at DESC);
CREATE INDEX IF NOT EXISTS idx_playback_sessions_lead ON public.event_playback_sessions(lead_id) WHERE lead_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_playback_sessions_session ON public.event_playback_sessions(session_id);
-- 활성 세션 인덱스 (D-OD-6: last_seen 기반)
CREATE INDEX IF NOT EXISTS idx_playback_sessions_active ON public.event_playback_sessions(event_id, session_id, last_seen_at) 
  WHERE exited_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_playback_sessions_visit ON public.event_playback_sessions(source_visit_id) WHERE source_visit_id IS NOT NULL;

-- RLS (D-OD-3: SELECT만 관리자용, INSERT/UPDATE는 서버 API가 service role로 처리)
ALTER TABLE public.event_playback_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "playback_sessions_select_own" ON public.event_playback_sessions FOR SELECT
  USING (event_id IN (SELECT id FROM public.events WHERE client_id IN (SELECT my_client_ids())));

-- INSERT/UPDATE 정책 없음: 서버 API가 service role로 직접 INSERT/UPDATE
-- 퍼블릭 직접 INSERT는 금지

COMMENT ON TABLE public.event_playback_sessions IS 'inev: 온디맨드 시청 세션 추적 (Visit과 분리된 시청/체류 레이어). INSERT/UPDATE는 서버 API(service role)만 가능.';
```

---

## 10. event_visits 테이블 수정 (D-OD-9)

**필수 변경**: `event_visits`에 `session_id` 컬럼 추가

**마이그레이션 파일**: `supabase/inev/003_event_visits_add_session_id.sql`

```sql
-- D-OD-9: source_visit_id 자동 연결을 위해 session_id 추가
ALTER TABLE public.event_visits ADD COLUMN IF NOT EXISTS session_id text;

CREATE INDEX IF NOT EXISTS idx_event_visits_session ON public.event_visits(session_id);
CREATE INDEX IF NOT EXISTS idx_event_visits_event_session ON public.event_visits(event_id, session_id, created_at DESC);

COMMENT ON COLUMN public.event_visits.session_id IS '브라우저 세션 UUID (ef_session_id). D-OD-9: playback_session의 source_visit_id 자동 연결용.';
```

---

## 11. 참고 자료

- `event_visits` 테이블: `supabase/inev/003_event_visits.sql`
- `event_visits` session_id 추가: `supabase/inev/003_event_visits_add_session_id.sql` (필수)
- 라이브 웨비나 세션: `docs/specs/집계시스템_구현명세서.md`
- Visit API: `app/api/inev/visits/route.ts`
- 온디맨드 페이지: `app/event/[slug]/ondemand/page.tsx`

---

**다음 단계**: Phase 1 구현 시작 (마이그레이션 파일 생성 → API 엔드포인트 구현 → 클라이언트 통합)
