# inev.ai 리빌드 Implementation Plan (Cursor Agent 실행용)

**문서 버전**: v0.1 (Draft)
**작성일**: 2026-02-08 (KST)
**대상**: `inev.ai` 리빌드(신규) / `eventflow.kr`(기존)은 유지
**목표**: EventFlow 코드/운영 경험을 “템플릿화”해서, 클라이언트별 **서브도메인=독립 앱(Vercel 프로젝트)**을 빠르게 찍어내는 하이브리드 모델로 전환

---

## 0) 한 장 요약

* **eventflow.kr**: 유지(운영/레거시/검증 자산) 
* **inev.ai**: 새로 리빌드(템플릿 + 관리자 콘솔 + 기능 개발/테스트 베드)
* **배포 단위 고정**: `hpe.inev.ai`, `wert.inev.ai` 같은 **서브도메인 = 독립 앱(= Vercel 프로젝트)**
* **DB 전략**: 초기엔 `inev.ai` **공용 Supabase 1개**. 규모/지속성 큰 클라이언트만 **전용 Supabase 분리**
* **핵심 구조**: `Client(폴더) → Event(컨테이너) → Modules(등록/설문/웨비나/온디맨드/UTM/이메일/… )`
* **리스크 핵심**: “등록/설문(정적, email 중심)”과 “웨비나(실시간, session/user 중심)”를 그대로 섞으면 또 꼬임 → **레이어 분리 + 연결키 규칙**이 최우선
* **인증/입장 핵심**: 외부 발송(SMS/외부메일/DirectSend)에서 “자동실행”이 꼬임 → **입장 게이트 + 버튼 실행**으로 안정화
* **부하 핵심**: 웨비나 핫패스(5초 폴링/Presence/Realtime 폴백 등)  + 중복 로그인 체크 구조(5초마다 presenceState)

---

## 1) 목적

### 1.1 비즈니스/운영

* 클라이언트별 맞춤 페이지를 “복잡한 멀티테넌시 포털”이 아니라 **클라이언트 전용 웹앱**으로 단순하게 제공
* 4개 클라이언트 수준은 수동 운영 가능, 이후 **인스턴스 자동 생성(팩토리)**로 확장

### 1.2 기술

* EventFlow에서 기능이 “그때그때 추가”되며 꼬였던 부분을:

  * **Event 컨테이너 기준으로 재귀속**
  * **모듈 간 결합 최소화**
  * **실시간/비실시간 레이어 분리**
* 장애/부하 경험을 리빌드에 반영(핫패스/중복 로그인/표시명/게이트 등)

---

## 2) 전제 조건 & 불변 원칙

### 2.1 전제 조건

* `eventflow.kr`는 그대로 둔다 (리빌드는 별도 repo/DB)
* `inev.ai`는 “서비스”가 아니라 **템플릿(골든 템플릿)**이다
* 서브도메인 앱은 행사 종료 후:

  * Vercel 도메인 연결 끊음(비활성)
  * GitHub repo는 유지(재사용/감사/복구용)

### 2.2 Non-Negotiable Rules (리빌드 품질 규칙)

* **실시간 화면(웨비나 live)에서 무거운 계산/재집계/AI 호출 금지**
* 중복 로그인 방지/세션 제어는 **DB 핫쿼리 금지**, Realtime/클라 로직은 “필요할 때만” 이벤트 기반으로
* **하드코딩 금지**: 권한/모듈/통계 기준은 설정 가능 구조로
* “사실(fact) 로그”와 “해석(analysis)” 분리: CRM/AI는 로그를 만든 뒤에만 작동

---

## 3) 현재 베이스라인(가져올 자산)

### 3.1 EventFlow 기능 범위(이식 대상)

* 공개 경로: inev는 `/event/[slug]`, `/event/[slug]/enter`, `/event/[slug]/register`, `/event/[slug]/webinar` 등 **풀네임**; 레거시 EventFlow는 `/event/[...path]`. 그 외 `/webinar/[id]`, `/ondemand/[id]`, `/s/[code]` 등 
* 웨비나(라이브): 채팅/Q&A/폼/퀴즈/추첨/파일/접속자/통계 
* 온디맨드: 등록/로그인/시청/세션 기반 인증 
* UTM/Visit 추적: 존재(이벤트 단위로 재귀속 예정)
* 이메일 발송 시스템: 편집/미리보기/테스트 발송/예약값 저장(단, 예약 자동 발송 크론은 아직 없음)
* 핫패스 엔드포인트/폴링/폴백 구조: `stats/access` 5초, messages 폴백 2초± 등 

### 3.2 현재 구조에서 확인된 “꼬임 포인트”

* 웨비나 핵심 테이블이 **event_id 없이 webinar_id 중심** (향후 `Event 컨테이너`로 연결이 필요) 
* 이메일 링크 자동 로그인에서 이름이 전달되지 않으면 `display_name=email 로컬파트`가 되어 “jubileo” 같은 표시명 문제가 발생 
* 중복 로그인 방지 로직은 Presence+Broadcast 기반이며 5초마다 감지(타이밍 경합 시 “둘 다 튕김” 가능)

---

## 4) 목표 아키텍처(inev.ai) — “템플릿 + 인스턴스” 모델

### 4.1 레포/배포 모델

* **템플릿 레포(골든)**: `inev-template` (가칭)
* **클라이언트 인스턴스 레포**: 템플릿을 clone한 repo (예: `inev-hpe`, `inev-modoo`, `inev-wert`)
* **Vercel 프로젝트**: 인스턴스 레포 1개당 1개 생성 → 서브도메인 연결

> 업데이트 방식: 템플릿 개선 → 필요한 클라이언트 인스턴스에 “선택적 반영(merge/cherry-pick)”
> (자동 동기화는 나중에)

### 4.2 DB(Supabase) 모델

* 기본: `inev.ai` 공용 Supabase 1개
* 예외: 큰 클라이언트/장기 운영/보안 요구가 강한 클라이언트는 **전용 Supabase**로 분리
* 분리/이전이 쉬운 구조를 위해:

  * 이벤트/리드/응답/로그가 **event 단위로 export/import** 가능해야 함(백업/이관)

### 4.3 권한 모델(inev.ai 리빌드)

* **Admin** / **Participant** 2레벨로 단순화
* Admin은 “클라이언트 폴더”로 이벤트들을 관리(로그인 별도 분기 최소화)

---

## 5) 반드시 확정해야 하는 핵심 설계 결정(Decision Points)

> 아래 5개는 **리빌드 초기에 확정**해야, 나중에 “꼬임 재발”을 막을 수 있음.

### D1. 사람(Lead) 식별/연결 규칙

* 내부 기준키: UUID (DB PK/조인/로그 연결용)
* 사용자용 코드: 6자리(이벤트 스코프) 가능(현장/운영/CS/키오스크 입력용)
* **중복 등록 정책(웨비나 포함)**:

  * 이메일이 다르면 등록 허용(막지 않음)
  * “동일인 가능성”은 **fact 로그**로만 남김(추후 CRM 분석용)

### D2. Event 컨테이너 & 모듈 귀속 규칙

* “모든 단위는 이벤트로 시작”을 강제
* 웨비나/설문/온디맨드/메일/UTM는 **이벤트 모듈**로만 존재
* 웨비나 실시간 테이블(세션/하트비트/채팅/Q&A)은 **비실시간 등록 테이블을 직접 재사용하지 않는다**

  * 대신 “연결키(lead_id 또는 event_participant_id)”로 매칭

### D3. 인증/입장 UX 규칙(외부 발송 안정성)

* 외부 채널(SMS/DirectSend/외부메일) 링크 클릭 시:

  * **자동 실행(side effect) 금지**
  * “입장 게이트 페이지 → [입장하기] 버튼”에서만 세션/로그인 생성
* 수동입장(직접 입력)은 단계가 늘지 않도록 “한 화면”에서 처리

### D4. 표시이름(display name) 결정 규칙

* 기본: “등록 시 이름”
* 자동입장 시에도 이름이 URL로 안 와도 문제 없게:

  * 이메일로 등록 데이터에서 이름을 찾아 표시이름을 설정(또는 게이트에서 보여주기)
* email-signup 같은 API가 이름 없이 들어오면 로컬파트로 떨어지는 현상 방지 

### D5. 중복 로그인 방지 정책(부하/버그 재발 방지)

* 기존 방식의 문제:

  * 5초 주기 감지 + session_conflict 브로드캐스트 방식은 타이밍 경합 시 둘 다 튕길 수 있음
* 목표 UX:

  * “다른 위치에서 접속 중 → 연결을 끊을까요?”
  * 새 세션이 승자가 되면 기존 세션은 **다음 갱신(ping)에서** 자연 퇴장
* 구현 원칙:

  * “승자 결정 기준(권위)”은 하나여야 함(lease/최신 timestamp 등)

---

## 6) 데이터/모듈 설계 가이드(구체)

> **중요**: 여기서의 테이블/필드명은 “개념”이며, Cursor Agent가 기존 EventFlow 스키마와 충돌 없이 최종 확정한다.

### 6.1 Event 컨테이너(필수)

* Event는 반드시:

  * 이벤트 코드(숫자 6자리) **불변**
  * 슬러그(자유: `seminar1`, `seminar2` 등) **가변** (클라이언트 범위 유니크)
  * 모듈 ON/OFF 구성(등록/설문/웨비나/메일/UTM/온디맨드…)

### 6.2 Registration(등록) 모듈

* 저장:

  * 등록자(lead) 생성/연결
  * 이벤트 참여 관계(event_participation) 생성
* 중복 처리:

  * 동일 이메일 재등록은 “차단”이 아니라 **정보 갱신/재발송/재입장** UX로
  * 이메일이 다르면 신규 등록 허용 + 동일인 가능성 로그

### 6.3 Webinar(실시간) 모듈

* 세션/프레즌스/하트비트는 웨비나 레이어에만 존재
* 라이브 진입 시 반드시:

  * `lead_id ↔ live_session` 연결이 생성되어야 함
* 핫패스 최적화 시 체크:

  * `stats/access` 5초 폴링 등 기존 핫패스 패턴을 그대로 가져오되, 불필요 호출 줄이기 

### 6.4 Survey / Kiosk(비실시간 상호작용) 모듈

* 하트비트 대신:

  * 페이지 이벤트 로그(page_view, step_complete, submit 등) 기반
* Kiosk는 “단계 기반 로그 + 결과 리포트”로 설계

### 6.5 UTM/Visit 모듈

* **클라이언트 단위가 아니라 이벤트 단위**로 귀속
* Visit/UTM은 “등록 전/후 모두” 수집 가능해야 함

### 6.6 Email 모듈

* EventFlow 이메일 시스템 자산을 최대한 재사용:

  * 편집 필드/상태(draft/ready/…) 정책 유지 
  * 미리보기: 변수 치환 + markdown→html 파이프라인 유지 
* 예약 발송:

  * 현재는 `scheduled_send_at` 저장만 되고 자동 발송은 별도(크론 미구현) 
  * inev.ai에서는 “예약 실행(스케줄러)”을 옵션으로 설계(초기엔 수동 발송도 가능)

### 6.7 Short Link(/s) 모듈

* 문자/SMS는 **항상 짧은 링크** 사용
* 짧은 링크는 “리다이렉트”가 아니라 “게이트”:

  * 클릭 로그 기록
  * 채널/메시지/이벤트 식별
  * 최종 URL로 이동

---

## 7) 인증/입장 리빌드 플로우(최우선 품질 영역)

### 7.1 입장 게이트(Entry Gate) — 필수

* 자동입장 링크:

  * `?email=`만 있어도 입장 가능(이메일 기반으로 등록 정보 조회)
  * 페이지 오픈만으로 로그인/비번발급/세션생성 같은 side effect 금지
  * 버튼 클릭 시점에만 실행(스캐너/미리보기로 인한 꼬임 방지)

### 7.2 수동입장 UX(불편 최소)

* 수동 입력(이메일+이름)을 쓸 경우:

  * “홍길동님으로 입장합니다. (닉네임은 설정에서 변경 가능)” 안내만 노출
  * 입장 단계가 2번 뜨지 않게 **한 화면에서 끝**

### 7.3 닉네임 정책(추천)

* 웨비나에만 기본 ON:

  * 자동입장 경로에서는 “OOO으로 입장” + (선택) 닉네임 수정 UI
  * 수동입장 경로에서는 안내만(수정은 설정에서)

---

## 8) 중복 로그인 방지 리빌드(버그/부하 감소)

### 8.1 현재 구조의 사실(참고)

* 현재 설계는:

  * Presence에서 중복 감지
  * `session_conflict` broadcast를 보내고 받은 쪽이 퇴장
  * 5초마다 감지 루프가 있음

### 8.2 목표 동작(새 정책)

* 중복 감지 시 즉시 퇴장 ❌
* 새 세션 입장 시 사용자 선택:

  * “다른 위치에서 접속 중입니다. 연결을 끊고 이 기기에서 입장할까요?”
* “예”를 누른 세션이 승자
* 기존 세션은 “다음 갱신”에서 종료(양쪽 튕김 방지)

### 8.3 완료 기준(DoD)

* 동일 계정 2탭 동시 진입에서:

  * **둘 다 튕김이 재현되지 않음**
  * 승자 1개만 유지
  * Realtime 이벤트/폴링 부하가 기존보다 증가하지 않음

---

## 9) Novel.sh 기반 에디터 이식(콘텐츠 편집 통일)

* 목표: 이메일 본문/설문 문항/안내문 등 텍스트 편집 UX를 단일화
* 기존 가이드(ustudio-web에서 검증된 이식 체크리스트/파일 구성)를 그대로 활용
* 주의:

  * SSR 확장 분리 등 기존 시행착오 항목을 리빌드에서도 그대로 준수(재발 방지) 

---

## 10) Implementation Phases (순서대로 수행)

> 각 Phase는 “기능을 많이 만들기”보다, **꼬임 방지 규칙을 먼저 고정**하는 순서로 설계.

### Phase 0 — 리빌드 준비(Repo/DB/배포 뼈대)

**목적**: “새 repo + 새 Supabase + 첫 배포”까지 안전하게 뚫기

* [ ] EventFlow repo 클론 → `inev-template` 초기화
* [ ] Supabase 신규 프로젝트 생성(`inev.ai`)
* [ ] Vercel 프로젝트 생성 + `inev.ai` 기본 도메인 연결
* [ ] 환경변수/키 관리 방식 정리(공용 vs 클라 전용 Supabase 분리 대비)

**DoD**

* 로컬/스테이징/프로덕션 기본 페이지가 뜨고, Supabase 연결 확인

---

### Phase 1 — “Event 컨테이너 + 모듈 ON/OFF” 골격

**목적**: 앞으로 모든 기능이 “이벤트 기준”으로만 붙게 강제

* [ ] Admin UI: Client 폴더 → Event 목록/생성/편집
* [ ] Event 설정: 코드(숫자 6자리), 슬러그(자유), 모듈 ON/OFF
* [ ] Public UI: 서브도메인 앱은 “폴더 없이” 이벤트 목록 → 이벤트 상세로 진입

**리스크 체크**

* 하드코딩된 모듈 목록이 생기지 않게(설정 가능 구조)

**DoD**

* 이벤트 1개 생성 → public 페이지에서 진입 가능
* 모듈 OFF 상태면 관련 메뉴/라우트가 노출되지 않음

---

### Phase 2 — Registration + Survey(비실시간) 모듈 이식

**목적**: 웨비나 없이도 동작하는 “등록/설문” 베이스를 먼저 안정화

* [ ] Registration 폼(이메일/이름) + 중복 처리 UX(차단이 아닌 갱신/재발송)
* [ ] Survey 모듈(부스형/등록형/온디맨드 설문 등은 단계적)
* [ ] 데이터 export 기본(등록자 CSV)

**DoD**

* 이벤트 단위로 등록자/설문 응답이 관리되고, 데이터가 뒤엉키지 않음

---

### Phase 3 — UTM/Visit 모듈을 “이벤트 단위”로 재귀속

**목적**: UTM이 client가 아니라 event에 귀속된다는 원칙을 구현

* [ ] Visit 수집(랜딩/등록/완료 등 주요 페이지)
* [ ] UTM 파라미터 저장/집계(이벤트 범위)
* [ ] (옵션) 등록자/응답자와 visit 연결(가능하면)

**DoD**

* 동일 클라이언트 내 여러 이벤트가 있을 때 UTM이 섞이지 않음

---

### Phase 4 — Email 모듈 + 에디터 이식

**목적**: “이벤트에 붙는 이메일”을 완성(웰컴/리마인드/후속)

* [ ] 이메일 편집/미리보기/테스트발송/발송 로그 이식
* [ ] 에디터(Novel) 적용 범위 결정: 이메일 본문부터 적용
* [ ] 예약 발송은 “저장”까지만(스케줄러는 Phase 이후 옵션) 

**DoD**

* 이벤트에서 이메일 1개 생성 → 미리보기 → 테스트 발송까지 OK

---

### Phase 5 — Entry Gate(자동입장 안정화) + 표시이름 규칙 확정

**목적**: DirectSend/SMS/외부메일에서 “매직링크 꼬임” 재발 방지

* [ ] `/entry` 게이트 구현(자동입장/수동입장 모드)
* [ ] 링크 오픈만으로 side effect 금지, 버튼 클릭에서만 세션 생성
* [ ] 표시이름: 등록 데이터 기반으로 확정(“jubileo” fallback 방지) 

**DoD**

* 자동입장 링크로 들어와도 이름이 이메일 로컬파트로 떨어지지 않음
* 스캐너/미리보기로 인해 세션/로그인 꼬임이 재현되지 않음

---

### Phase 6 — Webinar(Live) 모듈 이식 + 중복로그인 정책 교체

**목적**: 실시간 레이어를 안전하게 붙이되, “등록 DB 재사용” 꼬임 방지

* [ ] 웨비나 모듈을 event에 귀속(기존 webinar_id 구조를 이벤트 컨테이너에 연결) 
* [ ] 핫패스/폴백/폴링 구조 점검(불필요한 5초 루프 최소화) 
* [ ] 중복 로그인 방지: “입장 시 선택 + 다음 갱신에 퇴장” 정책으로 교체

**DoD**

* WERT 케이스(등록+웨비나)에서 “등록 데이터 ↔ 라이브 세션” 연결이 깨지지 않음
* 두 탭 동시 접속에서도 “둘 다 튕김” 재현 불가

---

### Phase 7 — Short Link(/s) + SMS 모듈(옵션)

**목적**: 문자에서 “짧은 링크 + 클릭 로그”로 운영/CRM 기반 확보

* [ ] `/s/[code]` 게이트 구현(클릭 로깅 + 최종 URL 이동) 
* [ ] SMS 발송은 “이벤트 이메일 모듈”과 같은 패턴으로 붙이기(추후)

**DoD**

* 문자/카카오 링크가 표준 URL을 직접 노출하지 않고도 정상 입장
* 클릭 로그가 event 단위로 남음

---

### Phase 8 — “전용 Supabase 분리” 절차(운영 툴킷)

**목적**: WERT 같은 케이스를 안전하게 분리/이관할 수 있게 준비

* [ ] 이벤트 단위 데이터 export 포맷 확정(테이블/파일/스토리지 포함)
* [ ] import 절차 체크리스트(마이그레이션 스크립트가 아니라 “절차” 문서로 먼저)
* [ ] 전용 Supabase로 분리 시 환경변수/도메인/권한/RLS 점검 항목 작성

**DoD**

* “이벤트 1개”를 공용 → 전용 Supabase로 옮기는 리허설이 가능

---

### Phase 9 — 인스턴스 자동 생성(Factory) (장기)

**목적**: 클라이언트가 20개 이상으로 늘 때 자동화

* [ ] “클론 repo + Vercel 프로젝트 + 도메인 연결 + (옵션) Supabase 생성” 자동화 플로우 설계
* [ ] 초기엔 수동 운영, 자동화는 최소 기능부터(Provisioning only)

**DoD**

* 버튼/스크립트/워크플로우 중 하나로 “새 클라이언트 앱 생성” 반복 가능

---

## 11) 테스트/검증 체크리스트

### 11.1 기능 테스트(모듈별)

* [ ] Event 생성/편집/삭제(아카이브)
* [ ] Registration: 신규/중복(동일 이메일)/다른 이메일 2개 등록
* [ ] Survey: 제출/수정 정책/응답 export
* [ ] Email: 미리보기/변수치환/테스트발송/상태전이
* [ ] Entry Gate: 자동입장(이메일 파라미터)/수동입장/스캐너 환경(인앱 브라우저)
* [ ] Webinar: 채팅/Q&A/접속자/폴백 동작 
* [ ] Duplicate login: 두 탭/두 기기 동시 접속 시 승자 1명만 유지

### 11.2 성능/부하 테스트(웨비나)

* [ ] `stats/access` 5초 폴링 상황에서 동접 증가 시 안정성 확인 
* [ ] Realtime 폴백(메시지 2초± / 질문 5초) 시 과부하 확인 
* [ ] Presence 이벤트량/중복로그인 체크로 인한 트래픽 확인

---

## 12) 운영 체크리스트(클라이언트 추가/이벤트 종료)

### 12.1 새 클라이언트(서브도메인 앱) 생성 절차(수동)

* [ ] 템플릿 repo 클론 → 인스턴스 repo 생성
* [ ] Vercel 프로젝트 생성, 서브도메인 연결
* [ ] `.env` 설정: 공용 Supabase 또는 전용 Supabase 선택
* [ ] Admin에서 Client 폴더/기본 이벤트 생성

### 12.2 이벤트 종료/폐기(앱 비활성)

* [ ] 도메인 연결 끊기(또는 maintenance 페이지로)
* [ ] 데이터 export(등록/응답/로그/메일 로그)
* [ ] repo 유지(재사용/감사/재오픈 대비)

---

## 13) “오늘 확정하면 좋은” 초기 결정 5개(체크박스)

* [ ] (D1) Lead 내부키(UUID) + 사용자코드(6자리, 이벤트 스코프) 병행
* [ ] (D2) Event 컨테이너를 최상위로 강제 + 모듈 ON/OFF 설계
* [ ] (D3) 외부 발송 링크는 **항상 게이트**로, 버튼 클릭에서만 실행
* [ ] (D4) 표시이름은 “등록 이름”이 기본, 자동입장도 등록 데이터에서 조회
* [ ] (D5) 중복 로그인 방지는 “입장 시 선택 + 다음 갱신에 퇴장”으로 교체

---

### 끝

원하면, 다음 단계로는 이 Plan을 그대로 Cursor에 붙여 넣을 수 있게 **“Phase 0~2를 실제 태스크 보드 형태(checkbox + 담당 파일/영향 범위/롤백 포인트)”**로 더 쪼개서 만들어줄게.
