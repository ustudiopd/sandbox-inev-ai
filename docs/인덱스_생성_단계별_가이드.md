# 인덱스 생성 단계별 가이드 (타임아웃 방지)

## 문제 상황

대용량 테이블에서 여러 인덱스를 한 번에 생성하면 타임아웃이 발생할 수 있습니다.

## 해결 방법: 단계별 실행

인덱스를 3단계로 나누어 하나씩 생성합니다.

---

## 1단계: profiles.email 인덱스 생성 (가장 중요!)

**파일**: `supabase/migrations/095_add_performance_indexes.sql`

**Supabase 대시보드 SQL Editor에서 실행**:

```sql
-- 타임아웃 설정 증가 (선택적)
SET statement_timeout = '10min';

-- profiles.email 인덱스 생성
-- CONCURRENTLY 옵션으로 테이블 락 없이 생성 (더 안전)
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_profiles_email 
ON public.profiles(email);
```

**확인**:
```sql
-- 인덱스 생성 확인
SELECT indexname, indexdef 
FROM pg_indexes 
WHERE tablename = 'profiles' 
  AND indexname = 'idx_profiles_email';
```

**예상 소요 시간**: 
- 작은 테이블 (< 10만 행): 1-2분
- 중간 테이블 (10만-100만 행): 5-10분
- 큰 테이블 (> 100만 행): 10-30분

---

## 2단계: profiles.email_lower 인덱스 생성 (선택적)

**파일**: `supabase/migrations/096_add_performance_indexes_part2.sql`

**1단계가 완료된 후 실행**:

```sql
-- 소문자 이메일 검색 인덱스
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_profiles_email_lower 
ON public.profiles(LOWER(email));
```

**확인**:
```sql
SELECT indexname, indexdef 
FROM pg_indexes 
WHERE tablename = 'profiles' 
  AND indexname = 'idx_profiles_email_lower';
```

---

## 3단계: 나머지 인덱스 생성

**파일**: `supabase/migrations/097_add_performance_indexes_part3.sql`

**2단계가 완료된 후 실행**:

```sql
-- agency_members.user_id 인덱스
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_agency_members_user_id 
ON public.agency_members(user_id);

-- client_members.user_id 인덱스
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_client_members_user_id 
ON public.client_members(user_id);

-- 테이블 통계 업데이트
ANALYZE public.profiles;
ANALYZE public.agency_members;
ANALYZE public.client_members;
```

**확인**:
```sql
-- 모든 인덱스 확인
SELECT 
  tablename,
  indexname,
  indexdef
FROM pg_indexes
WHERE tablename IN ('profiles', 'agency_members', 'client_members')
  AND indexname LIKE 'idx_%'
ORDER BY tablename, indexname;
```

---

## CONCURRENTLY 옵션의 장점

### 일반 인덱스 생성 (WITHOUT CONCURRENTLY)
- ❌ 테이블에 배타적 락(EXCLUSIVE LOCK) 설정
- ❌ 인덱스 생성 중 테이블 읽기/쓰기 불가
- ✅ 더 빠른 생성 속도

### CONCURRENTLY 옵션 사용
- ✅ 테이블 락 없이 생성 (SHARE UPDATE EXCLUSIVE LOCK)
- ✅ 인덱스 생성 중에도 테이블 사용 가능
- ✅ 프로덕션 환경에서 안전
- ⚠️ 더 느린 생성 속도 (약 2-3배)

---

## 타임아웃 설정

### Supabase 대시보드에서 타임아웃 증가

1. **SQL Editor**에서 실행 전에:
```sql
SET statement_timeout = '10min';
```

2. 또는 **더 긴 타임아웃**:
```sql
SET statement_timeout = '30min';
```

### 주의사항
- 타임아웃을 너무 길게 설정하면 문제가 있는 쿼리가 오래 실행될 수 있습니다.
- 인덱스 생성 후 원래 설정으로 복원하는 것을 권장합니다:
```sql
SET statement_timeout = DEFAULT;
```

---

## 인덱스 생성 진행 상황 확인

```sql
-- 진행 중인 인덱스 생성 확인
SELECT 
  pid,
  now() - pg_stat_activity.query_start AS duration,
  query
FROM pg_stat_activity
WHERE query LIKE '%CREATE INDEX%'
  AND state = 'active';
```

---

## 문제 해결

### 인덱스 생성이 너무 느린 경우

1. **테이블 크기 확인**:
```sql
SELECT 
  schemaname,
  tablename,
  pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_tables
WHERE tablename IN ('profiles', 'agency_members', 'client_members')
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

2. **불완전한 인덱스 정리** (필요한 경우):
```sql
-- 불완전한 인덱스 확인
SELECT 
  indexrelid::regclass AS index_name,
  indisvalid AS is_valid
FROM pg_index
WHERE NOT indisvalid;

-- 불완전한 인덱스 삭제 (주의!)
-- DROP INDEX IF EXISTS idx_profiles_email;
```

### 인덱스 생성 실패 시

1. **에러 로그 확인**: Supabase 대시보드 → Logs → Postgres
2. **다시 시도**: 같은 SQL을 다시 실행 (IF NOT EXISTS로 중복 생성 방지)
3. **단계별 실행**: 더 작은 단위로 나누어 실행

---

## 최소 필수 인덱스

가장 중요한 인덱스만 먼저 생성하려면:

**1단계만 실행** (idx_profiles_email):
- 배치 프로필 조회 성능 향상에 가장 중요
- 나머지는 나중에 추가 가능

---

## 체크리스트

- [ ] 1단계: idx_profiles_email 생성 완료
- [ ] 2단계: idx_profiles_email_lower 생성 완료 (선택적)
- [ ] 3단계: 나머지 인덱스 생성 완료
- [ ] 모든 인덱스 확인 완료
- [ ] 테이블 통계 업데이트 완료

---

## 참고 자료

- `supabase/migrations/095_add_performance_indexes.sql` - 1단계
- `supabase/migrations/096_add_performance_indexes_part2.sql` - 2단계
- `supabase/migrations/097_add_performance_indexes_part3.sql` - 3단계
- `docs/성능_지연_원인_분석_보고서.md` - 성능 문제 분석
