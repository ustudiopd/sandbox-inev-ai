좋아요. 로그와 올려주신 코드 기준으로 “가끔 첫 메시지가 누락되고, 같은 이벤트가 두 번 들어오며, SUBSCRIBED 뒤에 CLOSED가 찍히는” 현상을 재현 가능한 원인까지 좁혔고, 바로 적용 가능한 패치안을 정리했습니다.

---

## 핵심 결론 (요약)

1. **첫 메시지 누락**

   * 실시간 핸들러에서 메시지 배열이 비어 있으면 **그냥 무시**하는 가드가 있어 빈 채팅방의 “첫 메시지”가 드랍됩니다. 이 조건은 제거해야 합니다. 
   * 또한 `created_at` 비교를 **`<=`**로 해 둔 탓에 **동일 타임스탬프**(초·ms까지 같은 경우)로 들어온 메시지가 “과거”로 오판되어 드랍됩니다. 비교식을 바꾸고, 가능하면 **ID 기반(증가 시퀀스)**으로 판정해야 합니다. 

2. **중복 이벤트**

   * 동일 `mid`(envelope id)가 두 번 처리되는 케이스가 보입니다. 다중 구독 가능성도 있지만, 무엇보다 **이벤트 단위 de‑dup(중복 제거)**가 없어 중복 로그·처리가 발생합니다. 실시간 핸들러에 **`seenMid` 집합**을 두고 중복을 컷해야 합니다. 

3. **SUBSCRIBED → CLOSED 경고 스팸 & 폴백 과도화**

   * “이벤트 3초 무(無)”면 폴백을 켜는 **헬스체크 임계치가 지나치게 공격적(3초)**이라, 정상 유휴시간에도 폴백이 자주 켜지고 재연결/해제가 반복됩니다. 최소 **20~30초**로 올리세요. 지금 로직은 3초마다 폴백 전환을 유도합니다. 
   * “성공 직후 CLOSED” 로그 중 일부는 **이전 채널 정리/해제** 또는 SDK 자동 재연결 사이클에서 자연스럽게 찍힐 수 있습니다. 현재는 CLOSED를 모두 “실패”로 취급해 재시도 카운트를 올리는데, 이 중 **정상 종료**를 구분해 카운트를 올리지 않도록 해야 불필요한 폴백 전환을 줄일 수 있습니다. 

4. **서버 브로드캐스트 측은 설계 자체는 OK**

   * Admin(Service Role) 클라이언트로 채널에 `subscribe()` 후 `channel.send({ type: 'broadcast', ... })` 하는 흐름은 정석입니다. 다만 서버리스(Lambda) 환경에서는 구독을 매번 열었다 닫는 비용이 클 수 있어, 실패 시 처리·로그 수준을 약간 보강하면 디버깅에 유리합니다. 

---

## 근거 (코드 위치)

* **빈 배열이면 실시간 메시지 무시**
  실시간 `chat:new` 처리 내부 `setMessages`에서 `prev.length === 0`이면 그대로 `prev`를 반환하는 가드가 존재합니다. 빈 채팅에서 **첫 메시지**가 실시간으로 들어오면 그대로 버립니다. 

* **동일 타임스탬프 드랍 (`<=`)**
  최신 메시지 `latestMsg`의 `created_at`과 신규 메시지의 `created_at`을 비교해 `newMsgTime <= latestTime`이면 **“과거”로 간주**하고 return 합니다. **동일 시각(=)** 인 경우도 드랍되어 첫 메시지/동시 메시지 손실을 유발합니다(실제 로그에도 “과거 메시지 무시 … A vs A”가 찍혔죠). 이 비교는 바꿔야 합니다. 

* **헬스체크 3초**
  “초기 로드 3초 이후, 최근 이벤트에서 3초 넘게 지나면 폴백”이라는 헬스체크가 1초 주기로 돌고 있습니다. 채팅이 잠깐 조용해도 폴백이 자주 켜지게 됩니다. 

* **폴백 폴링 주기**
  폴백은 2초 ± 0.5초 지터로 매우 공격적으로 돌고 있어 서버/API 부하도 올라갑니다. 실시간 경로가 살아 있는데도 빈번히 폴백을 호출할 수 있습니다. 

* **서버 브로드캐스트 흐름**
  `getAdminRealtimeClient()`로 Service Role 클라이언트를 생성 후 `channel.subscribe()` → `channel.send({type:'broadcast', event, payload})`로 전파합니다. 자체는 적절합니다. 

---

## 수정안 (우선순위 순)

### 1) 첫 메시지 드랍 방지 (필수)

* 실시간 핸들러의 `setMessages` 내부에서 **`if (prev.length === 0) return prev;` 제거**
  (성공·에러 분기 두 군데 모두 제거) 

### 2) “과거 판정”을 ID 우선으로, 타임스탬프는 보조로 (필수)

* `created_at` 비교는 DB/서버 정밀도·동시성 때문에 같을 수 있습니다.
  **정렬/과거 판정은 `id`(숫자, 단조 증가) 기준**으로 바꿔 주세요. `id`가 없을 때만 `created_at`을 사용합니다.
* 그리고 **중복 확인을 “과거 판정”보다 먼저** 하세요(이미 가진 메시지면 바로 return). 지금은 `<=` 비교가 먼저라서 아직 안 가진 메시지도 같은 시각이면 그냥 버립니다. 

> 간단 규칙
>
> * `if (existsByIdOrClientMsgId) return prev;`
> * `if (typeof new.id === 'number' && max(prev.id) >= new.id) return prev;`
> * 그 외엔 추가(정렬은 `(created_at, id)` 복합 키).

### 3) 이벤트 단위 중복 제거 (필수)

* 실시간 envelope의 `mid`(로그에 보이는 UUID)를 **Set으로 캐싱**하고 동일 `mid` 재수신 시 무시합니다(메모리 보호를 위해 1~2천 개 정도만 유지). 이 한 줄이 “같은 브로드캐스트가 두 번 들어오는” 상황을 매우 효과적으로 컷합니다. 

### 4) 헬스체크 임계치 완화 & CLOSED 분류 조정 (권장)

* 헬스체크 임계치를 **3초 → 30초**(최소 20초 이상)로 올리세요. 유휴 시간에 폴백이 켜지는 걸 막습니다. 
* `subscribe` 콜백에서 `CLOSED`를 모두 실패로 치지 말고, **직전이 `unsubscribe/removeChannel`에 따른 정상 종료인지**를 구분해 재시도 카운트를 올리지 않도록 하세요(예: 우리가 명시적으로 언서브한 경우, 혹은 동일 채널 교체 중인 경우는 카운트 X). 

### 5) 폴백 폴링 주기 상향/가변화 (권장)

* 폴백이 켜졌을 때 **기본 2초 → 5~10초**로 완화하고, 일정 시간(예: 30초) 이상 폴백 지속 시 **10→20→30초**로 늘리는 지수 백오프를 추천합니다. 지금은 실시간이 잠깐 조용해도 폴백이 과도하게 도네요. 

---

## 패치 스니펫 (발췌)

아래는 `Chat.tsx` 실시간 핸들러의 핵심 변경만 딱 필요한 만큼 보여드립니다.

**① seenMid / last id 레퍼런스 추가**

```ts
// 상단 선언부
const seenMidRef = useRef<Set<string>>(new Set());
const lastIdRef = useRef<number>(0); // 실시간에서도 사용 (폴백만 쓰지 말고 공용)
```

**② 실시간 브로드캐스트 핸들러 앞부분에 중복 차단 추가**

```ts
.on('broadcast', { event: '*' }, (payload: any) => {
  const env = (payload?.payload || payload);
  if (!isValidBroadcastEnvelope(env)) return;

  // 1) mid 단위 de-dup
  if (env?.mid) {
    const seen = seenMidRef.current;
    if (seen.has(env.mid)) {
      // console.log('중복 envelope(mid) 무시:', env.mid);
      return;
    }
    seen.add(env.mid);
    // 간단한 메모리 보호(최대 2000개만 유지)
    if (seen.size > 2000) {
      const it = seen.values(); seen.delete(it.next().value);
    }
  }
  // ...
```



**③ chat:new 처리에서 “빈 배열이면 무시” 제거 + 판정 순서/기준 변경**

```ts
if (env.t === 'chat:new') {
  const newMsg = env.payload as ChatMessagePayload;
  if (!newMsg || newMsg.hidden) return;

  if (initialLoadTimeRef.current === 0) return; // 초기 로드 끝나기 전은 여전히 무시

  setMessages((prev) => {
    // A. 중복 먼저 컷 (id / client_msg_id)
    if (prev.some(m =>
      m.id === newMsg.id ||
      (newMsg.client_msg_id && m.client_msg_id === newMsg.client_msg_id)
    )) {
      // console.log('중복 메시지 무시:', newMsg.id, newMsg.client_msg_id);
      return prev;
    }

    // B. "과거" 판정은 id 우선, 그다음 created_at
    const prevMaxId = prev.reduce((acc, m) =>
      typeof m.id === 'number' ? Math.max(acc, m.id) : acc, lastIdRef.current);

    // id가 있으면 id 기준
    if (typeof newMsg.id === 'number') {
      if (newMsg.id <= prevMaxId) {
        // console.log('과거 메시지(SEQ) 무시:', newMsg.id, '<=', prevMaxId);
        return prev;
      }
    } else {
      // id 없을 때만 created_at 보조 비교 (strict < 만 과거로 간주)
      const latestTime = prev.length ? new Date(prev[prev.length - 1].created_at).getTime() : 0;
      const newTime = new Date(newMsg.created_at).getTime();
      if (newTime < latestTime) {
        // console.log('과거 메시지(TS) 무시:', newMsg.created_at, '<', prev[prev.length - 1].created_at);
        return prev;
      }
    }

    // 통과 → 추가 및 정렬
    const updated = [...prev, {
      id: newMsg.id,
      user_id: newMsg.user_id,
      content: newMsg.content,
      created_at: newMsg.created_at,
      hidden: newMsg.hidden,
      user: /* 아래 fetchProfile 결과로 대체 */,
      client_msg_id: newMsg.client_msg_id,
    }].sort((a, b) =>
      new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
    );

    // 최신 id 보관 (실시간/폴백 공용 커서)
    if (typeof newMsg.id === 'number') {
      lastIdRef.current = Math.max(lastIdRef.current, newMsg.id);
    }
    return updated.length > MAX_MESSAGES_WINDOW
      ? updated.slice(-MAX_MESSAGES_WINDOW)
      : updated;
  });

  // (기존 fetchProfile 로직은 유지)
}
```

> 변경점
>
> * **`prev.length === 0` 가드 삭제**
> * **중복 체크 → 과거 판정** 순으로 재배치
> * **과거 판정: id > created_at**(동시각 드랍 제거)
> * **`lastIdRef` 갱신**으로 폴백/실시간 공용 커서 사용
>

**④ 헬스체크 임계치 완화 (3초 → 30초)**

```ts
// 3초 → 30000(30초)
if (timeSinceLastEvent > 30000 && !fallbackOn) {
  setFallbackOn(true);
}
```



**⑤ CLOSED 분류 조정(개념)**

* `subscribe` 콜백에서 `status === 'CLOSED'`일 때, **우리가 바로 직전에 `unsubscribe/removeChannel`를 호출한 케이스**인지 플래그로 구분해(예: `closingByUsRef`) 재시도 카운트를 올리지 않도록 하세요. 이렇게 하면 “성공→정상 종료” 케이스가 “실패”로 카운트되어 폴백을 켜는 부작용을 줄입니다. 

---

## 서버 브로드캐스트 측 점검 포인트

* `broadcastToWebinar()`에서 `subscribe()` 결과를 체크해 **타임아웃/에러 로깅을 명확히** 하면, 전파 실패 vs 클라이언트 수신 실패를 쉽게 구분할 수 있습니다. 설계 자체는 맞습니다(관리자 SRK로 채널 join → send). 

---

## 왜 “성공했다가 바로 CLOSED가 뜨나요?”

* 케이스 1) **우리가 기존 채널을 언서브**했을 때 자연스럽게 `CLOSED`가 찍힙니다. 지금은 이것도 실패로 카운팅합니다. 정상 종료는 실패 카운팅에서 제외하세요. 
* 케이스 2) **헬스체크 3초** 때문에 폴백·재연결이 너무 자주 돌고, 그 과정의 채널 교체에서 `CLOSED` 로그가 자주 보입니다. 임계치를 20~30초로 완화하면 이 현상이 대폭 줄어듭니다. 

---

## 검증 체크리스트

1. **빈 채팅방**에서 첫 메시지 수신: 실시간으로 즉시 표시되는지(누락 없음).
2. **동일 시각 다건**(한꺼번에 2~3건 전송) 수신: 모두 표시되는지(동시각 드랍 없음).
3. **중복 이벤트**: 같은 `mid` 로그가 와도 1회만 처리되는지.
4. **유휴 1~2분** 후에도 폴백이 켜지지 않는지(헬스체크 완화).
5. 관리자(Chrome)와 참가자(Edge) 교차 송수신: **순서 뒤바뀜/누락/중복 없음**.

---

## 덧붙임: 지금 상태에 대한 판단

* 마지막 로그에서 **“최초 한 번 누락”**만 남았다고 하셨는데, 이는 위 ①·②(빈 배열 가드 & `<=` 비교)가 대부분 설명합니다. 해당 패치를 적용하면 **첫 메시지 누락과 동시각 드랍**이 같이 해소될 가능성이 큽니다.
* 브라우저(Chrome/Edge) 차이는 아니며, **클라이언트 로직** 이슈로 보는 게 맞습니다.

필요하시면 위 스니펫을 해당 위치에 바로 넣어드릴 수 있도록 더 구체적인 diff 형태로도 정리해 드릴게요.
