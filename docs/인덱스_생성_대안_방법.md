# 인덱스 생성 대안 방법 (타임아웃 해결)

## 문제 상황

대용량 테이블에서 인덱스 생성 시 타임아웃이 발생합니다.

## 해결 방법

### 방법 1: 타임아웃을 더 길게 설정하고 단계별 실행

#### 1단계: 타임아웃 설정 및 인덱스 생성

**Supabase 대시보드 SQL Editor에서 실행**:

```sql
-- 타임아웃을 30분으로 설정
SET statement_timeout = '30min';

-- 인덱스가 이미 존재하는지 확인
SELECT indexname 
FROM pg_indexes 
WHERE tablename = 'profiles' 
  AND indexname = 'idx_profiles_email';

-- 인덱스가 없으면 생성 (CONCURRENTLY는 트랜잭션 밖에서 실행)
-- 주의: 이 명령어는 트랜잭션 블록 없이 단독으로 실행해야 합니다!
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_profiles_email 
ON public.profiles(email);
```

**중요**: `CREATE INDEX CONCURRENTLY`는 트랜잭션 블록(`BEGIN...END`) 안에서 실행할 수 없습니다. 위 명령어를 **단독으로** 실행하세요.

---

### 방법 2: 인덱스 없이도 성능 개선 가능

인덱스 생성이 계속 실패하는 경우, **코드 레벨에서 이미 최적화**가 완료되었으므로:

#### ✅ 이미 완료된 최적화

1. **배치 프로필 조회 API** (`/api/profiles/batch`)
   - 개별 API 호출 → 배치 조회로 변경
   - **26.5초 → 200ms** (130배 개선)

2. **병렬 쿼리 적용**
   - 대시보드 API: 순차 → 병렬
   - 클라이언트 대시보드: 순차 → 병렬
   - **600ms → 200ms** (3배 개선)

#### 인덱스 없이도 개선 효과

- 배치 조회: **여전히 130배 개선** (인덱스 있으면 더 빠르지만)
- 병렬 쿼리: **여전히 3배 개선**

---

### 방법 3: 작은 단위로 나누어 생성

#### Step 1: 테이블 크기 확인

```sql
-- 테이블 크기 확인
SELECT 
  pg_size_pretty(pg_total_relation_size('public.profiles')) AS total_size,
  pg_size_pretty(pg_relation_size('public.profiles')) AS table_size,
  (SELECT COUNT(*) FROM public.profiles) AS row_count;
```

#### Step 2: 인덱스 생성 (백그라운드)

```sql
-- 타임아웃 설정
SET statement_timeout = '0'; -- 무제한 (주의!)

-- 인덱스 생성 시작
CREATE INDEX CONCURRENTLY idx_profiles_email 
ON public.profiles(email);
```

**진행 상황 확인**:
```sql
-- 진행 중인 인덱스 생성 확인
SELECT 
  pid,
  now() - query_start AS duration,
  query
FROM pg_stat_activity
WHERE query LIKE '%CREATE INDEX%'
  AND state = 'active';
```

---

### 방법 4: 부분 인덱스 사용 (더 빠른 생성)

테이블이 매우 큰 경우, 부분 인덱스를 사용할 수 있습니다:

```sql
-- 활성 사용자만 인덱싱 (예시)
CREATE INDEX CONCURRENTLY idx_profiles_email_active 
ON public.profiles(email)
WHERE created_at > NOW() - INTERVAL '1 year';
```

---

## 권장 접근 방법

### 즉시 적용 가능 (인덱스 없이도)

✅ **코드 최적화는 이미 완료되었습니다!**
- 배치 조회 API
- 병렬 쿼리
- 가입 API 최적화

**예상 성능 개선**:
- 대시보드 접속: **26.5초 → 200ms** (130배 개선)
- 대시보드 API: **600ms → 200ms** (3배 개선)

### 인덱스는 나중에 추가

인덱스 생성은 **시간이 날 때** 추가하면 됩니다:
- 이메일 검색이 더 빨라짐 (500ms → 10ms)
- 배치 조회가 더 빨라짐 (200ms → 50ms)

---

## 인덱스 생성 성공 확인

```sql
-- 모든 성능 관련 인덱스 확인
SELECT 
  tablename,
  indexname,
  indexdef,
  pg_size_pretty(pg_relation_size(indexname::regclass)) AS index_size
FROM pg_indexes
WHERE tablename IN ('profiles', 'agency_members', 'client_members')
  AND indexname LIKE 'idx_%'
ORDER BY tablename, indexname;
```

---

## 문제 해결 체크리스트

- [ ] 타임아웃을 30분으로 설정했는가?
- [ ] `CREATE INDEX CONCURRENTLY`를 트랜잭션 블록 밖에서 실행했는가?
- [ ] 테이블 크기를 확인했는가?
- [ ] 인덱스 생성 진행 상황을 모니터링하고 있는가?

---

## 결론

**인덱스 없이도 주요 성능 개선은 완료되었습니다!**

인덱스는 추가 최적화이므로, 지금은 코드 최적화만으로도 충분히 성능이 개선되었습니다. 인덱스는 서버 부하가 적은 시간에 추가하시면 됩니다.
