# 설문/퀴즈/추첨 알림 방식 검토 보고서

**작성일**: 2026-02-08  
**검토 기준**: 실시간 이벤트 처리 방식 (Broadcast vs DB Changes vs 폴링)  
**목적**: 팝업/버튼 실시간 알림의 안정성 및 부하 영향 검토

---

## 📋 실행 요약

현재 구현은 **대부분 안전한 방식(Broadcast)**을 사용하고 있으나, **추첨 위젯에서 DB Changes 구독을 사용**하고 있어 개선이 필요합니다.

### 현재 상태 요약

| 기능 | 알림 방식 | 상태 | 부하 영향 | 비고 |
|------|----------|------|----------|------|
| **설문/퀴즈 오픈** | ✅ Broadcast | 안전 | 낮음 | WebinarView에서 팝업 표시 |
| **설문/퀴즈 마감** | ✅ Broadcast | 안전 | 낮음 | WebinarView에서 처리 |
| **추첨 결과 발표** | ✅ Broadcast | 안전 | 낮음 | draw API에서 호출 |
| **추첨 오픈** | ❌ Broadcast 없음 | - | - | 상태 변경 API에 Broadcast 없음 |
| **추첨 위젯 상태** | ⚠️ DB Changes | 위험 | 높음 | 개선 필요 |
| **설문 위젯 상태** | ❌ 실시간 없음 | - | - | 초기 로드만 |

---

## 1. 설문/퀴즈 오픈 알림

### ✅ 현재 구현: Broadcast (안전)

**서버 측** (`app/api/webinars/[webinarId]/forms/[formId]/status/route.ts`):
```typescript
// 상태 변경 시 Broadcast 전파
if (status === 'open') {
  if (form.kind === 'quiz') {
    broadcastQuizOpen(webinarId, updatedForm, user.id)
  } else {
    broadcastPollOpen(webinarId, updatedForm, user.id)
  }
}
```

**클라이언트 측** (`app/(webinar)/webinar/[id]/components/WebinarView.tsx`):
```typescript
// Broadcast 이벤트 구독
const broadcastChannel = supabase
  .channel(`webinar:${webinar.id}`)
  .on('broadcast', { event: '*' }, (payload: any) => {
    // 설문/퀴즈 오픈 이벤트 처리
    if (env.t === 'poll:open' || env.t === 'quiz:open') {
      // 팝업 표시
    }
  })
```

**평가**:
- ✅ **이벤트 빈도**: 매우 낮음 (설문 오픈 1회, 퀴즈 시작 1회)
- ✅ **전달 방식**: Broadcast 1회 이벤트
- ✅ **payload 크기**: 작음 (폼 ID + 기본 정보만)
- ✅ **클라이언트 반응**: UI만 변경, 상세 데이터는 API로 조회

**결론**: ✅ **안전한 방식, 문제 없음**

---

## 2. 추첨 결과 발표 알림

### ✅ 현재 구현: Broadcast (안전)

**서버 측** (`app/api/webinars/[webinarId]/giveaways/[giveawayId]/draw/route.ts`):
```typescript
// 추첨 완료 후 Broadcast 전파
broadcastRaffleDraw(webinarId, {
  giveaway: updatedGiveaway,
  winners: formattedWinners,
}, user.id)
```

**평가**:
- ✅ **이벤트 빈도**: 매우 낮음 (추첨 1회)
- ✅ **전달 방식**: Broadcast 1회 이벤트
- ⚠️ **payload 크기**: 중간 (당첨자 리스트 포함, 하지만 이벤트가 드물어 문제 없음)
- ✅ **클라이언트 반응**: UI만 변경

**결론**: ✅ **안전한 방식, 문제 없음**

---

## 3. 추첨 위젯 상태 업데이트

### ⚠️ 현재 구현: DB Changes 구독 (위험)

**클라이언트 측** (`components/webinar/GiveawayWidget.tsx:184-231`):
```typescript
// 실시간 업데이트 구독
const channel = supabase
  .channel(`webinar:${webinarId}:giveaways`)
  .on(
    'postgres_changes',
    {
      event: '*',
      schema: 'public',
      table: 'giveaways',
      filter: `id=eq.${giveawayId}`,
    },
    () => {
      loadGiveaway() // 전체 데이터 다시 로드
    }
  )
  .on(
    'postgres_changes',
    {
      event: 'INSERT',
      schema: 'public',
      table: 'giveaway_entries',
      filter: `giveaway_id=eq.${giveawayId}`,
    },
    async () => {
      // 참여자 수 업데이트
      const { count } = await supabase
        .from('giveaway_entries')
        .select('*', { count: 'exact', head: true })
        .eq('giveaway_id', giveawayId)
        .eq('eligible', true)
      
      setEntryCount(count || 0)
    }
  )
```

**문제점**:
1. **DB Changes 구독**: 모든 참가자가 `giveaways` 테이블 변경을 구독
   - 참가자 1,000명이 모두 구독하면 상태 변경 1회마다 RLS 평가 1,000번
   - 부하가 참가자 수에 비례하여 증가

2. **giveaway_entries INSERT 구독**: 참가자마다 INSERT 이벤트 발생
   - 참가자 1,000명이 모두 구독하면 INSERT 1회마다 이벤트 1,000개 전달
   - 부하가 참가자 수에 비례하여 증가

3. **loadGiveaway() 재호출**: 상태 변경 시 전체 데이터 다시 로드
   - 불필요한 API 호출 발생

**평가**:
- ❌ **이벤트 빈도**: 높음 (참가자마다 INSERT 이벤트 발생)
- ❌ **전달 방식**: DB Changes 구독 (RLS 평가 비용)
- ⚠️ **payload 크기**: 작지만 이벤트 수가 많음
- ⚠️ **클라이언트 반응**: 전체 데이터 재로드

**결론**: ⚠️ **위험한 방식, 개선 필요**

---

## 4. 설문 위젯 상태 업데이트

### ❌ 현재 구현: 실시간 구독 없음

**클라이언트 측** (`components/webinar/FormWidget.tsx`):
- 초기 로드만 수행 (`useEffect`에서 1회)
- 실시간 구독 없음
- 상태 변경 감지 없음

**평가**:
- 설문/퀴즈는 `WebinarView`에서 Broadcast로 팝업을 띄우므로, 위젯 자체의 실시간 업데이트는 불필요할 수 있음
- 다만 설문이 열렸을 때 위젯이 자동으로 표시되려면 Broadcast 구독이 필요할 수 있음

**결론**: ⚠️ **현재는 문제 없지만, 향후 개선 가능**

---

## 🔍 상세 분석

### 안전한 방식 (Broadcast)

**사용 위치**:
1. ✅ 설문/퀴즈 오픈 (`poll:open`, `quiz:open`)
2. ✅ 추첨 결과 발표 (`raffle:draw`)

**특징**:
- 이벤트 빈도: 매우 낮음 (라이브당 수회)
- 전달 방식: Broadcast 1회 → 모든 참가자에게 전달
- 부하 영향: 참가자 수와 무관 (Broadcast는 1회 전송)

**코드 위치**:
- 서버: `app/api/webinars/[webinarId]/forms/[formId]/status/route.ts`
- 서버: `app/api/webinars/[webinarId]/giveaways/[giveawayId]/draw/route.ts`
- 클라이언트: `app/(webinar)/webinar/[id]/components/WebinarView.tsx`

---

### 위험한 방식 (DB Changes)

**사용 위치**:
1. ⚠️ 추첨 위젯 상태 업데이트 (`giveaways` 테이블)
2. ⚠️ 추첨 참여자 수 업데이트 (`giveaway_entries` 테이블)

**특징**:
- 이벤트 빈도: 높음 (참가자마다 INSERT 이벤트 발생)
- 전달 방식: DB Changes 구독 (RLS 평가 필요)
- 부하 영향: 참가자 수에 비례하여 증가

**코드 위치**:
- 클라이언트: `components/webinar/GiveawayWidget.tsx:184-231`

---

## 📊 부하 영향 분석

### 시나리오: 참가자 1,000명, 추첨 1회

**현재 방식 (DB Changes)**:
- `giveaway_entries` INSERT 1회 → 이벤트 1,000개 전달
- `giveaways` 상태 변경 1회 → RLS 평가 1,000번
- 총 이벤트: 1,000개 + RLS 평가 1,000번

**개선 방식 (Broadcast)**:
- `giveaway_entries` INSERT → Broadcast 없음 (불필요)
- `giveaways` 상태 변경 → Broadcast 1회 전달
- 총 이벤트: 1개

**부하 차이**: 약 1,000배 차이

---

## ✅ 권장 개선 사항

### 1. 추첨 위젯: DB Changes → Broadcast 전환

**현재 문제**:
- `giveaway_entries` INSERT 구독으로 참가자마다 이벤트 발생
- `giveaways` 상태 변경 구독으로 RLS 평가 비용 발생
- 추첨 오픈 시 Broadcast 호출 없음 (상태 변경 API에 Broadcast 없음)

**개선 방안**:
```typescript
// GiveawayWidget.tsx 수정
useEffect(() => {
  // 초기 로드
  loadGiveaway()
  
  // Broadcast 이벤트 구독 (DB Changes 대신)
  const channel = supabase
    .channel(`webinar:${webinarId}`)
    .on(
      'broadcast',
      { event: 'raffle:draw' },
      (payload: any) => {
        const env = payload?.payload || payload
        if (env.t === 'raffle:draw' && env.payload?.giveaway?.id === giveawayId) {
          // 추첨 결과 업데이트
          loadGiveaway()
        }
      }
    )
    .on(
      'broadcast',
      { event: 'raffle:start' },
      (payload: any) => {
        const env = payload?.payload || payload
        if (env.t === 'raffle:start' && env.payload?.giveaway?.id === giveawayId) {
          // 추첨 오픈 업데이트
          loadGiveaway()
        }
      }
    )
    .subscribe()
  
  return () => {
    supabase.removeChannel(channel)
  }
}, [webinarId, giveawayId])
```

**추가 필요**:
1. **추첨 상태 변경 API에 Broadcast 추가** (`app/api/webinars/[webinarId]/giveaways/[giveawayId]/route.ts`):
   ```typescript
   // 상태 변경 시 Broadcast 전파
   if (status === 'open') {
     broadcastRaffleStart(webinarId, updatedGiveaway, user.id)
       .catch((error) => console.error('Broadcast 전파 실패:', error))
   }
   ```

2. **추첨 참여자 수는 Broadcast로 전달하지 않음** (불필요, 위젯에서 필요 시 API로 조회)
   - 참여자 수는 실시간 업데이트가 필수 아님
   - 필요 시 주기적 폴링 또는 사용자 액션 시 조회

### 2. 설문 위젯: Broadcast 구독 추가 (선택)

**현재 상태**: 실시간 구독 없음

**개선 방안** (선택적):
- 설문이 열렸을 때 위젯이 자동으로 표시되려면 Broadcast 구독 추가
- 현재는 `WebinarView`에서 팝업으로 처리하므로 필수는 아님

---

## 🎯 체크리스트 평가

### 1. 이벤트 빈도 ✅
- 설문 오픈: 라이브당 1회
- 퀴즈 시작: 라이브당 1회
- 추첨 오픈: 라이브당 1회
- 추첨 결과: 라이브당 1회
- **결론**: 이벤트 빈도가 매우 낮아 안전

### 2. 전달 방식 ⚠️
- 설문/퀴즈 오픈: ✅ Broadcast
- 추첨 결과: ✅ Broadcast
- 추첨 위젯 상태: ❌ DB Changes (개선 필요)

### 3. payload 크기 ✅
- 설문/퀴즈 오픈: 작음 (폼 ID + 기본 정보)
- 추첨 결과: 중간 (당첨자 리스트, 하지만 이벤트가 드물어 문제 없음)

### 4. 클라이언트 반응 ✅
- 이벤트 수신 시 UI만 변경
- 필요한 데이터는 API로 조회

---

## 📝 결론

### 현재 상태

**안전한 부분**:
- ✅ 설문/퀴즈 오픈: Broadcast 사용
- ✅ 추첨 결과 발표: Broadcast 사용

**개선 필요**:
- ⚠️ 추첨 위젯 상태 업데이트: DB Changes → Broadcast 전환 필요

### 권장 사항

1. **즉시 개선 (P1)**:
   - 추첨 위젯의 DB Changes 구독을 Broadcast로 전환
   - 추첨 상태 변경 API에 `broadcastRaffleStart` 호출 추가 (`PUT /api/webinars/[webinarId]/giveaways/[giveawayId]`)

2. **선택적 개선 (P2)**:
   - 설문 위젯에 Broadcast 구독 추가 (현재는 필수 아님)
   - 추첨 참여자 수는 실시간 업데이트 제거 (필요 시 API로 조회)

### 예상 효과

**개선 전** (DB Changes):
- 참가자 1,000명 기준:
  - 추첨 오픈: RLS 평가 1,000번
  - 추첨 참여자 INSERT 1회: 이벤트 1,000개 전달
  - 추첨 결과: RLS 평가 1,000번
  - 총: 이벤트 2,000개 + RLS 평가 2,000번

**개선 후** (Broadcast):
- 참가자 1,000명 기준:
  - 추첨 오픈: Broadcast 1회
  - 추첨 참여자 INSERT: Broadcast 없음 (불필요)
  - 추첨 결과: Broadcast 1회
  - 총: Broadcast 2회

**부하 감소**: 약 1,000배 이상

---

**검토 완료**: 2026-02-08
