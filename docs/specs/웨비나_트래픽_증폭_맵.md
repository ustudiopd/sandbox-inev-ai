# 웨비나 시작 시간 트래픽 증폭 맵

**작성일**: 2026-02-07  
**목적**: 웨비나 시작 시간에 호출되는 API 엔드포인트별 DB 쿼리 수/빈도 분석

---

## 요약

웨비나 시작 시간에 호출되는 주요 API 엔드포인트와 각각의 DB 쿼리 수를 정리했습니다.

**핵심 확인 사항**:
- ✅ **Presence ping 주기**: 120초 (2분) ± 10초 지터
- ✅ **중복 로그인 체크**: Realtime Presence 사용, **DB 쿼리 없음**, 5초마다 클라이언트 사이드 체크

---

## 트래픽 증폭 맵 표

| API 엔드포인트 | 요청 주기 | 한 요청당 DB 쿼리 수 | 쓰기/읽기 | 쿼리 대상 테이블 | RLS 적용 여부 | 비고 |
|---|---|---|---|---|---|---|
| **POST /api/webinars/[webinarId]/access/track** | 입장 시 1회, 이후 5분마다 | **3~7회** | R: 2~4, W: 1~3 | `webinars`, `registrations`, `profiles`, `webinar_live_presence`, `webinar_user_sessions` | ❌ (Admin Supabase 사용) | 게스트: 3회, 로그인 사용자(등록 있음): 4회, 로그인 사용자(등록 없음): 7회 |
| **POST /api/webinars/[webinarId]/presence/ping** | **120초 ± 10초** | **4~10회** | R: 2~5, W: 1~2, RPC: 1~3 | `webinars`, `registrations`, `profiles`, `webinar_live_presence` (RPC), `webinar_user_sessions` (RPC) | ✅ (일부), ❌ (Admin 일부) | 등록 있고 session_id 없음: 4회, 등록 없고 session_id 있음: 10회 |
| **POST /api/webinars/[webinarId]/register** | 입장 시 1회 (자동 등록) | **4회** | R: 2, W: 1~2 | `webinars`, `registrations` | ❌ (Admin Supabase 사용) | 중복 등록 시 UPDATE 1회 |
| **GET /api/webinars/[webinarId]/stats/access** | 관리자 모드: **5초마다** | **6~8회** | R: 6~8 | `webinars`, `webinar_live_presence`, `profiles`, `registrations`, `webinar_access_logs` | ❌ (Admin Supabase 사용) | 관리자만 호출 |
| **중복 로그인 체크** | **5초마다** | **0회** | - | - | - | Realtime Presence 사용 (DB 쿼리 없음) |

---

## 상세 분석

### 1. POST /api/webinars/[webinarId]/access/track

**요청 주기**: 입장 시 1회, 이후 5분마다 갱신

**DB 쿼리 상세**:

| 순서 | 쿼리 | 테이블 | 읽기/쓰기 | 조건 | RLS |
|---|---|---|---|---|---|
| 1 | `auth.getUser()` | `auth.users` | R | 인증 확인 | ✅ |
| 2 | `SELECT id, client_id, agency_id` | `webinars` | R | `id = webinarId` | ❌ (Admin) |
| 3 | `SELECT id` | `registrations` | R | `webinar_id = X AND user_id = Y` | ❌ (Admin) |
| 4 | `SELECT email` | `profiles` | R | `id = user.id` | ❌ (Admin) |
| 5 | `INSERT` | `registrations` | W | 등록 없을 때만 | ❌ (Admin) |
| 6 | `UPSERT` | `webinar_live_presence` | W | 로그인 사용자만 | ❌ (Admin) |
| 7 | `UPSERT` | `webinar_user_sessions` | W | 모든 사용자 | ❌ (Admin) |

**시나리오별 쿼리 수**:
- **게스트**: 3회 (쿼리 1, 2, 7)
- **로그인 사용자 (등록 있음)**: 4회 (쿼리 1, 2, 3, 6, 7)
- **로그인 사용자 (등록 없음)**: 7회 (쿼리 1~7 모두)

**파일**: `app/api/webinars/[webinarId]/access/track/route.ts`

---

### 2. POST /api/webinars/[webinarId]/presence/ping

**요청 주기**: **120초 (2분) ± 10초 지터**

**DB 쿼리 상세**:

| 순서 | 쿼리 | 테이블 | 읽기/쓰기 | 조건 | RLS |
|---|---|---|---|---|---|
| 1 | `auth.getUser()` | `auth.users` | R | 인증 확인 | ✅ |
| 2 | `getWebinarIdFromIdOrSlug()` | `webinars` | R | slug → UUID 변환 | ❌ (Admin) |
| 3 | `SELECT id` | `registrations` | R | `webinar_id = X AND user_id = Y` | ❌ (Admin) |
| 4 | `SELECT agency_id, client_id` | `webinars` | R | 등록 없을 때만 | ❌ (Admin) |
| 5 | `SELECT email` | `profiles` | R | 등록 없을 때만 | ❌ (Admin) |
| 6 | `INSERT` | `registrations` | W | 등록 없을 때만 | ❌ (Admin) |
| 7 | `SELECT id` | `registrations` | R | 중복 등록 체크 시 | ❌ (Admin) |
| 8 | `webinar_presence_ping()` RPC | `webinar_live_presence` | W | INSERT/UPDATE (60초 throttle) | ✅ (SECURITY INVOKER) |
| 9 | `check_heartbeat_throttle()` RPC | `webinar_user_sessions` | R | session_id 있을 때만 | ❌ (SECURITY DEFINER) |
| 10 | `update_session_heartbeat()` RPC | `webinar_user_sessions` | W | session_id 있을 때만 | ❌ (SECURITY DEFINER) |

**시나리오별 쿼리 수**:
- **등록 있고 session_id 없음**: 4회 (쿼리 1, 2, 3, 8)
- **등록 있고 session_id 있음**: 6회 (쿼리 1, 2, 3, 8, 9, 10)
- **등록 없고 session_id 없음**: 7회 (쿼리 1~8)
- **등록 없고 session_id 있음**: 10회 (쿼리 1~10)

**파일**: `app/api/webinars/[webinarId]/presence/ping/route.ts`

**특징**:
- 클라이언트 측 60초 throttle (중복 호출 방지)
- 서버 측 60초 throttle (`webinar_presence_ping` RPC의 WHERE 조건)
- Heartbeat throttle: 60초 최소 간격 (`check_heartbeat_throttle` RPC)

---

### 3. POST /api/webinars/[webinarId]/register

**요청 주기**: 입장 시 1회 (자동 등록)

**DB 쿼리 상세**:

| 순서 | 쿼리 | 테이블 | 읽기/쓰기 | 조건 | RLS |
|---|---|---|---|---|---|
| 1 | `requireAuth()` | `auth.users` | R | 인증 확인 | ✅ |
| 2 | `getWebinarIdFromIdOrSlug()` | `webinars` | R | slug → UUID 변환 | ❌ (Admin) |
| 3 | `SELECT webinar_id, user_id, nickname` | `registrations` | R | `webinar_id = X AND user_id = Y` | ❌ (Admin) |
| 4 | `UPDATE/INSERT` | `registrations` | W | 중복이면 UPDATE, 없으면 INSERT | ❌ (Admin) |

**총 쿼리 수**: 4회

**파일**: `app/api/webinars/[webinarId]/register/route.ts`

---

### 4. GET /api/webinars/[webinarId]/stats/access

**요청 주기**: 관리자 모드에서 **5초마다** (현재 접속자 목록 갱신)

**DB 쿼리 상세**:

| 순서 | 쿼리 | 테이블 | 읽기/쓰기 | 조건 | RLS |
|---|---|---|---|---|---|
| 1 | `checkWebinarStatsPermission()` | `webinars`, `client_members`, `agency_members`, `profiles` | R | 권한 확인 (여러 쿼리) | ❌ (Admin) |
| 2 | `SELECT start_time, webinar_start_time, end_time` | `webinars` | R | `id = webinarId` | ❌ (Admin) |
| 3 | `SELECT user_id, last_seen_at, joined_at` | `webinar_live_presence` | R | `webinar_id = X AND last_seen_at >= now() - 3분` | ❌ (Admin) |
| 4 | `SELECT user_id` | `webinar_live_presence` | R | `webinar_id = X AND joined_at IS NOT NULL` | ❌ (Admin) |
| 5 | `SELECT id, display_name, email, nickname` | `profiles` | R | `id IN (userIds)` | ❌ (Admin) |
| 6 | `SELECT user_id, nickname, role` | `registrations` | R | `webinar_id = X AND user_id IN (userIds)` | ❌ (Admin) |
| 7 | `SELECT *` | `webinar_access_logs` | R | `webinar_id = X AND time_bucket >= from AND time_bucket < to` | ❌ (Admin) |

**총 쿼리 수**: 6~8회 (권한 확인 쿼리 수에 따라 변동)

**파일**: `app/api/webinars/[webinarId]/stats/access/route.ts`

**특징**:
- 관리자 모드에서만 호출
- 현재 접속자 목록 실시간 갱신용

---

### 5. 중복 로그인 체크

**요청 주기**: **5초마다** (클라이언트 사이드)

**DB 쿼리**: **0회** (Realtime Presence 사용)

**구현 방식**:
- Supabase Realtime Presence 채널 사용
- 클라이언트 사이드에서 `presenceState()`로 다른 세션 감지
- DB 쿼리 없이 메모리에서 처리

**파일**: `app/(webinar)/webinar/[id]/components/WebinarView.tsx` (라인 365~530)

**코드**:
```typescript
// 세션 관리 채널 생성 (presence 사용)
const channel = supabase.channel(`session:webinar-${webinar.id}`, {
  config: {
    presence: { key: 'user' },
    broadcast: { self: false },
  },
})

// 주기적으로 체크 (5초마다)
checkInterval = setInterval(() => {
  if (isActive) {
    checkForDuplicateSessions(user.id, sessionKey, channel)
  }
}, 5000)

// 중복 세션 체크 함수 (DB 쿼리 없음)
const checkForDuplicateSessions = (userId: string, currentSessionKey: string, ch: any) => {
  const presenceState = ch.presenceState() // 메모리에서 조회
  const allPresences = Object.values(presenceState).flat() as any[]
  // 같은 user_id의 다른 세션 찾기
  const otherSessions = allPresences.filter((presence: any) => {
    return presence.userId === userId && presence.sessionKey !== currentSessionKey
  })
  // ...
}
```

**특징**:
- ✅ **DB 쿼리 없음**: Realtime Presence State만 사용
- ✅ **5초마다 체크**: 클라이언트 사이드에서만 실행
- ✅ **관리자 제외**: 관리자 모드는 중복 로그인 방지 제외

---

## 트래픽 증폭 계산 예시

### 시나리오: 100명 동시 접속 (모두 로그인 사용자, 등록 있음)

**1분당 요청 수**:

| API | 주기 | 1분당 요청 수 (100명 기준) | 1분당 DB 쿼리 수 |
|---|---|---|---|
| `/access/track` | 입장 시 1회, 이후 5분마다 | 100회 (입장) + 20회 (갱신) = 120회 | 120 × 4 = **480회** |
| `/presence/ping` | 120초 ± 10초 | 100명 × 0.5회/분 = **50회** | 50 × 4 = **200회** |
| `/register` | 입장 시 1회 | 100회 (입장) | 100 × 4 = **400회** |
| `/stats/access` | 관리자 5초마다 | 1명 × 12회/분 = **12회** | 12 × 7 = **84회** |
| 중복 로그인 체크 | 5초마다 | 100명 × 12회/분 = **1,200회** | **0회** (Realtime) |

**총 1분당 DB 쿼리 수**: 약 **1,164회**

**시간당 DB 쿼리 수**: 약 **69,840회**

---

### 시나리오: 1,000명 동시 접속 (모두 로그인 사용자, 등록 있음)

**1분당 요청 수**:

| API | 주기 | 1분당 요청 수 (1,000명 기준) | 1분당 DB 쿼리 수 |
|---|---|---|---|
| `/access/track` | 입장 시 1회, 이후 5분마다 | 1,000회 (입장) + 200회 (갱신) = 1,200회 | 1,200 × 4 = **4,800회** |
| `/presence/ping` | 120초 ± 10초 | 1,000명 × 0.5회/분 = **500회** | 500 × 4 = **2,000회** |
| `/register` | 입장 시 1회 | 1,000회 (입장) | 1,000 × 4 = **4,000회** |
| `/stats/access` | 관리자 5초마다 | 1명 × 12회/분 = **12회** | 12 × 7 = **84회** |
| 중복 로그인 체크 | 5초마다 | 1,000명 × 12회/분 = **12,000회** | **0회** (Realtime) |

**총 1분당 DB 쿼리 수**: 약 **10,884회**

**시간당 DB 쿼리 수**: 약 **653,040회**

---

## 최적화 포인트

### 1. Presence Ping 최적화

**현재 상태**: 120초 ± 10초 주기 (이미 최적화됨)

**추가 최적화 가능**:
- [ ] 등록 확인 결과 캐싱 (짧은 TTL, 예: 60초)
- [ ] 자동 등록 로직 최적화 (중복 체크 제거)

### 2. Access Track 최적화

**현재 상태**: 5분마다 갱신 (이미 최적화됨)

**추가 최적화 가능**:
- [ ] 등록 확인 결과 캐싱
- [ ] 웨비나 정보 캐싱

### 3. 통계 API 최적화

**현재 상태**: 관리자 모드에서만 호출 (5초마다)

**추가 최적화 가능**:
- [ ] 클라이언트 사이드 캐싱 (SWR, 5초 TTL)
- [ ] 서버 사이드 캐싱 (짧은 TTL, 예: 3초)

### 4. 중복 로그인 체크

**현재 상태**: ✅ **이미 최적화됨** (DB 쿼리 없음, Realtime Presence만 사용)

---

## 확인 포인트 답변

### Q1: heartbeat/presence가 몇 초 주기인지

**답변**: 
- **Presence ping**: **120초 (2분) ± 10초 지터**
- **Heartbeat 업데이트**: Presence ping과 동일한 주기 (session_id가 있을 때만)
- **Heartbeat throttle**: 최소 60초 간격 (서버 측)

**파일**: `components/webinar/hooks/usePresencePing.ts` (라인 81~94)

### Q2: "중복 로그인 체크"가 ping마다 도는지/입장 시 1회인지

**답변**: 
- **중복 로그인 체크**: **5초마다** 실행 (ping과 독립적)
- **DB 쿼리**: **0회** (Realtime Presence State만 사용)
- **입장 시 1회**: ❌ (5초마다 계속 체크)

**파일**: `app/(webinar)/webinar/[id]/components/WebinarView.tsx` (라인 452~457)

**구현 방식**:
- Realtime Presence 채널 구독
- `presenceState()`로 메모리에서 다른 세션 감지
- DB 쿼리 없이 클라이언트 사이드에서만 처리

---

## 결론

1. **Presence ping**: 120초 주기로 이미 최적화됨
2. **중복 로그인 체크**: DB 쿼리 없이 Realtime Presence만 사용 (최적화됨)
3. **가장 많은 쿼리 발생**: `/access/track` (입장 시), `/presence/ping` (지속적)
4. **관리자 통계 API**: 5초마다 호출되지만 관리자만 사용하므로 영향 제한적

**권장 사항**:
- 현재 구조는 이미 잘 최적화되어 있음
- 추가 최적화는 캐싱 도입으로 가능 (등록 확인, 웨비나 정보 등)

---

**분석 완료일**: 2026-02-07  
**분석자**: AI Assistant (Composer)
