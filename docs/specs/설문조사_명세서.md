아래 구성으로 **충분히 “현장 설문 + 경품(캡슐뽑기) 운영”이 돌아갑니다.**
다만 “현장 혼잡/중복 체크/사후 입력(종이기록)”까지 고려해서, **몇 가지 화면/데이터 상태를 명확히 나누면 운영이 더 안정적**이에요.

그래서 네가 적어준 1~4 구성을 기본으로 하되, 제가 **전체 명세서(v1)** 형태로 완성해서 정리할게요.
(기술 스택/권한/실시간 패턴은 기존 EventLive 구조를 그대로 전제로 작성)  

---

# 현장 설문/경품(캡슐뽑기) 모듈 명세서 v1

## 1) 목표와 범위

### 목표

* **클라이언트(회사)별, 행사(캠페인)별**로 현장 설문을 만들고 운영
* 설문 완료자에게 **완료번호(1부터 순차)**를 부여해 **현장 종이 기록(캡슐 종이 뒷면)**에 적을 수 있게 함
* 스탭은 **완료 화면 확인 + QR(또는 코드) 스캔**으로 **설문 완료 여부 확인** 및 **중복 수령 가능성 경고**를 받음
* 경품 종류는 현장에서 바로 입력하지 않아도 되며, **종이 기록을 모아 사후에 일괄 입력**할 수 있음
* 관리자 대시보드에서 **실시간 현황(완료 수/스캔 수 등)** 모니터링

### 비범위(이번 v1에서 제외 가능)

* SMS 인증(휴대폰 실명 인증)
* 경품 재고/로트 단위 출고 관리
* 카메라 기반 QR 스캔(USB 리더기 입력 방식 권장)

---

## 2) 용어 정의

* **캠페인(Campaign)**: 특정 행사/부스에서 운영하는 “현장 설문 이벤트” 1개 단위
* **엔트리(Entry)**: 참여자 1명(전화번호 기준 1회 참여) 기록
* **완료번호(survey_no)**: 설문 완료 순서대로 1부터 부여되는 현장용 번호(종이에 적는 번호)
* **확인 스캔(verified)**: 스탭이 QR(또는 코드)을 찍어 **“이 사람 완료자 맞음”**을 확인한 행위 기록
  → 이게 누적되면 “이미 수령했을 확률이 높음” 경고에 사용
* **경품 기록(prize 기록)**: 종이로 모아둔 “완료번호 + 경품명”을 사후 입력하여 DB에 기록

---

## 3) 사용자/권한

기존 권한 모델 그대로 사용 

### 참여자(공개)

* 로그인 없이 접근
* 설문 제출 / 참여 확인(전화번호) 가능

### 스탭(현장 운영)

* 로그인 필요(최소 `client operator`)
* QR/코드 스캔 → 완료 여부 조회
* 스캔 기록(verified) 남김
* (선택) 경품 기록 즉시 입력

### 관리자(클라이언트 관리자)

* 캠페인 생성/편집/발행
* 템플릿 관리
* 통계 대시보드/리포트/CSV
* 사후 경품 일괄 입력

권한 체크는 기존 Guard + Admin Supabase 패턴 유지 

---

## 4) 화면 구성(IA) / 네가 제안한 1~4에 맞춘 최종 구조

### 공개(참여자) 3페이지 + 보조 1기능

1. **웰컴/시작 페이지(Participant Start Page)**

   * 참여 안내(“참여하면 경품”)
   * 버튼 2개:

     * `설문 참여하기`
     * `참여 확인하기(전화번호로)`
   * (운영용 옵션) “디스플레이 모드”로 QR/URL을 크게 띄우는 화면 제공

2. **설문 참여 페이지(Survey Page)**

   * 기본 필드: 이름/회사/전화번호(필수)
   * 추가 문항: 기존 설문 시스템 기반(템플릿/빌더 제공)

3. **설문 완료 페이지(Completion Page)**

   * “설문 완료되었습니다”
   * **완료번호(survey_no) 크게 표시**
   * **6자리 확인코드 + QR 표시**

     * 6자리 확인코드는 `survey_no`를 `000001`처럼 패딩해도 됨(운영 단순화)

(보조) **참여 확인 플로우**

* 시작 페이지에서 “참여 확인” → 전화번호 입력

  * 완료자면 완료 페이지 재노출
  * 미참여면 설문 참여 페이지로 이동

---

### 관리자/스탭 2대시보드 + 사후입력

4. **관리자 통계 대시보드(Admin Dashboard)**

   * 실시간: 완료수, 스캔수(verified), 미스캔 잔여 등
   * 기간 필터, CSV 다운로드, 참여 리스트 검색

5. **현장 대시보드(On-site Staff Dashboard)**

   * QR/코드 입력(USB 리더기 입력을 전제로, input에 focus 고정)
   * 스캔 시 뜨는 **추가 창(모달/패널)**:

     * “설문 완료자입니다 ✅”
     * **현재 완료번호 N번(= 참여자 숫자 카운트로 사용)**
     * 이미 스캔된 사람이라면: “이미 HH:MM에 스캔됨 → 수령했는지 확인하세요”
   * (선택) 경품 입력창(현장에서 바로 입력할 때)
   * (필수) “verified(스캔 기록)” 저장

6. **경품 사후 입력(Bulk Prize Entry)**

   * 종이 뒷면에 적힌 “완료번호(survey_no)”를 기준으로

     * `survey_no + 경품명(또는 5종 중 선택)`을 여러 건 빠르게 입력
   * CSV 업로드/다운로드 지원(선택)

---

## 5) URL/라우팅 정책(프리픽스 없이)

요구대로 “별도 프리픽스 없이” 행사별 경로를 그대로 쓸 수 있게 설계합니다.
Next.js App Router의 catch-all 라우트로 처리(기존 구조와 호환) 

### 공개 URL 예시

* 시작 페이지: `https://{host}/{public_path}`
* 설문 페이지: `https://{host}/{public_path}/survey`
* 완료 페이지: `https://{host}/{public_path}/done`
* 디스플레이(인쇄/모니터)용: `https://{host}/{public_path}/display`

> DB에는 `public_path`를 “캠페인 베이스 경로”로 저장하고, 뒤의 `/survey`, `/done`, `/display`는 런타임에서 라우팅으로 처리.

---

## 6) 데이터 모델(기존 설문 시스템 기반 + 캠페인/엔트리 확장)

기존에 이미 설문/퀴즈 통합 시스템(forms, submissions 등)이 구축되어 있으니 ,
**“캠페인(행사)”만 추가하고, 문항/응답은 기존 forms를 재사용**하는 방향으로 갑니다.

### 6.1 새 테이블: `event_survey_campaigns`

캠페인(행사) 단위 설정

* `id` uuid PK
* `agency_id`, `client_id`
* `title`
* `host` (도메인 식별용, 또는 domain_id FK)
* `public_path` (예: `/2025/triz/triz_1211_booth`)
* `status` (`draft|published|closed`)
* `form_id` uuid (기존 `forms.id` 연결)
* `welcome_schema` jsonb (웰컴/시작 페이지 템플릿 데이터)
* `completion_schema` jsonb (완료 페이지 템플릿 데이터)
* `display_schema` jsonb (디스플레이 페이지 템플릿 데이터)
* `next_survey_no` int default 1  ✅ 완료번호 발급용

유니크:

* `unique(host, public_path)` 또는 `unique(domain_id, public_path)`
* `unique(client_id, public_path)`(도메인 단위 분리 방식에 따라 선택)

### 6.2 새 테이블: `event_survey_entries`

참여자(전화번호 1회 참여) + 완료번호 + 스캔 기록 + 경품 기록

* `id` uuid PK
* `campaign_id` uuid FK
* `agency_id`, `client_id`
* `name` text
* `company` text
* `phone_norm` text (숫자만)
* `survey_no` int not null ✅ 완료 순번(1부터)
* `code6` text not null ✅ 예: `LPAD(survey_no::text,6,'0')`
* `completed_at` timestamptz not null
* `verified_at` timestamptz null ✅ 스탭 스캔 기록(“받았을 확률 높음” 판단)
* `verified_by` uuid null
* `prize_label` text null ✅ 사후 입력(“우산”, “방향제” 등)
* `prize_recorded_at` timestamptz null
* `prize_recorded_by` uuid null
* (선택) `form_submission_id` uuid (기존 form_submissions 연결)

제약/인덱스:

* `unique(campaign_id, phone_norm)` (중복 참여 방지)
* `unique(campaign_id, survey_no)`
* `unique(campaign_id, code6)`
* index: `(campaign_id, completed_at)`, `(campaign_id, verified_at)`

### 6.3 기존 forms 시스템 재사용(핵심)

* 문항 정의: `forms`, `form_questions`
* 응답 저장: `form_submissions`, `form_answers`
* 단, “웨비나 전용”으로 강하게 묶여있다면, forms에 `campaign_id` 연결을 추가하거나(추천), 별도 링크 테이블을 둡니다. 

---

## 7) 번호(survey_no) 발급 규칙(완료 순서대로 1부터)

**발급 시점 = 설문 제출이 성공해서 completed로 기록되는 순간**

서버 API에서 트랜잭션(또는 원자적 UPDATE)로 처리:

1. `event_survey_campaigns.next_survey_no`를 `+1` 업데이트하고, 그 직전 값을 `survey_no`로 확보
2. `event_survey_entries` insert (survey_no, code6, completed_at 포함)

이렇게 하면 동시 제출에서도 **중복 없이 1부터 순차**로 보장됩니다.

---

## 8) QR/코드 정책(현장 운영 최적)

### QR payload 추천

* QR 안에는 **code6**만 넣어도 충분

  * USB 리더기 스캔 시 input에 그대로 들어오고 Enter로 조회 가능
* 보안이 더 필요하면(복제 방지):

  * `code6 + 서명 토큰` 형태로 확장 가능(추후)

### 완료 화면 표시(참여자에게 보여줄 것)

* “완료번호: 128” (큰 숫자)
* “확인코드: 000128”
* QR(= 000128)

**현장 종이 운영**과 **스캔 운영**이 같은 숫자로 맞춰져서 실수가 확 줄어요.

---

## 9) API 명세(최소 세트)

> 모든 DB 쓰기는 Route Handler에서 처리(서비스 롤/권한 체크 포함). 

### 9.1 공개 API

1. 캠페인 resolve

* `GET /api/public/event-survey/resolve?path=<request_path>`
* 반환: 캠페인 정보, 페이지 schema(웰컴/설문/완료), form_id 등

2. 설문 제출

* `POST /api/public/event-survey/{campaignId}/submit`
* body: `{ name, company, phone, answers }`
* 동작:

  * phone 정규화
  * 이미 `campaign_id+phone_norm` 존재하면 **멱등 응답(기존 완료 정보 반환)**
  * 없으면: survey_no 발급 → entry 생성 → form_submission 생성/answers 저장 → 완료 정보 반환
* 반환: `{ survey_no, code6 }`

3. 참여 확인(전화번호 lookup)

* `POST /api/public/event-survey/{campaignId}/lookup`
* body: `{ phone }`
* 반환:

  * 완료자: `{ completed:true, survey_no, code6, verified:boolean, prize_label? }`
  * 미참여: `{ completed:false }`

---

### 9.2 스탭/관리자 API(인증 필요)

4. 스캔 조회(+자동 verified 처리 옵션)

* `POST /api/event-survey/{campaignId}/scan`
* body: `{ code6 }`
* 반환: `{ found, completed, survey_no, name, company, verified_at, prize_label }`
* **옵션 정책**

  * `verified_at`이 NULL이면 스캔 시점에 자동으로 `verified_at=now()` 저장(권장)
  * 이미 verified면 “이미 스캔됨” 메시지용 데이터 반환

5. 경품 사후 입력(단건)

* `POST /api/event-survey/{campaignId}/prize`
* body: `{ survey_no, prize_label }`
* 동작: survey_no로 entry 찾아서 prize_label 업데이트

6. 경품 일괄 입력(복수)

* `POST /api/event-survey/{campaignId}/prizes/bulk`
* body: `{ rows: [{ survey_no, prize_label }, ...] }`
* 성공/실패(없는 번호) 리포트 반환

7. 통계

* `GET /api/event-survey/{campaignId}/stats`
* 반환:

  * `total_completed`
  * `total_verified`
  * `total_prize_recorded`
  * `hourly_completed[]`, `hourly_verified[]` 등

---

## 10) 실시간(Realtime) 설계: Broadcast 추천

대시보드/현장 화면은 “집계값/상태 변화”가 중요하므로
DB Changes 대신 **Broadcast(가벼운 이벤트 신호)**를 쓰는 구조로 갑니다. (기존 시스템이 이미 broadcast 중심으로 안정화된 이력이 있음) 

### 채널

* `eventSurvey:${campaignId}`

### 이벤트 타입

* `entry:completed` (설문 완료)
* `entry:verified` (스캔됨)
* `entry:prize_recorded` (경품 입력됨)

### 페이로드 최소화(권장)

* `{ type: 'entry:verified', campaignId, survey_no }`
* 받은 쪽(대시보드)은 `stats API` 재조회 또는 로컬 카운트 +1

---

## 11) 템플릿/빌더(기존 설문 시스템 기반 확장)

### 11.1 설문 폼 템플릿

* 기존 `FormManagement`(설문 생성/문항 편집 UI)을 **캠페인에서도 그대로 재사용** 
* “템플릿에서 생성” 지원:

  * 시스템 기본 템플릿(만족도/리드수집/부스참여 등)
  * 에이전시/클라이언트 전용 템플릿(커서로 만든 걸 저장)
* 템플릿 저장 형태:

  * `forms.is_template = true` + `template_scope(system|agency|client)` 같은 방식(구현 선택)

### 11.2 페이지 템플릿(웰컴/완료/디스플레이)

* 최소 v1은 “텍스트/이미지/버튼/QR 블록” 정도의 간단 빌더로 충분
* 캠페인 생성 시:

  * “페이지 템플릿 선택” → 문구/로고만 교체 → 발행

---

## 12) 통계 대시보드(관리자) 요구사항

### 핵심 KPI(실시간)

* 총 완료 수 (= 마지막 survey_no와 동일)
* 스캔 수(verified_at not null)
* 미스캔 잔여(완료 - 스캔)
* 경품 기록 수(prize_recorded_at not null)

### 조회/필터

* survey_no 검색
* 전화번호 검색(권한 있는 관리자만 전체 조회)
* 상태 필터: (완료/스캔/경품기록)

### 내보내기

* CSV: 참여자 기본정보 + survey_no + verified_at + prize_label

---

## 13) 현장 대시보드(스탭) UX 요구사항

### 스캔 입력 방식

* USB QR 리더기(키보드 입력 방식) 전제
* 입력창 `autoFocus` + Enter로 즉시 조회
* 조회 성공 시 “추가 창(모달)” 표시

### 스캔 결과 모달(요구 그대로)

* 제목: “설문 완료자입니다 ✅”
* **참여자 번호(=survey_no)** 크게
* verified_at:

  * 없음 → “첫 확인(스캔)”
  * 있음 → “이미 HH:MM에 스캔됨 → 수령 여부 확인하세요”
* (선택) 참가자 표시(이름/회사만, 전화번호는 마스킹)

### 현장 혼잡 대응

* 모달 닫으면 입력창 자동 포커스 복귀
* “없음/미완료” 케이스는 빨간 경고로 즉시 안내

---

## 14) 개인정보/보안

* 공개 참여는 로그인 없이 가능하므로:

  * **서버 API에서만 DB write**(서비스 롤 사용 + 입력 검증) 
  * phone 정규화/유효성 체크
  * 동일 번호 재제출은 “기존 완료 화면 반환”으로 멱등 처리
* 스탭/관리자 화면은 기존 RBAC로 제한 
* (권장) 공개 lookup(참여확인)은 **전화번호만**으로도 되지만, 민감하면 “전화번호+이름” 2요소로 강화 가능

---

## 15) 구현 우선순위(Phase)

### Phase 1 (MVP 운영 가능)

* 캠페인 생성/발행
* 공개 3페이지(시작/설문/완료) + 참여확인(전화번호)
* 완료번호(survey_no) 발급
* 스탭 스캔 화면 + verified 기록 + 중복 경고
* 관리자 KPI 대시보드(완료/스캔)

### Phase 2 (운영 고도화)

* 페이지 템플릿 라이브러리
* 설문 폼 템플릿 라이브러리
* 경품 사후 입력(일괄 입력 UI + CSV)
* 상세 리포트(시간대별 차트 등, 기존 리포트 패턴 확장) 

---

# 결론

네가 제안한 구조(웰컴/설문/완료 + 관리자/현장 대시보드)는 **맞고**,
여기에 “현장 운영에 꼭 필요한” **완료번호(survey_no) + 스캔 기록(verified) + 사후 경품 입력**을 명시적으로 넣으면 **현장 혼잡/중복/사후정산까지 한 번에 커버**됩니다.

---

원하면 다음 답변에서 바로 **개발 착수용 산출물**로 내려줄게요:

1. DB 마이그레이션 SQL 초안(테이블/인덱스/제약)
2. API Route 목록과 request/response 예시(JSON)
3. 화면별 와이어(필드/버튼/상태 분기)
4. Broadcast 이벤트 타입/페이로드 정의

(너희 Next.js + Supabase 패턴에 맞춰 그대로 커밋 가능한 형태로 작성) 
