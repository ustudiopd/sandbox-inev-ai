# 중복 로그인 방지 기능 설계 현황

**작성일**: 2026-02-08  
**구현 위치**: `app/(webinar)/webinar/[id]/components/WebinarView.tsx`

---

## 1. 개요

- **목적**: 동일 사용자(동일 계정)가 **여러 탭 또는 여러 기기**에서 동시에 웨비나 라이브에 접속하는 것을 막지 않지만, **한쪽 세션에 “다른 곳에서 로그인했다”는 알림을 보내고 그 세션을 입장 페이지로 내보냄**으로써, 실질적으로 **한 세션만 유지**되도록 함.
- **적용 대상**: **참가자(participant)만**. 관리자(`isAdminMode`)는 **중복 로그인 방지 로직에서 제외**됨.
- **수단**: **Supabase Realtime**의 **Presence**(세션별 상태) + **Broadcast**(session_conflict 이벤트). **DB 쿼리 없음**, 채널 기반만 사용.

---

## 2. 동작 요약

| 항목 | 내용 |
|------|------|
| **감지** | 같은 웨비나 라이브 채널 안에서, **같은 user_id**로 **서로 다른 sessionKey**를 가진 Presence가 2개 이상 있으면 “중복 세션”으로 간주 |
| **처리** | 한쪽 세션이 **다른 세션(들)**에게 `session_conflict` 브로드캐스트 전송 → **이벤트를 수신한 쪽**이 “다른 기기/브라우저에서 로그인했다”는 alert 후 **입장 페이지**(`/webinar/{slug 또는 id}`)로 이동 |
| **결과** | 동일 사용자당 **동시에 라이브에 머무를 수 있는 세션은 1개**가 되도록 유도 (어느 쪽이 남을지는 타이밍에 따라 선착순) |

---

## 3. 상세 설계

### 3.1 채널 및 식별자

- **채널 이름**: `session:webinar-${webinar.id}` (웨비나별 1채널)
- **Presence 설정**: `presence: { key: 'user' }` → 동일 사용자도 **탭/기기마다 다른 presence 항목**으로 들어갈 수 있음
- **세션 키(sessionKey)**  
  - 각 탭(또는 라이브 컴포넌트 마운트)당 **1회 생성**:  
    `session_${Date.now()}_${random}`  
  - `sessionKeyRef.current`에 보관되어, **해당 탭의 고유 세션 ID**로 사용

### 3.2 Presence 등록

- 채널 **SUBSCRIBED** 후 `channel.track({ userId, sessionKey, timestamp })` 호출
- 따라서 **같은 userId**라도 **다른 탭/기기**는 **서로 다른 sessionKey**로 Presence에 등록됨

### 3.3 중복 세션 감지 시점

1. **Presence sync** 이벤트 시  
   → `checkForDuplicateSessions(userId, currentSessionKey, channel)` 호출  
2. **Presence join** 이벤트 시  
   → 500ms 뒤 `checkForDuplicateSessions` 호출 (presence 상태 반영 대기)  
3. **구독 직후**  
   → 1초 뒤 초기 1회 `checkForDuplicateSessions` 호출  
4. **주기 폴링**  
   → **5초마다** `checkForDuplicateSessions` 호출 (`setInterval(..., 5000)`)

(문서/장애 보고서 등에 “중복 로그인 체크 5초마다”라고 된 것은 위 4번 주기 체크를 말함.)

### 3.4 checkForDuplicateSessions 로직

1. `ch.presenceState()` 로 채널 내 **전체 Presence** 수집
2. **같은 userId**이면서 **자기 sessionKey가 아닌** 항목만 필터 → **“다른 세션” 목록**
3. 그중 **아직 session_conflict 알림을 보내지 않은 세션**만 필터 (`notifiedSessionsRef`)
4. 해당하는 **다른 세션** 각각에 대해:
   - 채널로 **broadcast** 전송:  
     `event: 'session_conflict'`,  
     `payload: { userId, newSessionKey: 현재탭의 sessionKey, oldSessionKey: 상대 sessionKey, timestamp }`
   - 상대 `sessionKey`를 `notifiedSessionsRef`에 넣어 **중복 알림 방지**

즉, **자기 자신은 “새 세션”이라고 가정**하고, **다른 세션(들)**에게 “너희가 구 세션이니 나가라”는 의미로 `session_conflict`를 보냄.

### 3.5 session_conflict 수신 시 (다른 탭/기기 쪽)

- 리스너: `channel.on('broadcast', { event: 'session_conflict' }, ...)`
- 수신 payload에서 `userId`, `newSessionKey` 사용
- 조건: **수신한 쪽의 user_id와 동일**이고, **수신한 newSessionKey가 “내 sessionKey”가 아님**  
  → 즉, **내가 “구 세션”으로 알림 받은 것**으로 판단
- 동작:
  1. `alert('다른 기기 또는 브라우저에서 로그인하여 이 세션이 종료됩니다.')`
  2. `window.location.href = '/webinar/${webinar.slug || webinar.id}'`  
     → **입장 페이지로 이동** (라이브에서 퇴장)

정리하면, **session_conflict를 “받은” 쪽이 항상 퇴장**하고, **보낸 쪽은 그대로 라이브에 머무는** 구조다.  
(동시에 서로에게 보낼 수 있어서, 실제로는 “먼저 수신·리다이렉트한 쪽”이 나가고, 한 세션만 남게 됨.)

### 3.6 관리자 제외

- `isAdminMode === true` 이면 해당 useEffect 전체를 **실행하지 않음** (early return)
- 따라서 **관리자**는 같은 계정으로 여러 탭/기기를 써도 **session_conflict 알림을 받지 않고**, 중복 로그인 방지 대상이 아님

---

## 4. 데이터/인프라

- **DB**: 사용하지 않음. 세션·중복 여부는 **Realtime 채널 Presence 상태**만으로 판단.
- **API**: 중복 감지·알림에 **전용 REST API 없음**.  
  - 참가자 → Realtime `channel.send({ type: 'broadcast', event: 'session_conflict', payload })` 로 직접 전송.
- **트래픽**:  
  - Presence: join/leave/sync, 그리고 **5초마다** `presenceState()` 조회(서버로 가는 추가 요청은 아님, 클라이언트 상태 조회).  
  - Broadcast: 중복 발견 시에만 `session_conflict` 전송.

(과거 장애/최적화 문서에서 “Presence 이벤트 수가 많다”고 한 것은, 동시 접속자 수 × (sync/join + 5초마다 트랙 갱신 등) 영향이다.)

---

## 5. 제한·참고 사항

1. **“어느 쪽이 남을지”**  
   - “가장 최근 로그인한 세션만 남는다”가 아니라, **먼저 `session_conflict`를 “받아서” 리다이렉트하는 쪽이 나가고**, 그렇지 않은 쪽이 남는 구조.  
   - 따라서 **거의 동시에 두 탭이 열리면** 어느 쪽이 남을지는 타이밍에 따라 달라질 수 있음.

2. **Realtime Broadcast 권한**  
   - 참가자(일반 사용자)도 `session_conflict`를 **클라이언트에서 직접** `channel.send(...)` 로 보냄.  
   - Supabase에서 **Realtime Broadcast에 대한 권한을 강화**할 경우(예: 참가자는 send 불가), **session_conflict만 서버 API 경유**로 보내도록 바꿔야 할 수 있음.  
   - (관련: `docs/Realtime_Broadcast_권한_점검.md`, 마이그레이션 104 등)

3. **동일 탭 내 여러 iframe/컴포넌트**  
   - 같은 페이지(같은 sessionKey)면 Presence도 하나로 보이므로, “중복”으로 잡히지 않음.  
   - 진짜 **다른 탭/다른 기기**만 별도 sessionKey로 잡힘.

---

## 6. 요약 표

| 항목 | 내용 |
|------|------|
| **목적** | 동일 사용자의 동시 라이브 세션을 1개로 유도 |
| **대상** | 참가자만 (관리자 제외) |
| **수단** | Supabase Realtime Presence + Broadcast(session_conflict) |
| **세션 식별** | 탭/기기별 sessionKey (페이지 진입 시 1회 생성) |
| **감지** | Presence에서 동일 userId, 서로 다른 sessionKey 존재 여부 |
| **감지 주기** | sync/join 이벤트 + 구독 후 1초 + **5초마다** 폴링 |
| **처리** | “다른 세션”에게 session_conflict 브로드캐스트 → 수신한 쪽이 alert 후 입장 페이지로 이동 |
| **DB 사용** | 없음 (채널 상태만 사용) |

---

**문서 버전**: 1.0  
**최종 업데이트**: 2026-02-08
