# 이벤트라이브 통계 기능 전체 명세서 v2 (옵션2: 1분 크론 + 5분 버킷)

> 목적: **실시간 웨비나 경험을 방해하지 않는 수준(최적화 최우선)**으로 기능별 통계(채팅/Q&A/폼/추첨/파일/등록/접속)를 제공한다.
>
> 핵심 결정사항
> - ✅ **접속 통계는 서버 크론 기반**으로 수집한다.
> - ✅ 크론은 **1분마다 실행**하지만, 저장은 **5분 버킷(멱등 Upsert)**으로 누적한다. (옵션2)
> - ✅ 라이브 참가자 화면에서는 **집계 쿼리 금지**, **가벼운 ping(upsert 1행)**만 수행한다.
> - ❌ 히트맵은 **검토 의견만 남기고 구현 보류**한다.

---

## 0. 용어/지표 정의 (헷갈리기 쉬운 것 고정)

- **등록자 수(totalRegistrants)**: `registrations` 기준(고유 user_id)
- **최대 동시 접속자(maxConcurrentParticipants)**: 접속 스냅샷 로그에서 **최대값**
- **평균 동시 접속자(avgConcurrentParticipants)**: 접속 스냅샷 로그에서 **(sum_participants / sample_count)** 기반 평균
- **고유 참석자(uniqueAttendees)**: “특정 기간 내 last_seen 기록이 있는 고유 user_id”로 정의 가능하나, 본 v2에서는 **선택/추후(Phase 2+)**

> 주의: “실제 접속자 수”라는 라벨은 오해 소지가 크므로, UI/응답에는 **최대 동시 접속자**라는 용어를 사용한다.

---

## 1. 범위

### 1.1 포함
- 웨비나별 통계
  - 채팅(messages)
  - Q&A(questions)
  - 폼/퀴즈(forms, form_questions, form_submissions, form_answers, quiz_attempts)
  - 추첨(giveaways, giveaway_entries, giveaway_winners)
  - 파일(webinar_files + 다운로드 로그)
  - 등록자(registrations)
  - 접속(서버 크론 집계)
- 관리자/운영자용 통계 UI(/webinar/[id]/stats)
- CSV 내보내기(선택: 기존 export 패턴 재사용)

### 1.2 제외(이번 범위에서 구현하지 않음)
- 히트맵(클릭 좌표)
- AI 보고서
- 참여자별 상세 세션(체류시간/이탈) — 필요 시 Phase 3에서 `webinar_user_sessions` 추가

---

## 2. 아키텍처 (실시간 방해 최소)

### 2.1 데이터 흐름

1) **참가자 페이지(라이브)**
- 2분(권장)마다 `/api/webinars/:id/presence/ping` 호출
- 서버는 `webinar_live_presence`에 **(webinar_id, user_id) upsert 1행**만 수행

2) **서버 크론(1분마다)**
- 활성 기준(cutoff = now - 3분)으로 `webinar_live_presence` 집계
- 웨비나별 현재 접속자수(count)를 계산
- `webinar_access_logs`에 **5분 버킷으로 누적(upsert+증분)**

3) **통계 UI(관리자)**
- Stats API 호출은 탭 클릭 시 로드(지연 로딩)
- 자동 refresh는 60초~300초 이상(기본 5분 권장)

### 2.2 최적화 원칙
- 라이브 참가자 화면:
  - ✅ 단일 upsert(ping)만
  - ❌ 통계 집계 쿼리, generate_series, 대형 조인 금지
- 통계 API:
  - ✅ 관리자 화면에서만 사용
  - ✅ 범위(from/to) + interval로 데이터량 제한
  - ✅ 병렬 쿼리(Promise.all)

---

## 3. 데이터베이스 설계

### 3.1 신규 테이블 1: webinar_live_presence (가벼운 heartbeat)

**목적**: 서버 크론이 “현재 접속자 수”를 DB에서 계산할 수 있게 만드는 최소 데이터.

```sql
create table if not exists public.webinar_live_presence (
  webinar_id uuid not null references public.webinars(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,

  joined_at timestamptz not null default now(),
  last_seen_at timestamptz not null default now(),

  -- org fields (프로젝트 표준)
  agency_id uuid,
  client_id uuid,

  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),

  primary key (webinar_id, user_id)
);

-- 조회/집계 성능
create index if not exists idx_wlp_webinar_last_seen
  on public.webinar_live_presence (webinar_id, last_seen_at desc);
create index if not exists idx_wlp_last_seen
  on public.webinar_live_presence (last_seen_at desc);
```

**권장 TTL/활성 기준**
- 클라이언트 ping: 120초(±10초 지터)
- 활성 사용자 판정: `last_seen_at >= now() - interval '3 minutes'`

> 3분은 2분 ping + 네트워크 지연/백그라운드/탭 전환을 고려한 여유값.

---

### 3.2 신규/확장 테이블 2: webinar_access_logs (5분 버킷 누적)

**목적**: “최대/평균 동시 접속자” 및 시간대별 추이를 **저비용**으로 제공.

> 옵션2 요구사항: 크론은 1분마다 실행하지만, 저장은 5분 버킷으로 **멱등 upsert**하며 통계(평균/최대/최소)를 누적한다.

```sql
create table if not exists public.webinar_access_logs (
  id uuid primary key default gen_random_uuid(),

  webinar_id uuid not null references public.webinars(id) on delete cascade,

  -- 5분 버킷 시작 시각(UTC 권장)
  time_bucket timestamptz not null,

  -- 버킷 내 샘플 누적 (크론이 1분마다 찍으면 sample_count는 최대 5)
  sample_count int not null default 0,
  sum_participants int not null default 0,
  min_participants int not null default 0,
  max_participants int not null default 0,
  last_participants int not null default 0,

  first_sample_at timestamptz not null default now(),
  last_sample_at timestamptz not null default now(),

  -- org fields (표준)
  agency_id uuid,
  client_id uuid,

  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create unique index if not exists uq_wal_webinar_bucket
  on public.webinar_access_logs (webinar_id, time_bucket);

create index if not exists idx_wal_webinar_bucket_desc
  on public.webinar_access_logs (webinar_id, time_bucket desc);
```

**버킷 평균(5분 단위)**
- `avg_participants = sum_participants::float / nullif(sample_count, 0)`

---

### 3.3 신규 테이블 3: webinar_downloads (다운로드 로그)

```sql
create table if not exists public.webinar_downloads (
  id uuid primary key default gen_random_uuid(),

  webinar_id uuid not null references public.webinars(id) on delete cascade,
  file_id uuid not null references public.webinar_files(id) on delete cascade,
  user_id uuid references auth.users(id) on delete set null,

  downloaded_at timestamptz not null default now(),

  -- org fields
  agency_id uuid,
  client_id uuid,

  created_at timestamptz not null default now()
);

create index if not exists idx_wd_webinar_downloaded
  on public.webinar_downloads (webinar_id, downloaded_at desc);

create index if not exists idx_wd_file_downloaded
  on public.webinar_downloads (file_id, downloaded_at desc);

create index if not exists idx_wd_user_downloaded
  on public.webinar_downloads (user_id, downloaded_at desc);
```

**로그 기록 시점(권장)**
- “다운로드 버튼 클릭 → 서버가 signed URL 발급” API에서 insert
  - 실제 파일 바이트 전송을 100% 보장하진 않지만, 운영 통계 목적에는 충분

---

## 4. 공통 SQL 유틸 함수 (버킷 계산 오류 방지)

기존 명세의 `DATE_TRUNC('minute', ts) / 5 * 5` 형태는 Postgres에서 동작/의도가 불명확하므로, **epoch 기반 버킷 함수**를 표준으로 사용한다.

```sql
create or replace function public.bucket_time(_ts timestamptz, _bucket_seconds int)
returns timestamptz
language sql
immutable
as $$
  select to_timestamp(floor(extract(epoch from _ts) / _bucket_seconds) * _bucket_seconds);
$$;
```

- 5분 버킷: `bucket_time(created_at, 300)`
- 15분 버킷: `bucket_time(created_at, 900)`
- 1시간 버킷: `bucket_time(created_at, 3600)`

---

## 5. 크론 집계(옵션2)용 RPC 함수

### 5.1 활성 웨비나별 접속자 수 집계

```sql
create or replace function public.get_active_webinar_participant_counts(_active_since timestamptz)
returns table (webinar_id uuid, participant_count int)
language sql
security definer
as $$
  select webinar_id, count(*)::int as participant_count
  from public.webinar_live_presence
  where last_seen_at >= _active_since
  group by webinar_id;
$$;
```

### 5.2 5분 버킷 누적 기록(배치)

```sql
create or replace function public.record_webinar_access_snapshot_batch(
  _snapshots jsonb,
  _sampled_at timestamptz default now()
)
returns int
language plpgsql
security definer
as $$
declare
  bucket timestamptz;
  affected int;
begin
  bucket := public.bucket_time(_sampled_at, 300);

  with rows as (
    select
      (s->>'webinar_id')::uuid as webinar_id,
      (s->>'participant_count')::int as participant_count
    from jsonb_array_elements(_snapshots) as s
  ),
  ins as (
    insert into public.webinar_access_logs (
      webinar_id,
      time_bucket,
      sample_count,
      sum_participants,
      min_participants,
      max_participants,
      last_participants,
      first_sample_at,
      last_sample_at
    )
    select
      webinar_id,
      bucket,
      1,
      participant_count,
      participant_count,
      participant_count,
      participant_count,
      _sampled_at,
      _sampled_at
    from rows
    on conflict (webinar_id, time_bucket) do update
      set sample_count     = public.webinar_access_logs.sample_count + 1,
          sum_participants = public.webinar_access_logs.sum_participants + excluded.sum_participants,
          min_participants = least(public.webinar_access_logs.min_participants, excluded.last_participants),
          max_participants = greatest(public.webinar_access_logs.max_participants, excluded.last_participants),
          last_participants = excluded.last_participants,
          last_sample_at    = excluded.last_sample_at,
          updated_at        = now()
    returning 1
  )
  select count(*) into affected from ins;

  return affected;
end;
$$;
```

> **수정 사항 (검토 반영)**:
> - `sum_participants` 누적 시 `excluded.sum_participants` 사용 (insert 시점의 `participant_count` 값)
> - `excluded`는 INSERT 시도된 값들을 참조하므로, `excluded.sum_participants`가 올바른 새 샘플 값을 포함함
> - 이렇게 하면 서브쿼리 없이 간단하고 정확하게 누적 가능
> 
> 참고: `security definer` 함수는 **서비스 롤(서버)**에서만 호출하도록 API를 잠근다.

---

## 6. RLS 정책(최소)

### 6.1 webinar_live_presence
- **INSERT/UPDATE**: 본인(user_id=auth.uid())만, 그리고 등록(registrations) 존재 시 허용
- **SELECT**: 관리자(클라이언트/에이전시 멤버)만 허용(또는 전면 금지 후 서버만)

권장 정책 예시:

```sql
alter table public.webinar_live_presence enable row level security;

-- 본인 upsert 허용(등록자)
create policy "wlp_upsert_self_if_registered"
on public.webinar_live_presence
for insert
with check (
  user_id = auth.uid()
  and exists (
    select 1 from public.registrations r
    where r.webinar_id = webinar_live_presence.webinar_id
      and r.user_id = auth.uid()
  )
);

create policy "wlp_update_self_if_registered"
on public.webinar_live_presence
for update
using (user_id = auth.uid())
with check (
  user_id = auth.uid()
  and exists (
    select 1 from public.registrations r
    where r.webinar_id = webinar_live_presence.webinar_id
      and r.user_id = auth.uid()
  )
);

-- 관리자 조회는 서버 Route Handler에서 Admin Supabase를 사용하므로 클라이언트 직접 조회는 금지 권장
-- 필요 시 프로젝트 권한 모델에 맞춰 별도 정책 추가 가능하나, 보안상 서버 전용이 더 안전
```

**보안 권장사항**:
- 클라이언트에서 `webinar_live_presence` 직접 조회는 **금지** 권장
- 통계 조회는 모두 서버 Route Handler를 통해 Admin Supabase로 처리
- RPC 함수(`get_active_webinar_participant_counts`)는 `security definer`로 RLS 우회

### 6.2 webinar_access_logs / webinar_downloads
- 통계 조회는 보통 서버 Route Handler에서 **Admin Supabase + 앱 권한 체크** 패턴을 사용하므로,
  - RLS는 “조직 멤버만 select 허용” 정도로 최소화하거나
  - 아예 서버에서만 접근하도록 정책을 더 강하게 두어도 된다.

---

## 7. 클라이언트 구현: Presence Ping (라이브 방해 최소)

### 7.1 엔드포인트
`POST /api/webinars/[webinarId]/presence/ping`

- 인증 필수
- Body 없음(권장) 또는 `{ ts?: number }`
- 응답: 204

### 7.2 동작 규칙(권장)
- ping interval: **120초**
- jitter: **±10초** (동시 폭주 방지)
- 탭이 hidden이면 중지
- unload/pagehide에서 마지막 1회 전송(가능하면 sendBeacon)

### 7.3 서버 구현(최소 DB 작업)
- (webinar_id, user_id) primary key 기준 upsert
- 업데이트 컬럼은 `last_seen_at`만(필요하면 `updated_at`)

---

## 8. 서버 구현: 크론(1분) 스냅샷

### 8.1 Vercel Cron
- 스케줄: `*/1 * * * *` (매 1분)
- 호출 URL: `/api/cron/webinar-access-snapshot?secret=...` 또는 헤더 기반

### 8.2 크론 Route Handler 요구사항
- **CRON_SECRET** 검증(필수)
- Supabase Admin 클라이언트 사용
- 로직:
  1) cutoff = now - 3분
  2) `rpc(get_active_webinar_participant_counts)` 호출
  3) 결과를 jsonb array로 `rpc(record_webinar_access_snapshot_batch)` 호출
  4) 성공 시 204
- 실패 시:
  - 500 반환(크론 모니터링용)
  - 단, 웨비나 UX에는 영향 없음
- **에러 처리 및 모니터링 (검토 반영)**:
  - 크론 실패 시 로깅 필수 (예: Sentry, Logtail, Vercel Logs)
  - 부분 실패 처리: 일부 웨비나만 실패해도 나머지는 정상 처리
  - 재시도 로직: 일시적 DB 오류 시 최대 2회 재시도 (지수 백오프)
  - 알림: 연속 3회 실패 시 관리자 알림 (선택)

### 8.3 성능 포인트
- 크론 1회당:
  - DB read 1번(RPC)
  - DB write 1번(RPC)
  - 활성 웨비나 수가 적으면 비용 매우 낮음

---

## 9. 통계 API 설계

### 9.1 공통 규칙
- 모든 stats API는 **관리자/운영자 전용**
- 권한(추천):
  - Super Admin
  - Agency: owner/admin/analyst
  - Client: owner/admin/operator/analyst/viewer
- DB 접근 패턴: `createAdminSupabase()` + 앱 레벨 권한 체크
- 공통 query param:
  - `from` (ISO)
  - `to` (ISO)
  - `interval` = `5m | 15m | 1h`
  - 기본값: `interval=5m`, `from/to`는 웨비나 시작~종료(없으면 최근 24h)

### 9.2 엔드포인트

- 통합:
  - `GET /api/webinars/[webinarId]/stats?sections=chat,qa,forms,...&from=&to=&interval=`

- 개별:
  - `GET /api/webinars/[webinarId]/stats/chat`
  - `GET /api/webinars/[webinarId]/stats/qa`
  - `GET /api/webinars/[webinarId]/stats/forms`
  - `GET /api/webinars/[webinarId]/stats/giveaways`
  - `GET /api/webinars/[webinarId]/stats/files`
  - `GET /api/webinars/[webinarId]/stats/registrants`
  - `GET /api/webinars/[webinarId]/stats/access`
  - `GET /api/webinars/[webinarId]/stats/timeline` (Phase 3)

---

## 10. 섹션별 집계 로직 (SQL 표준안)

> 아래 SQL은 **버킷 함수(bucket_time)**와 **COUNT 대상(PK) 명확화**를 반영한 “정확한 집계” 버전이다.

### 10.1 채팅 통계 (messages)

**기본**
```sql
select
  count(*) as total_messages,
  count(distinct user_id) as unique_senders
from public.messages
where webinar_id = $1 and hidden = false
  and created_at >= $2 and created_at < $3;
```

**타임라인**
```sql
select
  public.bucket_time(created_at, $4) as time_slot,
  count(*) as message_count,
  count(distinct user_id) as sender_count
from public.messages
where webinar_id = $1 and hidden = false
  and created_at >= $2 and created_at < $3
group by time_slot
order by time_slot;
```

**Top senders (닉네임 우선순위: registrations.nickname → profiles.nickname)**
```sql
select
  m.user_id,
  coalesce(r.nickname, p.nickname, '익명') as nickname,
  count(*) as message_count
from public.messages m
left join public.registrations r
  on r.webinar_id = m.webinar_id and r.user_id = m.user_id
left join public.profiles p
  on p.id = m.user_id
where m.webinar_id = $1 and m.hidden = false
  and m.created_at >= $2 and m.created_at < $3
group by m.user_id, nickname
order by message_count desc
limit 10;
```

---

### 10.2 Q&A 통계 (questions)

**기본(답변 여부는 answered_at 기준)**
```sql
select
  count(*) as total_questions,
  count(*) filter (where answered_at is not null) as answered_questions,
  count(distinct user_id) as unique_questioners
from public.questions
where webinar_id = $1 and status != 'hidden'
  and created_at >= $2 and created_at < $3;
```

**답변 시간(분)**
```sql
select
  avg(extract(epoch from (answered_at - created_at))/60) as avg_minutes,
  min(extract(epoch from (answered_at - created_at))/60) as min_minutes,
  max(extract(epoch from (answered_at - created_at))/60) as max_minutes
from public.questions
where webinar_id = $1
  and answered_at is not null
  and created_at >= $2 and created_at < $3;
```

**타임라인(질문/답변 수)**
```sql
select
  public.bucket_time(created_at, $4) as time_slot,
  count(*) as question_count,
  count(*) filter (where answered_at is not null) as answered_count
from public.questions
where webinar_id = $1 and status != 'hidden'
  and created_at >= $2 and created_at < $3
group by time_slot
order by time_slot;
```

---

### 10.3 폼/퀴즈 통계

#### 10.3.1 웨비나 레벨 요약

```sql
select
  count(*) filter (where kind = 'survey') as total_surveys,
  count(*) filter (where kind = 'quiz') as total_quizzes
from public.forms
where webinar_id = $1;
```

**설문 제출**
```sql
select
  count(*) as total_submissions,
  count(distinct fs.participant_id) as unique_respondents
from public.form_submissions fs
join public.forms f on f.id = fs.form_id
where f.webinar_id = $1 and f.kind = 'survey'
  and fs.submitted_at >= $2 and fs.submitted_at < $3;
```

**퀴즈 시도**
```sql
select
  count(*) as total_attempts,
  count(distinct qa.participant_id) as unique_participants,
  avg(qa.total_score) as avg_score,
  max(qa.total_score) as max_score,
  min(qa.total_score) as min_score
from public.quiz_attempts qa
join public.forms f on f.id = qa.form_id
where f.webinar_id = $1 and f.kind = 'quiz'
  and qa.submitted_at >= $2 and qa.submitted_at < $3;
```

#### 10.3.2 폼별 상세

**퀴즈 문항 정답률(LEFT JOIN + COUNT(fa.id)로 정확도 확보)**
```sql
select
  fq.id as question_id,
  fq.body as question_body,
  count(fa.id) as total_attempts,
  count(fa.id) filter (where fa.answer_value = fq.answer_key) as correct_count,
  (count(fa.id) filter (where fa.answer_value = fq.answer_key))::float / nullif(count(fa.id),0) * 100 as correct_rate
from public.form_questions fq
join public.forms f on f.id = fq.form_id
left join public.form_answers fa on fa.question_id = fq.id
left join public.form_submissions fs on fs.id = fa.submission_id
where f.id = $1 and f.kind = 'quiz'
  and (fs.submitted_at is null or (fs.submitted_at >= $2 and fs.submitted_at < $3))
group by fq.id, fq.body, fq.answer_key;
```

**설문 선택지 분포(COUNT(fa.id) 사용)**
```sql
select
  fq.id as question_id,
  fq.body as question_body,
  option->>'id' as option_id,
  option->>'text' as option_text,
  count(fa.id) as response_count
from public.form_questions fq
join public.forms f on f.id = fq.form_id
cross join lateral jsonb_array_elements(fq.options) as option
left join public.form_answers fa
  on fa.question_id = fq.id
 and fa.answer_value::jsonb @> jsonb_build_array(option->>'id')
left join public.form_submissions fs
  on fs.id = fa.submission_id
where f.id = $1 and f.kind = 'survey'
  and fq.type in ('single','multiple')
  and (fs.submitted_at is null or (fs.submitted_at >= $2 and fs.submitted_at < $3))
group by fq.id, fq.body, option->>'id', option->>'text'
order by fq.id, response_count desc;
```

---

### 10.4 추첨 통계

**기본**
```sql
select
  count(*) as total_giveaways,
  count(*) filter (where status = 'drawn') as drawn_giveaways
from public.giveaways
where webinar_id = $1;
```

**참여/당첨 요약**
```sql
select
  count(*) as total_entries,
  count(distinct ge.participant_id) as unique_participants
from public.giveaway_entries ge
join public.giveaways g on g.id = ge.giveaway_id
where g.webinar_id = $1
  and ge.created_at >= $2 and ge.created_at < $3;
```

**타임라인**
```sql
select
  public.bucket_time(ge.created_at, $4) as time_slot,
  count(*) as entry_count,
  count(distinct ge.participant_id) as participant_count
from public.giveaway_entries ge
join public.giveaways g on g.id = ge.giveaway_id
where g.webinar_id = $1
  and ge.created_at >= $2 and ge.created_at < $3
group by time_slot
order by time_slot;
```

---

### 10.5 파일 통계

**기본 파일 수**
```sql
select count(*) as total_files
from public.webinar_files
where webinar_id = $1;
```

**다운로드 요약**
```sql
select
  count(*) as total_downloads,
  count(distinct user_id) as unique_downloaders
from public.webinar_downloads
where webinar_id = $1
  and downloaded_at >= $2 and downloaded_at < $3;
```

**파일별 다운로드**
```sql
select
  wf.id as file_id,
  wf.file_name,
  wf.file_size,
  count(wd.id) as download_count
from public.webinar_files wf
left join public.webinar_downloads wd
  on wd.file_id = wf.id
 and wd.downloaded_at >= $2 and wd.downloaded_at < $3
where wf.webinar_id = $1
group by wf.id, wf.file_name, wf.file_size
order by download_count desc;
```

---

### 10.6 등록자 통계 (registrations)

**기본**
```sql
select
  count(distinct user_id) as total_registrants
from public.registrations
where webinar_id = $1;
```

**등록 출처**
```sql
select
  coalesce(registered_via, 'unknown') as source,
  count(*) as count
from public.registrations
where webinar_id = $1
group by registered_via;
```

**최대 동시 접속자(접속 로그 기반)**
```sql
select coalesce(max(max_participants), 0) as max_concurrent_participants
from public.webinar_access_logs
where webinar_id = $1;
```

---

### 10.7 접속 통계 (webinar_access_logs)

**전체 최대/평균 동시접속**
```sql
select
  coalesce(max(max_participants), 0) as max_concurrent_participants,
  coalesce(sum(sum_participants)::float / nullif(sum(sample_count),0), 0) as avg_concurrent_participants
from public.webinar_access_logs
where webinar_id = $1
  and time_bucket >= $2 and time_bucket < $3;
```

**타임라인(5분 버킷 그대로 사용)**
```sql
select
  time_bucket as time,
  (sum_participants::float / nullif(sample_count,0)) as avg_participants,
  max_participants,
  min_participants,
  last_participants
from public.webinar_access_logs
where webinar_id = $1
  and time_bucket >= $2 and time_bucket < $3
order by time_bucket;
```

---

## 11. API 응답 타입(요약)

> 기존 타입을 유지하되, 접속 관련 필드는 v2 테이블 구조에 맞춰 명확히 한다.

- ChatStats
- QAStats
- FormStats
- GiveawayStats
- FileStats
- RegistrantStats
- AccessStats

특히 AccessStats 권장:

```ts
interface AccessStats {
  maxConcurrentParticipants: number
  avgConcurrentParticipants: number
  timeline: Array<{
    time: string
    avgParticipants: number
    maxParticipants: number
    minParticipants: number
    lastParticipants: number
  }>
  peakTime: { time: string; participantCount: number } | null
}
```

---

## 12. UI/프론트 구현 가이드(성능 우선)

- `/webinar/[id]/stats`
  - 상단: 핵심 KPI 카드(등록자/최대동시/평균동시/채팅참여율 등)
  - 탭: chat / qa / forms / giveaways / files / registrants / access
- 데이터 로딩:
  - 탭 클릭 시 fetch
  - 기본 refresh 없음(또는 5분)
  - “새로고침” 버튼 제공

---

## 13. 구현 순서(커서 에이전트 작업 체크리스트)

### Phase A (필수: 수집 인프라)
1) DB 마이그레이션
   - `webinar_live_presence`, `webinar_access_logs`, `webinar_downloads`
   - `bucket_time` 함수
   - RPC 2개(`get_active_webinar_participant_counts`, `record_webinar_access_snapshot_batch`)
   - 필요한 인덱스
2) Presence ping API + 클라이언트 훅
3) 크론 Route Handler + Vercel Cron 설정(*/1)

### Phase B (필수: 통계 API)
4) chat/qa/forms/giveaways/files/registrants/access API를 “정확한 SQL”로 구현
5) 통합 stats API(sections) 구현 + Promise.all 병렬

### Phase C (UI)
6) stats 페이지 탭별 UI 연결(지연로딩)

### Phase D (보류)
- 히트맵/AI 리포트

---

## 14. 히트맵(검토 의견만)

- 클릭 좌표 수집은 이벤트량이 급증할 수 있어, 라이브 웨비나에서는 **성능/프라이버시 리스크**가 있다.
- 이식 시스템의 “배치 큐 + Fire-and-forget” 패턴은 유효하나,
  - 이번 v2에서는 **도입하지 않는다**.
- 향후 도입 시:
  - 관리자 화면에서만 샘플링
  - 모바일/데스크톱 분리
  - 이벤트 샘플링(예: 10%)


---

## 15. 공통 API 계약/권한/검증/캐싱 (커서 구현 기준)

### 15.1 공통 응답 포맷
- 성공: `{ success: true, data: ... }`
- 실패: `{ success: false, error: string }`

> 기존 프로젝트의 API 스타일과 일치시키는 것이 목표.

### 15.2 공통 권한 체크(권장)
- 모든 `/api/webinars/[webinarId]/stats/*`는 아래 중 하나면 허용
  - super admin
  - agency member: `owner | admin | analyst`
  - client member: `owner | admin | operator | analyst | viewer`

구현 패턴(권장):
1) `requireAuth()`로 user 확보
2) Admin Supabase로 webinar의 `agency_id/client_id`를 가져온 뒤
3) `requireAgencyMember()` 또는 `requireClientMember()`로 역할 체크

**주의사항 (검토 반영)**:
- `requireAgencyMember()`, `requireClientMember()` 함수가 프로젝트에 존재하는지 확인 필요
- 없으면 구현하거나 기존 권한 체크 패턴을 재사용
- Super Admin은 모든 통계 접근 가능

### 15.3 입력 검증
- `webinarId`: uuid/slug 혼용 가능하면, 내부에서 webinar 조회 후 id 정규화
- `from/to`:
  - 기본: `from = now - 24h`, `to = now`
  - `from >= to`면 400
  - 최대 범위 제한 권장: 31일(또는 7일) 이상이면 interval을 강제로 상향(예: 15m/1h)
- `interval`:
  - `5m => 300`, `15m => 900`, `1h => 3600`

### 15.4 캐싱(최적화 우선 원칙)
- **라이브에 영향이 없게** stats 호출은 관리자 UI에서만 발생
- 서버 쪽 추가 캐싱은 “있으면 좋음” 수준으로:
  - UI에서 탭 전환 시 재호출 방지(클라이언트 캐시/SWR)
  - 서버에서는 `Cache-Control: private, max-age=60` 정도만 부여(선택)

> 서버리스 환경에서 메모리 캐시는 인스턴스가 바뀌면 날아가므로, 과도한 캐시 구현은 지양.

---

## 16. Presence Ping 구현(부하 방지 디테일)

### 16.1 권장: 60초 이내 중복 업데이트 억제
클라이언트가 오동작(짧은 간격 ping)해도 DB write를 줄이기 위해, **ON CONFLICT UPDATE에 WHERE 조건**을 걸어 60초 이내에는 update를 생략한다.

> 구현 방법 A(권장): RPC 함수(SECURITY INVOKER)로 단일 SQL 실행

```sql
create or replace function public.webinar_presence_ping(_webinar_id uuid)
returns void
language sql
as $$
  insert into public.webinar_live_presence (webinar_id, user_id, joined_at, last_seen_at)
  values (_webinar_id, auth.uid(), now(), now())
  on conflict (webinar_id, user_id) do update
    set last_seen_at = excluded.last_seen_at,
        updated_at = now()
    where public.webinar_live_presence.last_seen_at < excluded.last_seen_at - interval '60 seconds';
$$;
```

- API `/presence/ping`는 위 RPC만 호출하고 204 반환
- RLS 정책은 기존(등록자만) 유지

**클라이언트 구현 디테일 (검토 반영)**:
- **중복 호출 방지**: 클라이언트 측에서도 마지막 ping 시간을 추적하여 60초 이내 재호출 방지
- **네트워크 오류 처리**: 실패 시 지수 백오프로 재시도 (최대 3회)
- **탭 전환 처리**: 
  - `document.visibilityState === 'hidden'`일 때 ping 중지
  - `visibilitychange` 이벤트로 재개
- **페이지 언로드**: `beforeunload` 또는 `pagehide`에서 마지막 ping 전송
  - 가능하면 `navigator.sendBeacon()` 사용 (브라우저 지원 시)
- **백그라운드 처리**: 모바일 앱 백그라운드 전환 시 ping 중지

### 16.2 데이터 정리(선택)
`webinar_live_presence`는 upsert라 “사용자당 1행”이지만, 웨비나가 많아지면 누적된다.
- 일 1회 크론으로 아래 삭제 권장:
  - `last_seen_at < now() - interval '7 days'`

---

## 17. 추가 통계 SQL(실제 화면에 자주 필요한 항목)

### 17.1 채팅
- **피크 시간대**
```sql
select time_slot, message_count
from (
  select public.bucket_time(created_at, $4) as time_slot,
         count(*) as message_count
  from public.messages
  where webinar_id = $1 and hidden = false
    and created_at >= $2 and created_at < $3
  group by time_slot
) t
order by message_count desc
limit 1;
```

- **채팅 참여율**
```sql
with regs as (
  select count(distinct user_id)::float as total_registrants
  from public.registrations
  where webinar_id = $1
), senders as (
  select count(distinct user_id)::float as chat_senders
  from public.messages
  where webinar_id = $1 and hidden = false
    and created_at >= $2 and created_at < $3
)
select
  coalesce((senders.chat_senders / nullif(regs.total_registrants,0)) * 100, 0) as participation_rate
from regs, senders;
```

### 17.2 Q&A
- **답변 시간 분포**
```sql
select
  case
    when extract(epoch from (answered_at - created_at))/60 <= 5  then '5분 이내'
    when extract(epoch from (answered_at - created_at))/60 <= 10 then '10분 이내'
    when extract(epoch from (answered_at - created_at))/60 <= 30 then '30분 이내'
    when extract(epoch from (answered_at - created_at))/60 <= 60 then '1시간 이내'
    else '1시간 이상'
  end as range,
  count(*) as count
from public.questions
where webinar_id = $1
  and answered_at is not null
  and created_at >= $2 and created_at < $3
group by range
order by min(extract(epoch from (answered_at - created_at)));
```

- **Top questioners**
```sql
select
  q.user_id,
  coalesce(r.nickname, p.nickname, '익명') as nickname,
  count(*) as question_count
from public.questions q
left join public.registrations r
  on r.webinar_id = q.webinar_id and r.user_id = q.user_id
left join public.profiles p
  on p.id = q.user_id
where q.webinar_id = $1 and q.status != 'hidden'
  and q.created_at >= $2 and q.created_at < $3
group by q.user_id, nickname
order by question_count desc
limit 10;
```

### 17.3 접속
- **피크 시간대(버킷 중 max_participants가 최대인 버킷)**
```sql
select time_bucket as time, max_participants
from public.webinar_access_logs
where webinar_id = $1
  and time_bucket >= $2 and time_bucket < $3
order by max_participants desc
limit 1;
```

---

## 18. 성능 인덱스(필수 최소)

> 아래는 “통계 조회”에서 가장 자주 타는 인덱스다. 이미 존재하면 생략.

```sql
-- messages
create index if not exists idx_messages_webinar_created_visible
on public.messages (webinar_id, created_at)
where hidden = false;

create index if not exists idx_messages_webinar_user_visible
on public.messages (webinar_id, user_id)
where hidden = false;

-- questions
create index if not exists idx_questions_webinar_created_visible
on public.questions (webinar_id, created_at)
where status != 'hidden';

create index if not exists idx_questions_webinar_answered
on public.questions (webinar_id, answered_at)
where answered_at is not null;

-- registrations
create index if not exists idx_registrations_webinar_user
on public.registrations (webinar_id, user_id);

-- form_submissions
create index if not exists idx_form_submissions_form_submitted
on public.form_submissions (form_id, submitted_at);

-- giveaway_entries
create index if not exists idx_giveaway_entries_giveaway_created
on public.giveaway_entries (giveaway_id, created_at);
```

---

## 19. 구현 파일/경로 제안(커서 작업 가이드)

### 19.1 API Route Handlers
- `/app/api/webinars/[webinarId]/presence/ping/route.ts`
- `/app/api/cron/webinar-access-snapshot/route.ts`
- `/app/api/webinars/[webinarId]/stats/route.ts`
- `/app/api/webinars/[webinarId]/stats/chat/route.ts`
- `/app/api/webinars/[webinarId]/stats/qa/route.ts`
- `/app/api/webinars/[webinarId]/stats/forms/route.ts`
- `/app/api/webinars/[webinarId]/stats/giveaways/route.ts`
- `/app/api/webinars/[webinarId]/stats/files/route.ts`
- `/app/api/webinars/[webinarId]/stats/registrants/route.ts`
- `/app/api/webinars/[webinarId]/stats/access/route.ts`

### 19.2 클라이언트 훅
- `/components/webinar/hooks/usePresencePing.ts`
  - 라이브 페이지에서만 사용

### 19.3 마이그레이션
- `/supabase/migrations/0xx_create_webinar_stats_v2.sql`
  - 테이블 3개 + 함수 3개 + 인덱스 + RLS

---

## 20. 완료 기준(Definition of Done)

- [ ] 라이브 페이지 접속 시 `webinar_live_presence`가 upsert 된다(2분 주기)
- [ ] 크론이 1분마다 실행되어 `webinar_access_logs`가 5분 버킷으로 누적된다
- [ ] `/stats/access`에서 max/avg/timeline이 정상 표시된다
- [ ] 채팅/Q&A/폼/추첨/파일/등록자 통계 API가 최소 1개 이상 화면에 연결되어 숫자가 일관된다
- [ ] 라이브(참가자)에서 통계 집계 쿼리 실행이 없다

---

## 21. 검토 사항 및 주의사항 (구현 전 확인)

### 21.1 데이터 정합성
- ✅ `record_webinar_access_snapshot_batch` 함수의 `sum_participants` 로직 수정 완료
- ⚠️ 버킷 시간 함수(`bucket_time`)의 타임존 처리 확인 필요
  - 모든 `time_bucket`는 UTC로 저장되는지 확인
  - 클라이언트 표시 시 적절한 타임존 변환 필요

### 21.2 보안
- ✅ RLS 정책 명확화 완료 (클라이언트 직접 조회 금지 권장)
- ⚠️ `requireAgencyMember()`, `requireClientMember()` 함수 존재 여부 확인 필요
- ⚠️ 크론 Route Handler의 `CRON_SECRET` 검증 필수

### 21.3 성능
- ✅ Presence ping 중복 방지 로직 (서버 + 클라이언트 양쪽)
- ⚠️ 대용량 웨비나(수천 명 동시 접속) 시 성능 테스트 필요
- ⚠️ `webinar_access_logs` 파티셔닝 고려 (장기 운영 시)

### 21.4 모니터링 및 운영
- ✅ 크론 실패 시 로깅 및 알림 전략 추가
- ⚠️ 데이터 정리 크론 구현 필요 (`webinar_live_presence` 일 1회 정리)
- ⚠️ 통계 API 응답 시간 모니터링 (목표: 500ms 이내)

### 21.5 테스트 체크리스트
- [ ] Presence ping이 2분 주기로 정상 동작하는지 확인
- [ ] 크론이 1분마다 실행되어 5분 버킷으로 누적되는지 확인
- [ ] `sum_participants`가 정확히 누적되는지 검증 (샘플 데이터로 테스트)
- [ ] 통계 API가 권한 없이 접근 불가능한지 확인
- [ ] 라이브 페이지에서 집계 쿼리가 실행되지 않는지 확인 (DB 로그 확인)

