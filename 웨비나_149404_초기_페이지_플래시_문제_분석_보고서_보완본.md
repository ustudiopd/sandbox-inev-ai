# 웨비나 149404 초기 페이지 플래시 문제 분석 보고서 (보완본)

## 📋 문제 개요

**문제**: `/webinar/149404` 페이지 접속 시 파란색 그라데이션 배경이 있는 초기 페이지가 잠깐 나타났다가 사라지고, 그 후 흰색 배경의 WERT 스타일 페이지가 나타남

**목표**: 초기 페이지 플래시를 제거하고, 처음부터 흰색 배경의 WERT 스타일 페이지가 즉시 표시되도록 함

**영향 페이지**: `http://localhost:3000/webinar/149404`

---

## 🔍 문제 원인 분석 (보완)

### 1. 플래시의 2가지 원인 분리

#### 1.1 배경 오버라이드 타이밍 문제 (확정)
- `globals.css`의 `body` 그라데이션 배경이 초기 페인트에 먼저 적용됨
- 이후 클라이언트 하이드레이션 시점에 WERT 스타일(흰 배경)이 오버라이드됨
- **증상**: 배경색만 변경되는 플래시

#### 1.2 SSR/CSR UI 트리 불일치 가능성 (확인 필요)
- `shouldShowWertStyle` 계산이 클라이언트(`window.location.pathname`)에 의존
- 서버와 클라이언트에서 다른 조건 평가로 인한 렌더링 차이 가능성
- **증상**: 레이아웃 자체가 변경되는 플래시

**확인 방법**:
- Chrome DevTools → Disable cache + Network Slow 3G로 새로고침
- 플래시 순간에 DOM이 "다른 페이지처럼" 바뀌는지 vs 배경만 바뀌는지 관찰
- 콘솔에서 Hydration mismatch 경고 확인

### 2. 스타일 적용 순서 문제

#### 2.1 `globals.css`의 전역 스타일
```css
/* app/globals.css:21-29 */
body {
  color: rgb(var(--foreground-rgb));
  background: linear-gradient(
      to bottom,
      transparent,
      rgb(var(--background-end-rgb))
    )
    rgb(var(--background-start-rgb));
}
```
- **문제**: `body` 태그에 그라데이션 배경이 전역적으로 적용됨
- **영향**: 모든 페이지의 초기 렌더링 시 이 배경이 먼저 표시됨

#### 2.2 Next.js 렌더링 타이밍
- **서버 사이드 렌더링 (SSR)**: HTML이 서버에서 생성될 때 `globals.css`가 먼저 적용됨
- **클라이언트 사이드 하이드레이션**: React가 클라이언트에서 마운트되면서 `styled-jsx` 스타일이 적용됨
- **타이밍 갭**: 이 사이의 짧은 시간 동안 `globals.css`의 그라데이션 배경이 보임

### 3. 조건부 스타일 적용의 한계

#### 3.1 `shouldShowWertStyle` 계산 시점
```typescript
// app/(webinar)/webinar/[id]/components/WebinarEntry.tsx:869-872
const pathname = typeof window !== 'undefined' ? window.location.pathname : ''
const isPath149404 = pathname.includes('/149404')
const shouldShowWertStyle = isPath149404 || String(webinar.slug) === '149404' || ...
```
- **문제**: `window.location.pathname`은 클라이언트 사이드에서만 사용 가능
- **서버 사이드**: `pathname`이 빈 문자열이므로 초기 렌더링 시 조건이 false일 수 있음
- **클라이언트 사이드**: 하이드레이션 후에야 `pathname`이 설정되어 조건이 true가 됨
- **SSR/CSR 불일치**: 서버와 클라이언트에서 다른 UI 트리를 렌더링할 가능성

#### 3.2 `styled-jsx`의 적용 시점
- `styled-jsx`는 컴포넌트가 마운트된 후에 스타일을 주입함
- 초기 HTML에는 `globals.css`의 스타일만 포함되어 있음

### 4. 레이아웃 구조의 영향

#### 4.1 `app/layout.tsx`
```tsx
<body className={`${inter.className} flex flex-col min-h-screen`}>
  <Header />
  <LayoutWrapper>
    <div className="flex-1">
      {children}
    </div>
  </LayoutWrapper>
  <ConditionalFooter />
</body>
```
- `body` 태그에 직접 클래스가 적용되어 있음
- `globals.css`의 `body` 스타일이 우선 적용됨
- **중요**: Next.js App Router에서는 `#__next` 요소가 없음 (Pages Router 전용)

#### 4.2 `LayoutWrapper.tsx`
```tsx
// 공개 웨비나 페이지는 사이드바 없이 렌더링
if (isPublicPage || isPublicWebinarPage || ...) {
  return <>{children}</>
}
```
- 공개 웨비나 페이지는 사이드바 없이 렌더링되지만, `body`의 배경 스타일은 여전히 적용됨
- `LayoutWrapper`는 클라이언트 컴포넌트이므로 SSR 시점에 조건 판단 불가

---

## 🛠️ 시도한 해결 방법

### 방법 1: `shouldShowWertStyle` 조건 강화
**시도 내용**:
- URL 경로에서도 slug 확인 (`isPath149404`)
- 여러 조건을 OR로 연결하여 강화

**결과**: ❌ 실패
- 서버 사이드 렌더링 시 `window` 객체가 없어 `pathname`이 빈 문자열
- 초기 렌더링 시점에 조건이 false로 평가될 수 있음

### 방법 2: 초기 렌더링 시 흰색 배경 강제 적용
**시도 내용**:
```tsx
<style jsx global>{`
  html, body, #__next {
    background-color: #fff !important;
  }
  ${wertStyles}
`}</style>
```

**결과**: ❌ 부분 실패
- `background-color`만으로는 `globals.css`의 `background` 속성을 완전히 덮어쓰지 못함
- `#__next` 셀렉터는 App Router에서 존재하지 않음

### 방법 3: `background` 속성도 명시적으로 설정
**시도 내용**:
```tsx
<style jsx global>{`
  html, body, #__next {
    background-color: #fff !important;
    background: #fff !important;
  }
  ${wertStyles}
`}</style>
```

**결과**: ❌ 여전히 실패
- `styled-jsx`가 적용되기 전에 이미 `globals.css`의 스타일이 렌더링됨

### 방법 4: `@import`를 `<link>` 태그로 분리
**시도 내용**:
- `@import`를 별도의 `<link>` 태그로 분리하여 중첩 오류 해결

**결과**: ✅ 빌드 오류 해결, 하지만 플래시 문제는 지속

---

## 💡 근본 원인 (보완)

### 확정된 원인
1. **CSS 적용 순서**: `globals.css` → 서버 HTML 생성 → 클라이언트 하이드레이션 → `styled-jsx` 적용
2. **타이밍 갭**: 서버에서 생성된 HTML이 브라우저에 전달되고, React가 하이드레이션되기 전까지의 시간 동안 `globals.css`의 스타일이 표시됨
3. **조건부 렌더링의 한계**: 클라이언트 사이드에서만 확인 가능한 값(`window.location.pathname`)에 의존하여 서버 사이드 렌더링 시점에 올바른 스타일을 적용할 수 없음

### 추가 확인 필요 사항
1. **SSR/CSR UI 트리 불일치**: `shouldShowWertStyle`이 false일 때 `null`을 반환하여 서버와 클라이언트에서 다른 렌더링 결과가 나올 가능성
2. **DOM 구조 확인**: Next.js App Router에서는 `#__next` 요소가 없으므로, 실제 루트 컨테이너 구조 확인 필요

---

## 🎯 권장 해결 방안 (우선순위별)

### 1순위: 라우트 세그먼트 레이아웃에서 SSR 즉시 덮는 흰 배경 래퍼 (권장)

#### 핵심 아이디어
- 전역 `body` 그라데이션은 유지하되, 해당 경로(`/webinar/[id]`)에서 SSR로 **흰 배경을 가진 최상단 컨테이너가 항상 렌더**되도록 해서 body를 "가려버리는 방식"
- 서버 사이드에서 slug를 확인하여 조건 판단

#### 구현 방법

**1.1 `app/(webinar)/webinar/[id]/layout.tsx` 생성**
```tsx
export default async function WebinarLayout({
  children,
  params,
}: {
  children: React.ReactNode
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  
  // 서버 사이드에서 slug 확인 (149404 또는 다른 WERT 웨비나)
  const isWertPage = id === '149404'
  
  return (
    <div 
      className={isWertPage ? 'bg-white min-h-screen' : ''}
      style={isWertPage ? { 
        backgroundColor: '#fff', 
        background: '#fff',
        position: 'relative',
        zIndex: 1,
        minHeight: '100vh',
        width: '100%'
      } : {}}
    >
      {children}
    </div>
  )
}
```

**1.2 `app/(webinar)/webinar/[id]/page.tsx`에서 추가 확인**
```typescript
// 서버 사이드에서 slug 확인
const isWertPage = id === '149404' || webinar?.slug === '149404'

// WebinarEntry에 prop으로 전달하여 클라이언트에서도 일치 보장
return <WebinarEntry webinar={webinarData} isWertPage={isWertPage} />
```

**장점**:
- SSR에서 즉시 흰 배경 래퍼가 HTML에 포함되어 전달됨
- 초기 페인트 시점부터 올바른 배경이 표시됨
- 플래시 현상 완전 제거
- 변경 범위가 작고 롤백 쉬움
- 구현 리스크 낮음

**주의사항**:
- 컨테이너가 뷰포트를 완전히 덮지 못하면 잔여 플래시/테두리 노출 가능
- 헤더/푸터/Wrapper 구조에서 "빈 공간"이 생기지 않도록 구조 점검 필수
- `min-height: 100vh` 수준이 아니라, 레이아웃 구조상 배경이 빈 공간을 만들지 않는지 확인 필요

**검증 방법**:
- View-source에서 초기 HTML에 흰 배경 래퍼가 포함되어 있는지 확인
- Elements 탭에서 래퍼가 body를 완전히 덮는지 확인
- Disable cache + Slow 3G 환경에서 강제 새로고침 10회 테스트

---

### 2순위: 배경은 body가 아니라 '페이지 루트 래퍼'가 책임진다 (장기적 해결)

#### 핵심 아이디어
- 전역 `body` 배경 그라데이션을 제거하거나 조건부로 적용
- 페이지별 배경이 필요하면 **body가 아니라, 각 라우트/레이아웃의 최상단 래퍼가 배경을 갖는 구조**로 변경
- WERT 페이지는 SSR에서 바로 흰 배경 래퍼가 찍히고, 그라데이션은 아예 보이지 않음

#### 구현 방법

**2.1 `globals.css` 수정**
```css
/* body 배경을 기본값으로 변경 (또는 제거) */
body {
  color: rgb(var(--foreground-rgb));
  /* background 제거 또는 기본값으로 변경 */
  background: #fff;
}

/* 관리 페이지용 그라데이션 (조건부 적용) */
body[data-theme="admin"] {
  background: linear-gradient(
      to bottom,
      transparent,
      rgb(var(--background-end-rgb))
    )
    rgb(var(--background-start-rgb));
}
```

**2.2 관리 페이지 레이아웃에서 테마 설정**
```tsx
// app/(admin)/layout.tsx 또는 해당 레이아웃
<body data-theme="admin" className={...}>
```

**장점**:
- SSR/CSR 타이밍 갭 리스크 최소
- "특정 웨비나만"이 아니라 앞으로 유사 케이스에도 재사용 가능
- 전역 CSS 충돌을 줄여 장기적으로 유지보수 유리

**주의사항**:
- 기존 페이지들이 "body 배경"에 의존해 디자인이 완성돼 있었다면 영향 범위를 사전 확인해야 함
- 모든 페이지를 점검하여 배경이 필요한 곳에 래퍼 추가 필요

---

### 3순위: head에 white override CSS를 SSR로 주입

#### 핵심 아이디어
- 보고서의 방안 1(서버 사이드에서 스타일 미리 적용) 방향 자체는 맞음
- `<style>`을 **body 내부가 아니라 head에 들어가게** 하는 게 가장 이상적 (초기 페인트 전에 CSSOM에 반영)

#### 구현 방법

**3.1 Next.js Metadata API 활용**
```tsx
// app/(webinar)/webinar/[id]/layout.tsx
export async function generateMetadata({ params }: { params: Promise<{ id: string }> }) {
  const { id } = await params
  const isWertPage = id === '149404'
  
  return {
    other: isWertPage ? {
      'custom-style': `
        html, body {
          background-color: #fff !important;
          background: #fff !important;
        }
      `
    } : {}
  }
}
```

**또는 3.2 `next/head` 또는 `next/script` 활용**
```tsx
// app/(webinar)/webinar/[id]/layout.tsx
import Script from 'next/script'

export default async function WebinarLayout({ children, params }: {...}) {
  const { id } = await params
  const isWertPage = id === '149404'
  
  return (
    <>
      {isWertPage && (
        <Script id="wert-background-override" strategy="beforeInteractive">
          {`
            document.documentElement.style.setProperty('--body-bg', '#fff');
            document.body.style.backgroundColor = '#fff';
            document.body.style.background = '#fff';
          `}
        </Script>
      )}
      {children}
    </>
  )
}
```

**장점**:
- body 배경 자체를 완전히 교체 가능
- 초기 페인트 전에 CSSOM에 반영 가능

**주의사항**:
- 라우트 세그먼트에서 head 삽입 방식은 Next 구성/관례에 따라 구현 디테일이 달라질 수 있음
- "실제로 head에 들어갔는지"를 HTML View-source/Elements로 검증해야 함
- `Script`의 `beforeInteractive`는 제한적으로만 사용 가능

---

## 📊 우선순위별 권장 사항 (수정)

### 즉시 적용 가능 (Quick Win) - 조건 명확화

#### 방안 1-1: 라우트 레이아웃에서 SSR 래퍼 추가 (가장 권장)
**성공 조건**:
- ✅ 그 div가 **첫 SSR HTML에 포함**되어야 함 (클라이언트 조건부 렌더 금지)
- ✅ 그 div가 **뷰포트를 100% 덮어야 함**
  - `min-height: 100vh` 수준이 아니라, 레이아웃 구조상 배경이 빈 공간을 만들지 않는지 확인 필요
  - 헤더/푸터/Wrapper 구조 포함하여 확인
- ✅ "흰 배경이 보이는 범위"가 **body의 그라데이션을 완전히 가리는지** 확인 필요

**구현 예시**:
```tsx
// app/(webinar)/webinar/[id]/layout.tsx
export default async function WebinarLayout({
  children,
  params,
}: {
  children: React.ReactNode
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  const isWertPage = id === '149404'
  
  // SSR에서 항상 렌더 (조건부 렌더 금지)
  return (
    <div 
      className={isWertPage ? 'fixed inset-0 bg-white z-[-1]' : ''}
      style={isWertPage ? {
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: '#fff',
        background: '#fff',
        zIndex: -1,
      } : {}}
    />
    <div className={isWertPage ? 'relative bg-white min-h-screen' : ''}>
      {children}
    </div>
  )
}
```

#### 방안 1-2: `data-webinar-page` 속성 사용 (보완)
**성공 조건**:
- 서버 사이드에서 `data` 속성을 설정해야 함 (클라이언트 `useEffect`는 실패)
- `globals.css`에서 해당 속성에 대한 스타일이 정의되어 있어야 함

**구현 예시**:
```tsx
// app/(webinar)/webinar/[id]/layout.tsx
export default async function WebinarLayout({ children, params }: {...}) {
  const { id } = await params
  const isWertPage = id === '149404'
  
  return (
    <div data-webinar-page={isWertPage ? '149404' : undefined}>
      {children}
    </div>
  )
}
```

```css
/* globals.css */
body[data-webinar-page="149404"],
body:has([data-webinar-page="149404"]) {
  background: #fff !important;
  background-color: #fff !important;
}
```

### 근본적 해결 (Long-term)
1. **방안 2**: 전역 body 배경을 제거하고 페이지별 래퍼가 책임지는 구조 (가장 권장)
2. **방안 3**: head에 SSR로 스타일 주입 (구현 복잡도 높음)

---

## 🔬 추가 디버깅 필요 사항 (보완)

### 1. 플래시 원인 분리 확인
- **Chrome DevTools 설정**:
  - Disable cache 활성화
  - Network 탭 → Slow 3G 설정
  - 강제 새로고침 (Ctrl+Shift+R)
  
- **관찰 사항**:
  - 플래시 순간에 DOM이 "다른 페이지처럼" 바뀌는지 (레이아웃 자체 변환)
  - vs 배경만 바뀌는지 (스타일 오버라이드만)
  
- **콘솔 확인**:
  - React hydration mismatch 경고 확인
  - 서버와 클라이언트의 렌더링 결과 비교

### 2. 서버 사이드 렌더링 로그 확인
- `webinar.slug` 값이 서버에서 올바르게 전달되는지 확인
- `shouldShowWertStyle` 계산 로직에 로그 추가
- 서버 사이드에서 `isWertPage` 판단이 올바른지 확인

### 3. 브라우저 개발자 도구 확인
- **Network 탭**: 초기 HTML 확인 (View-source)
- **Elements 탭**: 
  - 실제 DOM 구조 확인 (`#__next` 존재 여부)
  - 스타일 적용 순서 확인
  - 루트 컨테이너가 무엇인지 확인
- **Performance 탭**: 렌더링 타이밍 확인

### 4. 하이드레이션 불일치 확인
- React DevTools에서 하이드레이션 경고 확인
- 서버와 클라이언트의 렌더링 결과 비교
- `shouldShowWertStyle`이 서버와 클라이언트에서 동일한 값으로 평가되는지 확인

---

## 📝 결론 (보완)

현재 문제는 **Next.js의 서버 사이드 렌더링과 클라이언트 사이드 하이드레이션 사이의 타이밍 갭**에서 발생합니다. `globals.css`의 전역 스타일이 먼저 적용되고, 이후에 `styled-jsx`로 오버라이드되는 과정에서 플래시가 발생합니다.

**추가로 확인해야 할 사항**:
- 플래시가 "배경만" 변경되는지, 아니면 "페이지 레이아웃 자체가 변경"되는지
- SSR/CSR에서 다른 UI 트리를 렌더링하는지 (hydration mismatch)

**가장 효과적인 해결책**은 **서버 사이드에서 조건을 확인하고, HTML 생성 시점에 올바른 스타일을 포함시키는 것**입니다. 이를 위해:
1. **라우트 레이아웃에서 SSR 래퍼 추가** (1순위, Quick Win)
2. **전역 body 배경을 제거하고 페이지별 래퍼가 책임지는 구조** (2순위, 장기적 해결)

---

## 🎯 Cursor Agent 작업 지침

### 목적
`/webinar/149404`에서 발생하는 **초기 그라데이션 → 흰 배경 전환 플래시를 제거**하고, 첫 페인트부터 WERT(화이트) 스타일이 보이도록 한다.

### 왜 필요한가
- 첫 인상/신뢰도 저하(UX)
- "하이드레이션 이후 스타일 변경"은 네트워크/디바이스 성능에 따라 플래시가 더 커질 수 있어 재현 편차가 큼
- 동일 패턴이 다른 공개 페이지로 확산될 수 있음

### 전제 조건
- 전역 `globals.css`에서 `body`에 그라데이션 배경이 설정되어 있음
- WERT 스타일은 현재 컴포넌트 쪽에서 후행 적용되는 구조(클라이언트 타이밍 의존 가능성)
- `window.location` 기반 조건 분기가 존재(SSR 결정 불가)
- Next.js App Router 사용 (`#__next` 요소 없음)

### 바꾸면 안 되는 것
- 라이브 참가자 UX에 영향 줄 수 있는 무거운 계산/추가 호출 도입 금지
- 다른 페이지의 디자인/테마를 의도치 않게 깨지 않도록 "영향 범위"를 통제
- "특정 숫자 ID 하드코딩"은 최후의 수단(가능하면 구성 가능 구조로)

### 결정 포인트

#### 1. 플래시 원인이
- **(A) 배경 오버라이드 타이밍 문제만**인지
- **(B) SSR/CSR에서 다른 UI 트리 렌더(조건/데이터/`window`)까지 포함**인지
  → DevTools로 확정 후 접근

#### 2. 해결 범위
- **(A) `/webinar/149404`만 긴급 패치**
- **(B) "WERT 테마가 필요한 웨비나들"까지 확장 가능한 구조**
  → 프로젝트 원칙상 (B) 선호(구성 가능)

### 선택 기준
- **초기 페인트 이전에** 흰 배경이 확정되어야 함(클라이언트 마운트 이후 적용 방식은 실패로 간주)
- SSR/CSR **렌더 결과가 동일**해야 함(`window` 기반 분기 제거/대체)
- 변경이 최소 침습이며 롤백이 쉬워야 함

### 구현 가이드 (만족 조건)

#### 조건 1: 배경은 "전역 body"가 아니라 해당 라우트의 SSR 루트 컨테이너가 책임지도록 설계
- 라우트 레이아웃에서 서버 사이드로 조건 확인
- 흰 배경 래퍼를 SSR HTML에 포함
- 클라이언트 조건부 렌더 금지

#### 조건 2: WERT 스타일 여부는 서버에서 결정 가능한 정보로 판정
- 라우트 params (`id`)
- 서버에서 조회된 webinar 데이터 (`webinar.slug`)
- 클라이언트에서 `window`를 근거로 판정하지 않음

#### 조건 3: 라우트에 적용되는 배경/테마는 구성 가능하게 만든다
- 웨비나 데이터에 "테마/레이아웃 변형"을 표현하는 필드/설정이 이미 있다면 그것을 사용
- 없다면 "추가" 여부를 영향 범위/롤백 계획과 함께 제시
- 숫자 ID를 코드에 박는 방식은 지양

#### 조건 4: "덮는 방식(white wrapper)"을 택하면
- SSR에서 항상 렌더 (조건부 렌더 금지)
- 뷰포트 전체를 항상 커버 (`fixed inset-0` 또는 `min-h-screen` + 구조 확인)
- 헤더/푸터/레이아웃 구조에서 빈 공간이 생기지 않음
- `z-index` 조정으로 body 배경을 완전히 가림

### 리스크 체크

#### 디자인 영향 범위
- 다른 공개 페이지에서 body 배경 의존이 있는지 점검
- 헤더/푸터가 body 배경을 보여주는 구조인지 확인

#### 하이드레이션 불일치
- 경고/리렌더가 발생하면 플래시가 재발
- 서버와 클라이언트에서 동일한 조건 평가 보장

#### CSS 우선순위/특이성
- 특정 오버라이드가 Tailwind/기존 클래스와 충돌하지 않는지 확인
- `!important` 사용 시 다른 스타일과의 충돌 확인

#### 회귀
- 다른 웨비나/slug에서도 동일 현상이 생기지 않는지 최소 2~3개 샘플로 확인
- 관리 페이지의 그라데이션 배경이 유지되는지 확인

### 완료 조건(DoD)

- ✅ Disable cache + Slow 3G 환경에서 **강제 새로고침 10회** 기준, `/webinar/149404`에서 파란 그라데이션이 **단 1프레임도 보이지 않는다**
- ✅ React hydration mismatch 경고가 없다
- ✅ 다른 대표 페이지(메인/대시보드/운영콘솔/다른 웨비나) 배경이 기존과 동일하다
- ✅ 수정 사항이 "구성 가능" 구조(최소한 향후 확장/변경 가능)로 남아 있다
- ✅ View-source에서 초기 HTML에 흰 배경 관련 스타일/구조가 포함되어 있음을 확인

---

## 📌 다음 단계

필요하면, 다음 단계로 **"WERT 스타일 판정 로직(SSR/CSR 일치)"** 쪽도 같이 점검해야 합니다. 플래시가 "배경만"이 아니라 "페이지 자체가 다른 레이아웃으로 교체되는 것"이라면, 지금 보고서의 해결책(스타일 선적용)만으로는 100% 해결이 안 될 수 있습니다.

---

**작성일**: 2026-01-25  
**작성자**: AI Assistant  
**검토일**: 2026-01-25  
**관련 파일**:
- `app/(webinar)/webinar/[id]/components/WebinarEntry.tsx`
- `app/(webinar)/webinar/[id]/page.tsx`
- `app/globals.css`
- `app/layout.tsx`
- `components/layout/LayoutWrapper.tsx`
