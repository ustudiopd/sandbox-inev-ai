아래 문서는 **“개인 시청시간 + 입장(재입장) 전체 이력”**을 **현재 EventFlow 구조를 깨지 않으면서**(라이브 화면 경량 ping, 서버/크론 집계 중심) **부하를 최소화**하는 방식으로 도입하기 위한 **Cursor Agent용 최종 명세서**입니다.
(현 시스템의 통계 원칙/크론 구조/Presence Ping 구조를 그대로 확장하는 접근)   

---

# 개인 시청시간 & 세션 트래킹 전체 명세서 (부하 최소화 버전)

## 1) 목적

### 1.1 우리가 얻고 싶은 결과

* **개인별**

  * 총 시청시간(초/분)
  * 입장 횟수(재입장 포함)
  * 최초 입장/최종 퇴장
  * (선택) 시작 전 대기시간, 종료 후 잔류시간
* **웨비나 전체**

  * 고유 참석자(Unique Attendees)
  * 재입장 비율/평균 입장 횟수
  * 평균 시청시간 / 중앙값 / 상위% 분위수(시청시간 분포)
  * “시청 완료율”(시청시간 ÷ 웨비나 본편 길이)

### 1.2 절대 원칙(현재 시스템과 합치)

* 라이브 참가자 화면은 **집계/조인 금지**, **가벼운 ping**만 수행.  
* 시간대별 전체 동시접속은 **기존 크론(1분) → 5분 버킷(upsert)** 흐름 유지.  
* 멀티테넌시/권한: “누가/어느 이벤트에/어디까지”를 항상 설명 가능해야 함.  

---

## 2) 전제 조건

### 2.1 이미 존재하는 것(As-Is)

* Presence Ping: `POST /api/webinars/[webinarId]/presence/ping`

  * 권장 2분마다 + 지터, `webinar_live_presence` upsert, `last_seen_at` 갱신 (60초 이내 중복 업데이트 억제) 
* Access Snapshot Cron: `/api/cron/webinar-access-snapshot`

  * 1분마다 실행, `last_seen_at >= now()-3분` 기준으로 활성 사용자 집계 → `webinar_access_logs`에 5분 버킷 누적(upsert) 
* 웨비나 시작시간: `webinar_start_time`가 이미 캠페인 기간과 분리되어 존재/사용 중 

### 2.2 바꾸면 안 되는 것

* `webinar_live_presence`의 “현재 접속” 목적(가벼운 upsert 기반)은 유지 (세션 이력 저장용으로 변질 금지). 
* 크론 기반 “전체 동시접속 추이” 수집/버킷 방식 유지. 
* 관리자 통계는 관리자 화면에서만(탭 클릭 시 로드, 자동 refresh 최소화).  

---

## 3) 핵심 아이디어: “세션 1행 + heartbeat 업데이트” 원리

### 3.1 왜 heartbeat가 필요한가?

* “입장 시작”만 기록하면 **퇴장 시점이 불명확**(브라우저 unload는 누락이 잦음)
* heartbeat는 “사용자가 아직 보고 있다”를 **짧은 요청으로 증명**하고,
* 서버는 heartbeat 간격(Δt)을 누적해서 **시청시간을 서버에서 결정론적으로 계산**한다.

### 3.2 부하가 왜 낮나?

* 매 heartbeat는:

  * (A) `webinar_live_presence` 1행 upsert(이미 하고 있음)
  * (B) “현재 세션 1행” update(추가 1행)
* 즉, **사용자당 O(1) write**만 발생. “로그를 매번 insert로 쌓는 구조”가 아니라서 폭증이 없다. 

---

## 4) 웨비나 시작/종료 “선언” 설계 (사용자 제안 반영)

사용자 제안:

* 종료시간(예정) 추가 → 그 기준으로 집계
* 실제 종료시간 입력 시 보정 가능
* 시작 30분 전 / 종료 30분 후까지는 집계(대기/잔류 인원 포함)
* 실제 시청시간은 시작~종료 기준으로 보정

### 4.1 데이터 모델(웹비나 스케줄 필드)

* 이미 존재: `webinar_start_time` 
* 추가(권장):

  * **종료시간(예정)**: scheduled end
  * **종료시간(실제)**: actual end (운영자가 “종료” 처리 시 기록)

> 결정 포인트(컬럼명): 기존 네이밍(`webinar_start_time`)과 일관성 유지가 기준.
> (예: start_time과 같은 prefix로 end_time을 정의)
> “예정/실제” 2종을 둘지, end_time 하나 + actual_end_time 하나를 둘지 Cursor Agent가 결정.

### 4.2 집계 윈도우 정의(하드코딩 금지)

* `pre_window_minutes` (기본 UI 추천값 30, 변경 가능)
* `post_window_minutes` (기본 UI 추천값 30, 변경 가능)

정의:

* **수집 윈도우(collect window)**

  * `collect_from = webinar_start_time - pre_window`
  * `collect_to = (actual_end_time ?? scheduled_end_time) + post_window`
* **본편 윈도우(main content window)**

  * `content_from = webinar_start_time`
  * `content_to = (actual_end_time ?? scheduled_end_time)`

**보정 규칙**

* 세션이 `collect window` 밖에서 발생해도 “기록”은 되지만,
* “시청시간 KPI”는 **content window에 대한 overlap만 집계**한다.
* `대기시간`은 `collect_from ~ content_from` overlap
* `잔류시간`은 `content_to ~ collect_to` overlap

---

## 5) DB 설계: “세션 이력 테이블” 추가 (기존 제안과 일치)

현재 문서에서도 개선 방향으로 **`webinar_user_sessions` 추가**가 명시되어 있으므로, 새 이름을 invent 하지 않고 그대로 간다.  

### 5.1 신규 테이블: `webinar_user_sessions` (개별 입장 세션 단위)

**핵심 설계 원칙**

* “한 번 입장” = “세션 1행”
* heartbeat는 **insert가 아니라 update**
* 최종 집계는 admin 통계 화면 또는 (선택) 크론으로 사전집계

**필드 구성(요구조건 중심, 세부 타입은 Cursor Agent 결정)**

* 식별/관계

  * `webinar_id` (FK)
  * `user_id` (FK, 가능한 한 유지 / 게스트도 user_id를 갖는 구조면 nullable 불필요)
  * `session_key`(클라이언트 생성, 재시도/중복 방지용)
* 시간

  * `entered_at` (세션 시작)
  * `last_heartbeat_at` (마지막 heartbeat)
  * `exited_at` (세션 종료, 없으면 열려있는 상태)
* 누적(서버 계산)

  * `watched_seconds_raw` (heartbeat Δt 누적)
  * (선택) `closed_reason` (client_exit / timeout / forced_close / etc)
* 메타(필요 최소)

  * `user_agent` / `referrer` 등은 “통계 가치가 확실할 때만”
  * IP는 개인정보 이슈가 있으니 “원문 저장이 필요할 때만”, 아니면 해시/마스킹 고려
* 멀티테넌시

  * `agency_id`, `client_id` (기존 트리거 fill_org_fields 패턴 적용 가능 여부 확인) 

**인덱스(쿼리 형태 기반)**

* `(webinar_id, entered_at desc)` : 웨비나별 세션 리스트
* `(webinar_id, user_id, entered_at desc)` : 개인별 입장 히스토리
* `(webinar_id) where exited_at is null` : 열려있는 세션 sweep
* `unique(session_key)` 또는 `(webinar_id, user_id, session_key)` : 중복 시작 방지

### 5.2 RLS/권한

* 참가자:

  * 자기 `user_id`에 대한 insert/update(heartbeat/update)만 허용
* 운영자/관리자(agency/client 멤버):

  * 소속 웨비나에 대한 select 허용
* 슈퍼관리자:

  * 전체 select

이 프로젝트는 **Guard Pattern + RLS** 이중 방어를 표준으로 쓰고 있으니 그 방식 고수.  

---

## 6) API 설계 (기존 endpoint 확장 우선)

### 6.1 결정 포인트: endpoint를 새로 만들지/기존 ping에 합칠지

**권장(부하/복잡도 최소화)**

* `presence/ping`를 확장해서 **세션 heartbeat도 같이 처리**

  * 네트워크 요청 1개로 통합
  * 기존 “현재 접속 집계” 흐름 유지 

**대안(분리, 명확하지만 요청 2개 가능)**

* 세션 전용 start/ping/exit endpoint 추가

> 선택 기준
>
> * “클라이언트 요청 수 최소화”가 최우선이면 통합
> * “라우트 책임 분리/관측성”이 더 중요하면 분리
>   단, 어떤 경우든 라이브 화면에서 **집계 쿼리**는 금지.

### 6.2 (권장안) `POST /api/webinars/[webinarId]/presence/ping` 확장 스펙

**Request에 옵션 필드 추가(하위호환)**

* `session_key` (필수: 세션 추적 활성화 시)
* `view_state` (선택)

  * `is_visible`: 탭이 보이는지
  * `is_active`: 최근 N초 내 유저 입력이 있었는지(선택)
  * (가능하면) `is_playing`: 플레이어 재생중인지(가능할 때만)

**서버 동작(항상 O(1))**

1. 기존대로 `webinar_live_presence` upsert + last_seen 갱신(60초 억제 유지) 
2. `session_key`가 있으면:

   * 없던 session_key면 `webinar_user_sessions`에 **세션 1행 insert**
   * 있던 session_key면 해당 row에 대해:

     * `Δt = now - last_heartbeat_at`를 계산(상한값 cap 적용)
     * `watched_seconds_raw += Δt`
     * `last_heartbeat_at = now`
3. `is_visible=false` 또는 `is_active=false`면:

   * watched_seconds_raw 누적을 “중지”하거나 “감쇠”하는 정책을 결정(아래 7.2 참고)

**중요: 서버가 누적시간을 계산해야 하는 이유**

* 클라이언트가 “내가 1시간 봤다”라고 보내는 방식은 조작 가능.
* heartbeat 기반 누적은 최소한 “서버가 받은 ping의 시간”으로 결정론적.

### 6.3 퇴장 처리(Exit)

**필수는 아님(heartbeat+timeout로 닫을 수 있음)**
하지만 정확도를 올리려면 권장:

* `pagehide`/`visibilitychange(hidden)`에서 마지막 ping을 한 번 더 보내고,
* 가능하면 `navigator.sendBeacon` 활용(서버리스에서도 수신 가능하도록 라우트가 작은 응답을 주면 됨)

서버는 exit를 받으면:

* 마지막 Δt 누적
* `exited_at` 기록
* `closed_reason='client_exit'`

---

## 7) Heartbeat 주기/정확도/부하 정책 (하드코딩 금지)

### 7.1 권장 기본값(“설정 가능”이 전제)

* **heartbeat interval(초)**: 60s 권장

  * 30s는 정확하지만 비용↑
  * 120s(현재 presence 권장)도 가능하지만 개인 시청시간 오차↑ 
* **stale timeout**: 3~5분 (현재 활성판정 3분과 합) 
* **Δt cap**: 예) heartbeat 간격의 2~3배

  * 탭 백그라운드/네트워크 지연으로 “한 번에 20분 누적” 같은 왜곡을 방지
  * cap 값은 env/config로 관리

> 구현 기준: 코드에 숫자를 박지 말고(하드코딩 금지),
> env 또는 “웨비나/클라이언트 설정”으로 승격 가능한 구조로 둔다.

### 7.2 “진짜 시청시간” 정의(정확도 정책)

**결정 포인트(정책 선택)**

1. **탭이 보일 때만 누적**(가장 단순/안전)

   * `document.visibilityState === 'visible'`일 때만 heartbeat 전송 또는 누적
2. **활동 기반 누적**(더 정확하지만 구현↑)

   * 최근 N초 내 입력(마우스/키보드/스크롤)이 없으면 누적 중지
3. **플레이어 재생 기반 누적**(가장 정확, 구현 난이도↑)

   * YouTube IFrame API 상태(playing/paused) 기반으로 누적

> 추천: 1)부터 먼저.
> 운영/분석팀이 “시청시간 과대 계상”을 문제 삼기 시작하면 2) → 3) 단계적으로 강화.

---

## 8) 세션 자동 종료(정합성) — 크론/배치

### 8.1 왜 필요한가

* exit 호출은 누락될 수 있음 → `exited_at`이 영원히 null이면 통계가 꼬임
* 따라서 **서버가 “stale” 기준으로 세션을 닫아줘야** 한다.

### 8.2 세션 sweeper 크론(신규 또는 기존 크론 확장)

* 주기: 5분 또는 10분 (1분까지는 불필요)
* 대상: `exited_at is null AND last_heartbeat_at < now - stale_timeout`
* 처리:

  * `exited_at = last_heartbeat_at` (또는 now가 아니라 last_heartbeat로 닫는 게 과대계상 방지)
  * `closed_reason='timeout'`

### 8.3 종료시간 기반 강제 보정(사용자 아이디어 반영)

웨비나에 `collect_to`가 정의되어 있으면:

* `exited_at is null`인 세션이 `collect_to`를 초과해서 열려있으면

  * `exited_at = min(last_heartbeat_at, collect_to)`
  * `closed_reason='forced_close_by_schedule'`

이렇게 하면 “종료 후 30분까지만 집계” 정책과 충돌이 없다.

---

## 9) 통계 산출 방식(관리자 조회용)

### 9.1 개인별 시청시간(본편 기준 보정 포함)

**개념**

* 각 세션은 `entered_at ~ exited_at` 구간을 가진다(없으면 sweeper로 채움)
* 본편 시청시간 = `overlap(session_interval, [content_from, content_to])`의 합
* 대기시간 = `overlap(session_interval, [collect_from, content_from])`의 합

**개인별 KPI 예시**

* `visit_count = count(*)`
* `total_watch_seconds = sum(overlap_seconds)`
* `first_entered_at = min(entered_at)`
* `last_exited_at = max(exited_at)`
* `completion_rate = min(1, total_watch_seconds / content_duration_seconds)`

### 9.2 “대기 인원” 지표(사용자 요구)

* “대기 고유 인원”: collect_from~content_from 사이 overlap이 1초 이상 있는 고유 user 수
* “대기 최대 동시 인원”: 기존 `webinar_access_logs` 타임라인에서 pre-window 구간 max_participants 최대값을 쓰면 된다(이미 크론이 수집). 

### 9.3 재입장(들락날락) 지표

* `returning_users = count(distinct user_id where visit_count >= 2)`
* `avg_visits_per_user = avg(visit_count)`
* “재입장 시간대”: 세션 entered_at 히스토그램(관리자 통계에서만)

### 9.4 성능 원칙(조회)

* 웨비나 stats 탭에서만 조회, from/to 필수로 데이터량 제한, 병렬 쿼리.  
* 필요 시 “세션 요약 테이블(사전 집계)”는 **Phase 2**로 두고, 먼저는 인덱싱으로 해결.

---

## 10) 예상 부하 산정(운영 판단 기준)

### 10.1 요청 수(heartbeat)

* 동시 시청자 N, heartbeat 60초면:

  * RPS ≈ N / 60
  * N=600 → 10 rps
  * N=1800 → 30 rps

### 10.2 DB write

* heartbeat 1회당:

  * presence upsert 1 + sessions update 1
  * 단, presence는 60초 억제로 write가 줄 수 있음(현 문서 기준) 
* 즉 “대량 insert 로그 적재”가 아니라 충분히 감당 가능한 형태.

> 리스크 포인트는 “DB write 자체”보다
> **서버리스 함수 cold start / 동시성 / 재시도 폭주**이므로, 클라이언트 지터(+/-)와 서버 측 rate cap이 중요.

---

## 11) 구현 단계 제안 (Phase 기반)

### Phase 0 — 스케줄 선언(종료시간 UI/DB)

**목적**: “집계 윈도우”와 “보정 기준”을 운영자가 명시 가능하게

* 웨비나 설정 UI에:

  * 종료시간(예정)
  * 종료시간(실제)
  * pre/post window minutes(기본 30, 수정 가능)
* DoD

  * 저장/조회/표시(입장 페이지/통계 API에서 사용 가능)
  * null일 때의 fallback(예정/실제 우선순위) 정의 완료

### Phase 1 — 세션 테이블 + heartbeat 누적(핵심)

**목적**: 개인 시청시간/입장횟수 확보

* `webinar_user_sessions` 마이그레이션
* `presence/ping`에 `session_key`를 받아 세션 insert/update 동작 추가(하위호환)
* 클라이언트(라이브 페이지)에서:

  * 진입 시 session_key 생성
  * heartbeat 스케줄러(지터 포함)
  * visibility 기반으로 ping 제어(최소 정책 1 적용)
* DoD

  * 한 사용자가 여러 번 들어오면 `webinar_user_sessions`에 세션이 누적
  * watched_seconds_raw가 heartbeat에 의해 증가
  * 통계 화면에서 “입장횟수/총 시청초”가 계산 가능(쿼리로라도)

### Phase 2 — 세션 sweeper(정합성) + 통계 UX

**목적**: exit 누락/장기 오픈 세션 제거 + 운영자가 쓰기 좋은 KPI

* sweeper 크론 추가(또는 기존 크론들과 동일 인증 패턴/멱등성 적용) 
* 통계 탭에 “참여/시청시간” 섹션 추가
* CSV export(선택)
* DoD

  * exited_at null 세션이 stale 기준으로 자동 종료됨
  * 종료시간 기반 forced_close 동작
  * 대기 인원/본편 시청시간 보정 지표 노출

---

## 12) 리스크 체크리스트 (Cursor Agent용)

### 성능

* [ ] heartbeat interval, stale timeout, Δt cap이 **설정 가능**한가(코드 하드코딩 금지)
* [ ] presence upsert는 기존 “60초 억제” 로직 유지되는가 
* [ ] 세션 update도 “너무 잦은 update” 방지(필요 시 최소 간격) 고려했는가

### 데이터 정합성

* [ ] exit 누락 시에도 sweeper로 일관된 종료가 되는가
* [ ] Δt cap으로 비정상 누적이 방지되는가
* [ ] multi-tab / multi-device 시 중복 누적을 어떻게 정의할지(정책) 문서화했는가

  * 권장: “세션은 중복 허용(로그)” + “개인 KPI는 본편 길이로 상한(보정)” 같은 방식

### 권한/멀티테넌시

* [ ] 참가자가 타인 세션을 조회/수정할 수 없는가(RLS)
* [ ] 운영자/관리자는 소속 웨비나만 조회 가능한가(Guard + RLS) 
* [ ] org_fields 채움이 표준 방식과 일치하는가 

### 개인정보

* [ ] IP/UA/referrer를 저장할 필요가 “통계 가치”로 설명 가능한가
* [ ] 원문 IP 저장이 필요 없다면 해시/마스킹 정책을 택했는가

---

## 13) “웨비나 통계 집계” 추가 보완 아이템(우선순위 제안)

이미 있는 것: 동시접속 추이(버킷), 등록자 수/출처 등 

세션 기반으로 보강하면 좋은 것(가치 대비 난이도 순)

1. **고유 참석자(Unique Attendees)**: content window에 overlap이 있는 고유 user 수
2. **재입장 지표**: visit_count≥2 비율
3. **시청시간 분포**: 5분 이상/10분 이상/30분 이상 등 구간별 인원(운영 KPI로 매우 유용)
4. **시청 완료율**: content_duration 대비 시청 비율
5. **참여도 결합 지표(Phase 3)**

   * “시청시간 상위 그룹의 채팅/질문 참여율”
   * 단, 라이브 화면에서 계산 금지 → 관리자 통계에서만/또는 크론 사전집계

---

# 최종 결론(설계 방향)

* “입장할 때마다 로그 남기기”는 **세션 1행 insert**로 해결(부하 낮음).
* “시청시간”은 **heartbeat 기반으로 세션 row를 update**해서 서버가 누적(조작/누락에 강함).
* “시작 30분 전/종료 30분 후 수집 + 본편 구간으로 보정”은
  **스케줄 필드(예정/실제) + pre/post window 설정**으로 깔끔하게 달성 가능.
* 전체 동시접속 추이는 기존 크론/버킷을 그대로 사용하고, 개인 시청시간은 세션 테이블로 보강한다.  

원하면, 다음 단계로 **“Phase 0~2를 실제 코드 변경으로 옮길 때 Cursor Agent가 체크해야 할 ‘변경 영향도/롤백 플랜/마이그레이션 순서’”**까지 이어서 문서 형태로 더 촘촘하게 내려줄게.
